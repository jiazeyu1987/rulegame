# Epic8-子任务01: 通关/死亡条件识别

## 开发状态
子任务开发完成

## 开发方案

### 1. 开发目标
实现游戏结束条件的准确识别和评估，包括S/A/B/C四个通关等级和死亡条件检测。

### 2. 设计方案
- 建立条件评估引擎，支持复杂表达式
- 实时监控系统状态变化
- 实现条件优先级和冲突处理
- 提供清晰的条件达成反馈

### 3. 实现方式

#### 核心类型定义
```typescript
// 游戏状态接口
interface GameState {
  attributes: PlayerAttributes;
  inventory: string[];
  flags: Record<string, boolean>;
  day: number;
  time: number;
  location: string;
}

// 玩家属性接口
interface PlayerAttributes {
  health: number;        // 生命值 (0-100)
  sanity: number;        // 理智值 (0-100)
  hunger: number;        // 饱食度 (0-100)
  intelligence: number;  // 智力 (0-100)
  strength: number;      // 力量 (0-100)
  speed: number;         // 速度 (0-100)
  luck: number;          // 运气 (0-100)
  profession: string;    // 职业
}

// 条件评估结果
interface EvaluationResult {
  winLevel?: WinLevel;    // 'S' | 'A' | 'B' | 'C'
  deathReason?: DeathReason;
  triggeredConditions: Condition[];
  priority: number;
  timestamp: number;
}

// 通关等级
type WinLevel = 'S' | 'A' | 'B' | 'C';

// 死亡原因
type DeathReason = 'health_zero' | 'sanity_zero' | 'hunger_zero' | 'rule_violation' | 'special_event';

// 条件接口
interface Condition {
  id: string;
  type: 'win' | 'death';
  level?: WinLevel;
  expression: string;
  priority: number;
  description: string;
  message: string;
}
```

#### 条件评估引擎实现
```typescript
class ConditionEvaluator {
  private conditions: Condition[] = [];
  private cache: Map<string, EvaluationResult> = new Map();
  private cacheTimeout = 1000; // 1秒缓存

  constructor(conditions: Condition[]) {
    this.conditions = conditions.sort((a, b) => b.priority - a.priority);
  }

  /**
   * 评估所有条件
   */
  evaluateConditions(state: GameState): EvaluationResult {
    const cacheKey = this.generateCacheKey(state);
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached;
    }

    const result = this.performEvaluation(state);
    this.cache.set(cacheKey, result);
    return result;
  }

  /**
   * 检查通关条件
   */
  checkWinConditions(state: GameState): WinLevel | null {
    for (const condition of this.conditions) {
      if (condition.type === 'win' && this.evaluateExpression(condition.expression, state)) {
        return condition.level!;
      }
    }
    return null;
  }

  /**
   * 检查死亡条件
   */
  checkDeathConditions(state: GameState): DeathReason | null {
    for (const condition of this.conditions) {
      if (condition.type === 'death' && this.evaluateExpression(condition.expression, state)) {
        return this.parseDeathReason(condition.expression);
      }
    }
    return null;
  }

  /**
   * 验证条件表达式
   */
  validateConditionExpression(expr: string): { valid: boolean; error?: string } {
    try {
      this.parseExpression(expr);
      return { valid: true };
    } catch (error) {
      return { valid: false, error: (error as Error).message };
    }
  }

  /**
   * 执行条件评估
   */
  private performEvaluation(state: GameState): EvaluationResult {
    const triggeredConditions: Condition[] = [];
    let winLevel: WinLevel | undefined;
    let deathReason: DeathReason | undefined;
    let maxPriority = -1;

    for (const condition of this.conditions) {
      if (this.evaluateExpression(condition.expression, state)) {
        triggeredConditions.push(condition);
        
        if (condition.priority > maxPriority) {
          maxPriority = condition.priority;
          
          if (condition.type === 'win') {
            winLevel = condition.level;
            deathReason = undefined;
          } else if (condition.type === 'death') {
            deathReason = this.parseDeathReason(condition.expression);
            winLevel = undefined;
          }
        }
      }
    }

    return {
      winLevel,
      deathReason,
      triggeredConditions,
      priority: maxPriority,
      timestamp: Date.now()
    };
  }

  /**
   * 评估表达式
   */
  private evaluateExpression(expr: string, state: GameState): boolean {
    try {
      // 简单的表达式评估器
      // 支持基本运算符: &&, ||, !, ==, !=, >, <, >=, <=
      // 支持属性访问: attributes.health, inventory.length, flags.xxx
      return this.parseAndEvaluate(expr, state);
    } catch (error) {
      console.error('Expression evaluation error:', error);
      return false;
    }
  }

  /**
   * 解析并评估表达式
   */
  private parseAndEvaluate(expr: string, state: GameState): boolean {
    // 替换属性引用
    let processedExpr = expr;
    
    // 替换属性访问
    processedExpr = processedExpr.replace(/attributes\.(\w+)/g, (match, attr) => {
      return String((state.attributes as any)[attr] || 0);
    });
    
    // 替换库存检查
    processedExpr = processedExpr.replace(/inventory\.length/g, String(state.inventory.length));
    processedExpr = processedExpr.replace(/inventory\.includes\(['"](.+?)['"]\)/g, (match, item) => {
      return String(state.inventory.includes(item));
    });
    
    // 替换标记检查
    processedExpr = processedExpr.replace(/flags\.(\w+)/g, (match, flag) => {
      return String(state.flags[flag] || false);
    });
    
    // 替换其他状态
    processedExpr = processedExpr.replace(/day/g, String(state.day));
    processedExpr = processedExpr.replace(/time/g, String(state.time));
    processedExpr = processedExpr.replace(/location/g, `'${state.location}'`);

    // 安全评估表达式
    return this.safeEvaluate(processedExpr);
  }

  /**
   * 安全评估处理后的表达式
   */
  private safeEvaluate(expr: string): boolean {
    // 只允许安全的字符和运算符
    const safePattern = /^[0-9\s+\-*/><=!&|()'.]+$/;
    if (!safePattern.test(expr)) {
      throw new Error('Unsafe expression');
    }

    // 使用Function构造器安全评估
    try {
      return new Function(`return (${expr})`)();
    } catch {
      return false;
    }
  }

  /**
   * 解析死亡原因
   */
  private parseDeathReason(expr: string): DeathReason {
    if (expr.includes('health')) return 'health_zero';
    if (expr.includes('sanity')) return 'sanity_zero';
    if (expr.includes('hunger')) return 'hunger_zero';
    if (expr.includes('rule')) return 'rule_violation';
    return 'special_event';
  }

  /**
   * 解析表达式（用于验证）
   */
  private parseExpression(expr: string): void {
    // 简单的语法验证
    const parentheses = (expr.match(/[()]/g) || []).reduce((acc, char) => {
      return char === '(' ? acc + 1 : acc - 1;
    }, 0);
    
    if (parentheses !== 0) {
      throw new Error('Unbalanced parentheses');
    }
  }

  /**
   * 生成缓存键
   */
  private generateCacheKey(state: GameState): string {
    return JSON.stringify({
      attributes: state.attributes,
      inventory: state.inventory,
      flags: state.flags,
      day: state.day,
      time: state.time,
      location: state.location
    });
  }

  /**
   * 清除缓存
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * 获取统计信息
   */
  getStats(): { cacheSize: number; conditionCount: number } {
    return {
      cacheSize: this.cache.size,
      conditionCount: this.conditions.length
    };
  }
}
```

#### 使用示例
```typescript
// 定义条件
const conditions: Condition[] = [
  {
    id: 'win_s',
    type: 'win',
    level: 'S',
    expression: 'day >= 7 && attributes.health >= 80 && attributes.sanity >= 80 && inventory.includes("golden_key")',
    priority: 100,
    description: '完美通关：存活7天且保持高属性并获得黄金钥匙',
    message: '恭喜！你以完美的表现通关了游戏！'
  },
  {
    id: 'win_a',
    type: 'win',
    level: 'A',
    expression: 'day >= 7 && attributes.health >= 60 && attributes.sanity >= 60',
    priority: 90,
    description: '优秀通关：存活7天且保持良好状态',
    message: '很好！你成功通关了游戏！'
  },
  {
    id: 'win_b',
    type: 'win',
    level: 'B',
    expression: 'day >= 7',
    priority: 80,
    description: '普通通关：存活7天',
    message: '你勉强通关了游戏。'
  },
  {
    id: 'win_c',
    type: 'win',
    level: 'C',
    expression: 'day >= 5 && attributes.health > 0',
    priority: 70,
    description: '勉强通关：存活5天',
    message: '你以最低标准通关了游戏。'
  },
  {
    id: 'death_health',
    type: 'death',
    expression: 'attributes.health <= 0',
    priority: 1000,
    description: '生命值归零死亡',
    message: '你的生命走到了尽头...'
  },
  {
    id: 'death_sanity',
    type: 'death',
    expression: 'attributes.sanity <= 0',
    priority: 1000,
    description: '理智值归零死亡',
    message: '你的精神崩溃了...'
  },
  {
    id: 'death_hunger',
    type: 'death',
    expression: 'attributes.hunger <= 0',
    priority: 1000,
    description: '饥饿死亡',
    message: '你被饿死了...'
  }
];

// 创建评估器
const evaluator = new ConditionEvaluator(conditions);

// 游戏状态
const gameState: GameState = {
  attributes: {
    health: 85,
    sanity: 75,
    hunger: 60,
    intelligence: 70,
    strength: 65,
    speed: 60,
    luck: 50,
    profession: 'student'
  },
  inventory: ['golden_key', 'food', 'water'],
  flags: { rule1_obeyed: true, rule2_broken: false },
  day: 7,
  time: 1200,
  location: 'dormitory'
};

// 评估条件
const result = evaluator.evaluateConditions(gameState);
console.log('评估结果:', result);
```

### 4. 关键技术点
- **条件表达式解析和执行**: 支持复杂逻辑表达式，包括属性访问、库存检查、标记验证
- **实时状态监控和触发机制**: 缓存机制确保性能，优先级处理避免冲突
- **条件优先级算法**: 高优先级条件优先生效，死亡条件具有最高优先级
- **性能优化**: 表达式缓存、增量评估、内存管理
- **安全性**: 表达式白名单验证，防止代码注入

### 5. 依赖项
- Epic3脚本解析（条件定义）
- Epic4状态管理（评估数据）
- TypeScript 4.5+ (类型安全)
- Node.js 16+ (运行时环境)

## Milestone

- Day 1: 条件评估引擎架构和基础解析
- Day 2: 通关/死亡条件检测实现
- Day 3: 实时监控和反馈机制完善

## 测试方案

### 功能点测试
- 四种通关等级正确识别
- 死亡条件准确检测
- 条件优先级正确处理
- 复杂条件表达式评估

### 异常测试
- 无效条件表达式处理
- 条件冲突解决机制
- 循环依赖检测
- 性能边界测试

### 性能验证
- 条件评估响应时间<50ms
- 实时监控资源消耗<5%
- 大数量条件处理性能
- 内存使用稳定性