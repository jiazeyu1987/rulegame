# Epic10-子任务01: 错误处理与日志系统

## 开发状态
子任务开发完成

## 开发方案

### 1. 开发目标
建立完整的错误处理和日志记录系统，确保游戏稳定性和问题排查能力。

### 2. 设计方案
- React错误边界捕获UI异常
- 统一的错误处理机制
- 本地日志文件系统
- 用户友好的错误提示
- 日志轮转和归档
- 性能监控和异常恢复

### 3. 实现方式

#### 核心类型定义
```typescript
// 日志级别
export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';

// 日志条目接口
export interface LogEntry {
  id: string;
  timestamp: number;
  level: LogLevel;
  message: string;
  context?: Record<string, any>;
  stackTrace?: string;
  userAgent?: string;
  url?: string;
  userId?: string;
}

// 日志配置接口
export interface LogConfig {
  maxFileSize: number;        // 最大文件大小(字节)
  maxFiles: number;           // 最大文件数量
  logLevel: LogLevel;         // 日志级别
  enableConsole: boolean;     // 是否启用控制台输出
  enableFile: boolean;        // 是否启用文件输出
  enableRemote: boolean;      // 是否启用远程日志
  compression: boolean;       // 是否压缩旧日志
}

// 错误分类
export type ErrorCategory = 'ui' | 'logic' | 'network' | 'storage' | 'validation' | 'unknown';

// 错误信息接口
export interface AppError {
  id: string;
  category: ErrorCategory;
  message: string;
  originalError?: Error;
  context?: Record<string, any>;
  timestamp: number;
  recoverable: boolean;
  userMessage?: string;
}

// 错误边界属性接口
export interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: AppError; reset: () => void }>;
  onError?: (error: AppError) => void;
  resetOnPropsChange?: boolean;
}

// 错误边界状态接口
export interface ErrorBoundaryState {
  hasError: boolean;
  error: AppError | null;
  errorInfo: React.ErrorInfo | null;
}

// 性能指标接口
export interface PerformanceMetrics {
  timestamp: number;
  memoryUsage?: number;
  cpuUsage?: number;
  renderTime?: number;
  networkLatency?: number;
}
```

#### 日志管理器实现
```typescript
import { v4 as uuidv4 } from 'uuid';

/**
 * 日志管理器 - 负责日志的记录、存储和管理
 */
export class LogManager {
  private config: LogConfig;
  private logQueue: LogEntry[] = [];
  private isProcessing = false;
  private currentFileSize = 0;
  private logFileName = 'game.log';
  
  constructor(config: Partial<LogConfig> = {}) {
    this.config = {
      maxFileSize: 5 * 1024 * 1024, // 5MB
      maxFiles: 10,
      logLevel: 'info',
      enableConsole: true,
      enableFile: true,
      enableRemote: false,
      compression: true,
      ...config
    };
  }

  /**
   * 记录调试日志
   */
  debug(message: string, context?: Record<string, any>): void {
    this.log('debug', message, context);
  }

  /**
   * 记录信息日志
   */
  info(message: string, context?: Record<string, any>): void {
    this.log('info', message, context);
  }

  /**
   * 记录警告日志
   */
  warn(message: string, context?: Record<string, any>): void {
    this.log('warn', message, context);
  }

  /**
   * 记录错误日志
   */
  error(message: string, context?: Record<string, any>): void {
    this.log('error', message, context);
  }

  /**
   * 记录致命错误日志
   */
  fatal(message: string, context?: Record<string, any>): void {
    this.log('fatal', message, context);
  }

  /**
   * 核心日志记录方法
   */
  private log(level: LogLevel, message: string, context?: Record<string, any>): void {
    // 检查日志级别
    if (!this.shouldLog(level)) {
      return;
    }

    const logEntry: LogEntry = {
      id: uuidv4(),
      timestamp: Date.now(),
      level,
      message,
      context,
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,
      url: typeof window !== 'undefined' ? window.location.href : undefined
    };

    // 如果是错误级别，添加堆栈信息
    if (level === 'error' || level === 'fatal') {
      logEntry.stackTrace = new Error().stack;
    }

    // 添加到队列
    this.logQueue.push(logEntry);
    
    // 立即输出到控制台
    if (this.config.enableConsole) {
      this.outputToConsole(logEntry);
    }

    // 异步处理文件输出
    if (this.config.enableFile) {
      this.processLogQueue();
    }
  }

  /**
   * 检查是否应该记录日志
   */
  private shouldLog(level: LogLevel): boolean {
    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error', 'fatal'];
    const currentLevelIndex = levels.indexOf(this.config.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    
    return messageLevelIndex >= currentLevelIndex;
  }

  /**
   * 输出到控制台
   */
  private outputToConsole(logEntry: LogEntry): void {
    const consoleMethod = this.getConsoleMethod(logEntry.level);
    const timestamp = new Date(logEntry.timestamp).toISOString();
    const logMessage = `[${timestamp}] [${logEntry.level.toUpperCase()}] ${logEntry.message}`;
    
    if (logEntry.context) {
      consoleMethod(logMessage, logEntry.context);
    } else {
      consoleMethod(logMessage);
    }
  }

  /**
   * 获取控制台输出方法
   */
  private getConsoleMethod(level: LogLevel): (...args: any[]) => void {
    switch (level) {
      case 'debug':
        return console.debug;
      case 'info':
        return console.info;
      case 'warn':
        return console.warn;
      case 'error':
      case 'fatal':
        return console.error;
      default:
        return console.log;
    }
  }

  /**
   * 处理日志队列
   */
  private async processLogQueue(): Promise<void> {
    if (this.isProcessing || this.logQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      const logsToProcess = [...this.logQueue];
      this.logQueue = [];

      for (const logEntry of logsToProcess) {
        await this.writeToFile(logEntry);
      }
    } catch (error) {
      console.error('处理日志队列失败:', error);
    } finally {
      this.isProcessing = false;
      
      // 如果队列中又有新日志，继续处理
      if (this.logQueue.length > 0) {
        setTimeout(() => this.processLogQueue(), 0);
      }
    }
  }

  /**
   * 写入日志到文件
   */
  private async writeToFile(logEntry: LogEntry): Promise<void> {
    try {
      const logLine = JSON.stringify(logEntry) + '\n';
      const logSize = new Blob([logLine]).size;

      // 检查是否需要轮转日志
      if (this.currentFileSize + logSize > this.config.maxFileSize) {
        await this.rotateLogs();
      }

      // 这里应该实现实际的文件写入逻辑
      // 由于浏览器环境的限制，这里使用localStorage作为演示
      const existingLogs = localStorage.getItem(this.logFileName) || '';
      localStorage.setItem(this.logFileName, existingLogs + logLine);
      
      this.currentFileSize += logSize;
    } catch (error) {
      console.error('写入日志文件失败:', error);
    }
  }

  /**
   * 轮转日志文件
   */
  private async rotateLogs(): Promise<void> {
    try {
      // 实现日志轮转逻辑
      for (let i = this.config.maxFiles - 1; i > 0; i--) {
        const oldFileName = i === 1 ? this.logFileName : `${this.logFileName}.${i - 1}`;
        const newFileName = `${this.logFileName}.${i}`;
        
        const oldContent = localStorage.getItem(oldFileName);
        if (oldContent) {
          localStorage.setItem(newFileName, oldContent);
        }
      }
      
      // 清空当前日志文件
      localStorage.setItem(this.logFileName, '');
      this.currentFileSize = 0;
      
      this.info('日志文件轮转完成');
    } catch (error) {
      this.error('日志文件轮转失败', { error });
    }
  }

  /**
   * 获取日志文件内容
   */
  async getLogs(level?: LogLevel, limit?: number): Promise<LogEntry[]> {
    try {
      const logs: LogEntry[] = [];
      const logContent = localStorage.getItem(this.logFileName) || '';
      
      const lines = logContent.split('\n').filter(line => line.trim());
      
      for (const line of lines) {
        try {
          const logEntry: LogEntry = JSON.parse(line);
          
          if (!level || logEntry.level === level) {
            logs.push(logEntry);
          }
        } catch (error) {
          console.error('解析日志行失败:', error);
        }
      }
      
      // 按时间戳排序（最新的在前）
      logs.sort((a, b) => b.timestamp - a.timestamp);
      
      // 限制返回数量
      if (limit) {
        return logs.slice(0, limit);
      }
      
      return logs;
    } catch (error) {
      this.error('获取日志失败', { error });
      return [];
    }
  }

  /**
   * 清理旧日志
   */
  async clearLogs(): Promise<void> {
    try {
      localStorage.removeItem(this.logFileName);
      
      // 清理轮转的文件
      for (let i = 1; i < this.config.maxFiles; i++) {
        localStorage.removeItem(`${this.logFileName}.${i}`);
      }
      
      this.currentFileSize = 0;
      this.info('日志清理完成');
    } catch (error) {
      this.error('清理日志失败', { error });
    }
  }

  /**
   * 获取日志统计信息
   */
  async getStats(): Promise<{
    totalLogs: number;
    logSize: number;
    levelCounts: Record<LogLevel, number>;
  }> {
    try {
      const logs = await this.getLogs();
      const levelCounts: Record<LogLevel, number> = {
        debug: 0,
        info: 0,
        warn: 0,
        error: 0,
        fatal: 0
      };
      
      logs.forEach(log => {
        levelCounts[log.level]++;
      });
      
      return {
        totalLogs: logs.length,
        logSize: this.currentFileSize,
        levelCounts
      };
    } catch (error) {
      this.error('获取日志统计失败', { error });
      return {
        totalLogs: 0,
        logSize: 0,
        levelCounts: { debug: 0, info: 0, warn: 0, error: 0, fatal: 0 }
      };
    }
  }
}

/**
 * 错误边界组件实现
 */
export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private logManager: LogManager;
  
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
    
    this.logManager = new LogManager();
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error: {
        id: uuidv4(),
        category: 'ui',
        message: error.message,
        originalError: error,
        timestamp: Date.now(),
        recoverable: true,
        userMessage: '界面加载出现问题，请刷新页面重试。'
      }
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    this.setState({ errorInfo });
    
    // 记录错误日志
    this.logError(this.state.error!, errorInfo);
    
    // 调用用户提供的错误处理回调
    if (this.props.onError) {
      this.props.onError(this.state.error!);
    }
  }

  componentDidUpdate(prevProps: ErrorBoundaryProps): void {
    // 如果props发生变化且启用了重置功能，则重置错误状态
    if (this.props.resetOnPropsChange && prevProps !== this.props) {
      this.reset();
    }
  }

  private logError(error: AppError, errorInfo: React.ErrorInfo): void {
    this.logManager.error('React错误边界捕获到异常', {
      errorId: error.id,
      errorMessage: error.message,
      errorCategory: error.category,
      componentStack: errorInfo.componentStack,
      stackTrace: error.originalError?.stack
    });
  }

  reset = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render(): React.ReactNode {
    if (this.state.hasError && this.state.error) {
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback;
        return <FallbackComponent error={this.state.error} reset={this.reset} />;
      }
      
      return (
        <div className="error-boundary-fallback">
          <h2>出错了</h2>
          <p>{this.state.error.userMessage}</p>
          <details>
            <summary>错误详情</summary>
            <pre>{this.state.error.message}</pre>
            {this.state.errorInfo?.componentStack && (
              <pre>{this.state.errorInfo.componentStack}</pre>
            )}
          </details>
          <button onClick={this.reset}>重试</button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

#### 错误处理工具函数
```typescript
/**
 * 错误处理工具类
 */
export class ErrorHandler {
  private logManager: LogManager;
  
  constructor(logManager?: LogManager) {
    this.logManager = logManager || new LogManager();
  }

  /**
   * 创建应用错误
   */
  createError(
    message: string,
    category: ErrorCategory = 'unknown',
    originalError?: Error,
    context?: Record<string, any>,
    recoverable: boolean = true,
    userMessage?: string
  ): AppError {
    return {
      id: uuidv4(),
      category,
      message,
      originalError,
      context,
      timestamp: Date.now(),
      recoverable,
      userMessage: userMessage || this.getDefaultUserMessage(category)
    };
  }

  /**
   * 获取默认用户消息
   */
  private getDefaultUserMessage(category: ErrorCategory): string {
    const messages: Record<ErrorCategory, string> = {
      ui: '界面加载出现问题，请刷新页面重试。',
      logic: '程序逻辑出现错误，请联系技术支持。',
      network: '网络连接失败，请检查网络设置。',
      storage: '数据存储失败，请检查存储空间。',
      validation: '输入数据验证失败，请检查输入内容。',
      unknown: '发生未知错误，请稍后重试。'
    };
    
    return messages[category] || messages.unknown;
  }

  /**
   * 处理错误
   */
  handleError(error: AppError): void {
    // 记录错误日志
    this.logManager.error('应用错误', {
      errorId: error.id,
      category: error.category,
      message: error.message,
      context: error.context,
      stackTrace: error.originalError?.stack
    });

    // 根据错误类型进行不同的处理
    switch (error.category) {
      case 'network':
        this.handleNetworkError(error);
        break;
      case 'storage':
        this.handleStorageError(error);
        break;
      case 'validation':
        this.handleValidationError(error);
        break;
      default:
        this.handleGenericError(error);
    }
  }

  private handleNetworkError(error: AppError): void {
    this.logManager.warn('网络错误，尝试重连机制', { errorId: error.id });
    // 实现重连逻辑
  }

  private handleStorageError(error: AppError): void {
    this.logManager.warn('存储错误，尝试清理空间', { errorId: error.id });
    // 实现存储清理逻辑
  }

  private handleValidationError(error: AppError): void {
    this.logManager.info('验证错误，提示用户修正', { errorId: error.id });
    // 实现用户提示逻辑
  }

  private handleGenericError(error: AppError): void {
    if (error.recoverable) {
      this.logManager.info('可恢复错误，尝试自动恢复', { errorId: error.id });
      // 实现自动恢复逻辑
    } else {
      this.logManager.error('不可恢复错误', { errorId: error.id });
      // 实现严重错误处理逻辑
    }
  }
}
```

#### 性能监控实现
```typescript
/**
 * 性能监控器
 */
export class PerformanceMonitor {
  private logManager: LogManager;
  private metrics: PerformanceMetrics[] = [];
  private isMonitoring = false;
  
  constructor(logManager?: LogManager) {
    this.logManager = logManager || new LogManager();
  }

  /**
   * 开始性能监控
   */
  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.logManager.info('性能监控开始');
    
    // 定期收集性能指标
    this.collectMetrics();
  }

  /**
   * 停止性能监控
   */
  stopMonitoring(): void {
    this.isMonitoring = false;
    this.logManager.info('性能监控停止');
  }

  /**
   * 收集性能指标
   */
  private collectMetrics(): void {
    if (!this.isMonitoring) return;
    
    try {
      const metric: PerformanceMetrics = {
        timestamp: Date.now()
      };
      
      // 收集内存使用信息
      if ((performance as any).memory) {
        metric.memoryUsage = (performance as any).memory.usedJSHeapSize;
      }
      
      // 收集其他性能指标...
      
      this.metrics.push(metric);
      
      // 如果指标过多，清理旧的
      if (this.metrics.length > 1000) {
        this.metrics = this.metrics.slice(-500);
      }
      
      // 继续收集
      setTimeout(() => this.collectMetrics(), 5000); // 每5秒收集一次
    } catch (error) {
      this.logManager.error('收集性能指标失败', { error });
    }
  }

  /**
   * 记录自定义性能指标
   */
  recordMetric(type: string, value: number, context?: Record<string, any>): void {
    this.logManager.info(`性能指标: ${type}`, { value, context });
  }

  /**
   * 获取性能报告
   */
  getPerformanceReport(): {
    averageMetrics: Record<string, number>;
    peakMetrics: Record<string, number>;
    totalSamples: number;
  } {
    if (this.metrics.length === 0) {
      return {
        averageMetrics: {},
        peakMetrics: {},
        totalSamples: 0
      };
    }
    
    // 计算平均和峰值指标
    const averageMetrics: Record<string, number> = {};
    const peakMetrics: Record<string, number> = {};
    
    // 实现指标计算逻辑...
    
    return {
      averageMetrics,
      peakMetrics,
      totalSamples: this.metrics.length
    };
  }
}
```

#### 使用示例和配置
```typescript
// 应用配置示例
import { LogManager, ErrorBoundary, ErrorHandler, PerformanceMonitor } from './error-handling';

// 创建日志管理器实例
const logManager = new LogManager({
  maxFileSize: 10 * 1024 * 1024, // 10MB
  maxFiles: 20,
  logLevel: 'info',
  enableConsole: process.env.NODE_ENV === 'development',
  enableFile: true,
  enableRemote: false,
  compression: true
});

// 创建错误处理器
const errorHandler = new ErrorHandler(logManager);

// 创建性能监控器
const performanceMonitor = new PerformanceMonitor(logManager);

// 应用初始化
function initializeApp() {
  // 启动性能监控
  performanceMonitor.startMonitoring();
  
  // 记录应用启动
  logManager.info('应用启动', {
    version: process.env.APP_VERSION,
    environment: process.env.NODE_ENV,
    userAgent: navigator.userAgent
  });
  
  // 设置全局错误处理
  window.addEventListener('error', (event) => {
    const appError = errorHandler.createError(
      event.message,
      'ui',
      event.error,
      { filename: event.filename, lineno: event.lineno, colno: event.colno }
    );
    errorHandler.handleError(appError);
  });
  
  // 设置未处理的Promise拒绝
  window.addEventListener('unhandledrejection', (event) => {
    const appError = errorHandler.createError(
      '未处理的Promise拒绝',
      'logic',
      event.reason instanceof Error ? event.reason : new Error(String(event.reason))
    );
    errorHandler.handleError(appError);
  });
}

// React组件中使用
const App: React.FC = () => {
  const handleError = (error: AppError) => {
    // 自定义错误处理逻辑
    console.error('应用错误:', error);
  };
  
  return (
    <ErrorBoundary
      onError={handleError}
      resetOnPropsChange={true}
      fallback={({ error, reset }) => (
        <div className="error-fallback">
          <h2>应用出现错误</h2>
          <p>{error.userMessage}</p>
          <button onClick={reset}>重试</button>
        </div>
      )}
    >
      <div className="app">
        {/* 应用内容 */}
      </div>
    </ErrorBoundary>
  );
};

// 导出供其他模块使用
export { logManager, errorHandler, performanceMonitor };
```