# Epic6-子任务01: 中国地图组件

## 开发状态
已测试 → 子任务开发完成

## 开发方案

### 1. 开发目标
实现中国地图交互组件，支持省份选择、数据可视化和交互反馈功能。

### 2. 设计方案
- 使用SVG实现矢量地图，支持缩放和交互
- 省份数据与地理坐标映射
- 色彩渐变算法实现数据可视化
- 响应式设计适配不同屏幕

### 3. 实现方式

#### 3.1 中国省份地理数据和类型定义
```typescript
// src/types/map.ts
export interface ProvinceData {
  name: string;
  code: string;
  value: number; // 通关人数
  color?: string; // 计算出的颜色
  path: string; // SVG路径数据
  center: [number, number]; // 中心点坐标
  bounds: [[number, number], [number, number]]; // 边界框
}

export interface ChinaMapProps {
  mode: 'selection' | 'display';
  selectedProvince?: string;
  provinceData?: ProvinceData[];
  onProvinceSelect?: (province: string) => void;
  showDataVisualization?: boolean;
  className?: string;
  size?: 'small' | 'medium' | 'large';
  colorScheme?: 'green-red' | 'blue-orange' | 'purple-yellow';
}

export interface MapInteractionState {
  hoveredProvince: string | null;
  selectedProvince: string | null;
  zoomLevel: number;
  panOffset: [number, number];
  isDragging: boolean;
}
```

#### 3.2 中国省份SVG路径数据
```typescript
// src/data/chinaProvinces.ts
export const CHINA_PROVINCES = [
  {
    name: '北京',
    code: 'BJ',
    path: 'M380,120 L390,115 L395,125 L385,130 Z',
    center: [387.5, 122.5],
    bounds: [[380, 115], [395, 130]]
  },
  {
    name: '上海',
    code: 'SH',
    path: 'M420,200 L430,195 L435,205 L425,210 Z',
    center: [427.5, 202.5],
    bounds: [[420, 195], [435, 210]]
  },
  {
    name: '广东',
    code: 'GD',
    path: 'M350,280 L380,270 L390,290 L360,300 Z',
    center: [370, 285],
    bounds: [[350, 270], [390, 300]]
  },
  {
    name: '江苏',
    code: 'JS',
    path: 'M410,180 L440,175 L445,195 L415,200 Z',
    center: [427.5, 187.5],
    bounds: [[410, 175], [445, 200]]
  },
  {
    name: '浙江',
    code: 'ZJ',
    path: 'M430,190 L450,185 L455,205 L435,210 Z',
    center: [442.5, 197.5],
    bounds: [[430, 185], [455, 210]]
  },
  {
    name: '山东',
    code: 'SD',
    path: 'M390,140 L420,135 L425,155 L395,160 Z',
    center: [407.5, 147.5],
    bounds: [[390, 135], [425, 160]]
  },
  {
    name: '河南',
    code: 'HN',
    path: 'M360,160 L390,155 L395,175 L365,180 Z',
    center: [377.5, 167.5],
    bounds: [[360, 155], [395, 180]]
  },
  {
    name: '湖北',
    code: 'HB',
    path: 'M350,180 L380,175 L385,195 L355,200 Z',
    center: [367.5, 187.5],
    bounds: [[350, 175], [385, 200]]
  },
  {
    name: '湖南',
    code: 'HN2',
    path: 'M340,200 L370,195 L375,215 L345,220 Z',
    center: [357.5, 207.5],
    bounds: [[340, 195], [375, 220]]
  },
  {
    name: '江西',
    code: 'JX',
    path: 'M400,200 L420,195 L425,215 L405,220 Z',
    center: [412.5, 207.5],
    bounds: [[400, 195], [425, 220]]
  },
  {
    name: '安徽',
    code: 'AH',
    path: 'M380,170 L410,165 L415,185 L385,190 Z',
    center: [397.5, 177.5],
    bounds: [[380, 165], [415, 190]]
  },
  {
    name: '福建',
    code: 'FJ',
    path: 'M430,210 L450,205 L455,225 L435,230 Z',
    center: [442.5, 217.5],
    bounds: [[430, 205], [455, 230]]
  },
  {
    name: '广西',
    code: 'GX',
    path: 'M320,240 L350,235 L355,255 L325,260 Z',
    center: [337.5, 247.5],
    bounds: [[320, 235], [355, 260]]
  },
  {
    name: '海南',
    code: 'HI',
    path: 'M330,290 L345,285 L350,305 L335,310 Z',
    center: [340, 297.5],
    bounds: [[330, 285], [350, 310]]
  },
  {
    name: '四川',
    code: 'SC',
    path: 'M300,180 L340,175 L345,205 L305,210 Z',
    center: [322.5, 192.5],
    bounds: [[300, 175], [345, 210]]
  },
  {
    name: '重庆',
    code: 'CQ',
    path: 'M320,190 L340,185 L345,205 L325,210 Z',
    center: [332.5, 197.5],
    bounds: [[320, 185], [345, 210]]
  },
  {
    name: '贵州',
    code: 'GZ',
    path: 'M310,210 L340,205 L345,225 L315,230 Z',
    center: [327.5, 217.5],
    bounds: [[310, 205], [345, 230]]
  },
  {
    name: '云南',
    code: 'YN',
    path: 'M280,220 L320,215 L325,245 L285,250 Z',
    center: [302.5, 232.5],
    bounds: [[280, 215], [325, 250]]
  },
  {
    name: '西藏',
    code: 'XZ',
    path: 'M220,200 L280,195 L285,235 L225,240 Z',
    center: [252.5, 217.5],
    bounds: [[220, 195], [285, 240]]
  },
  {
    name: '青海',
    code: 'QH',
    path: 'M260,160 L300,155 L305,185 L265,190 Z',
    center: [282.5, 172.5],
    bounds: [[260, 155], [305, 190]]
  },
  {
    name: '甘肃',
    code: 'GS',
    path: 'M280,140 L330,135 L335,175 L285,180 Z',
    center: [307.5, 157.5],
    bounds: [[280, 135], [335, 180]]
  },
  {
    name: '宁夏',
    code: 'NX',
    path: 'M320,140 L340,135 L345,155 L325,160 Z',
    center: [332.5, 147.5],
    bounds: [[320, 135], [345, 160]]
  },
  {
    name: '陕西',
    code: 'SX',
    path: 'M340,160 L370,155 L375,185 L345,190 Z',
    center: [357.5, 172.5],
    bounds: [[340, 155], [375, 190]]
  },
  {
    name: '新疆',
    code: 'XJ',
    path: 'M200,100 L280,95 L285,165 L205,170 Z',
    center: [242.5, 132.5],
    bounds: [[200, 95], [285, 170]]
  },
  {
    name: '内蒙古',
    code: 'NM',
    path: 'M320,100 L420,95 L425,145 L325,150 Z',
    center: [372.5, 122.5],
    bounds: [[320, 95], [425, 150]]
  },
  {
    name: '黑龙江',
    code: 'HL',
    path: 'M420,80 L460,75 L465,125 L425,130 Z',
    center: [442.5, 102.5],
    bounds: [[420, 75], [465, 130]]
  },
  {
    name: '吉林',
    code: 'JL',
    path: 'M410,110 L450,105 L455,135 L415,140 Z',
    center: [432.5, 122.5],
    bounds: [[410, 105], [455, 140]]
  },
  {
    name: '辽宁',
    code: 'LN',
    path: 'M400,130 L430,125 L435,155 L405,160 Z',
    center: [417.5, 142.5],
    bounds: [[400, 125], [435, 160]]
  },
  {
    name: '河北',
    code: 'HB2',
    path: 'M370,130 L400,125 L405,155 L375,160 Z',
    center: [387.5, 142.5],
    bounds: [[370, 125], [405, 160]]
  },
  {
    name: '山西',
    code: 'SX2',
    path: 'M350,140 L380,135 L385,165 L355,170 Z',
    center: [367.5, 152.5],
    bounds: [[350, 135], [385, 170]]
  },
  {
    name: '天津',
    code: 'TJ',
    path: 'M390,125 L405,120 L410,140 L395,145 Z',
    center: [400, 132.5],
    bounds: [[390, 120], [410, 145]]
  }
];

// 色彩映射算法
export const COLOR_SCHEMES = {
  'green-red': {
    min: '#22c55e', // 绿色 - 最少通关人数
    max: '#dc2626', // 红色 - 最多通关人数
    interpolate: (value: number, min: number, max: number) => {
      const ratio = (value - min) / (max - min);
      const r = Math.round(34 + (220 - 34) * ratio);
      const g = Math.round(197 + (38 - 197) * ratio);
      const b = Math.round(94 + (38 - 94) * ratio);
      return `rgb(${r}, ${g}, ${b})`;
    }
  },
  'blue-orange': {
    min: '#3b82f6', // 蓝色
    max: '#f97316', // 橙色
    interpolate: (value: number, min: number, max: number) => {
      const ratio = (value - min) / (max - min);
      const r = Math.round(59 + (249 - 59) * ratio);
      const g = Math.round(130 + (115 - 130) * ratio);
      const b = Math.round(246 + (22 - 246) * ratio);
      return `rgb(${r}, ${g}, ${b})`;
    }
  },
  'purple-yellow': {
    min: '#a855f7', // 紫色
    max: '#eab308', // 黄色
    interpolate: (value: number, min: number, max: number) => {
      const ratio = (value - min) / (max - min);
      const r = Math.round(168 + (234 - 168) * ratio);
      const g = Math.round(85 + (179 - 85) * ratio);
      const b = Math.round(247 + (8 - 247) * ratio);
      return `rgb(${r}, ${g}, ${b})`;
    }
  }
};

// 计算省份颜色
export const calculateProvinceColor = (
  value: number,
  minValue: number,
  maxValue: number,
  colorScheme: keyof typeof COLOR_SCHEMES = 'green-red'
): string => {
  if (minValue === maxValue) return COLOR_SCHEMES[colorScheme].min;
  return COLOR_SCHEMES[colorScheme].interpolate(value, minValue, maxValue);
};
```

#### 3.3 核心地图组件实现
```typescript
// src/components/ui/ChinaMap.tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ChinaMapProps, MapInteractionState, ProvinceData } from '../../types/map';
import { CHINA_PROVINCES, calculateProvinceColor } from '../../data/chinaProvinces';
import styles from './ChinaMap.module.css';

export const ChinaMap: React.FC<ChinaMapProps> = React.memo(({
  mode = 'selection',
  selectedProvince,
  provinceData = [],
  onProvinceSelect,
  showDataVisualization = true,
  className = '',
  size = 'medium',
  colorScheme = 'green-red'
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const [interactionState, setInteractionState] = useState<MapInteractionState>({
    hoveredProvince: null,
    selectedProvince: selectedProvince || null,
    zoomLevel: 1,
    panOffset: [0, 0],
    isDragging: false
  });

  // 计算数据范围
  const { minValue, maxValue } = useMemo(() => {
    const values = provinceData.map(p => p.value);
    return {
      minValue: Math.min(...values, 0),
      maxValue: Math.max(...values, 1)
    };
  }, [provinceData]);

  // 获取省份数据
  const getProvinceData = useCallback((provinceName: string): ProvinceData | undefined => {
    return provinceData.find(p => p.name === provinceName);
  }, [provinceData]);

  // 获取省份颜色
  const getProvinceColor = useCallback((provinceName: string): string => {
    if (!showDataVisualization) return '#e5e7eb';
    
    const data = getProvinceData(provinceName);
    if (!data) return '#f3f4f6';
    
    return calculateProvinceColor(data.value, minValue, maxValue, colorScheme);
  }, [showDataVisualization, getProvinceData, minValue, maxValue, colorScheme]);

  // 处理省份点击
  const handleProvinceClick = useCallback((provinceName: string) => {
    if (mode === 'selection' && onProvinceSelect) {
      setInteractionState(prev => ({
        ...prev,
        selectedProvince: provinceName
      }));
      onProvinceSelect(provinceName);
    }
  }, [mode, onProvinceSelect]);

  // 处理鼠标悬停
  const handleMouseEnter = useCallback((provinceName: string) => {
    setInteractionState(prev => ({
      ...prev,
      hoveredProvince: provinceName
    }));
  }, []);

  const handleMouseLeave = useCallback(() => {
    setInteractionState(prev => ({
      ...prev,
      hoveredProvince: null
    }));
  }, []);

  // 处理键盘导航
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      if (interactionState.hoveredProvince) {
        handleProvinceClick(interactionState.hoveredProvince);
      }
    }
  }, [interactionState.hoveredProvince, handleProvinceClick]);

  // 渲染省份路径
  const renderProvince = (province: typeof CHINA_PROVINCES[0]) => {
    const isHovered = interactionState.hoveredProvince === province.name;
    const isSelected = interactionState.selectedProvince === province.name;
    const color = getProvinceColor(province.name);
    const data = getProvinceData(province.name);

    return (
      <g key={province.code}>
        <path
          d={province.path}
          fill={color}
          stroke={isSelected ? '#3b82f6' : isHovered ? '#60a5fa' : '#9ca3af'}
          strokeWidth={isSelected ? 3 : isHovered ? 2 : 1}
          className={styles.provincePath}
          onClick={() => handleProvinceClick(province.name)}
          onMouseEnter={() => handleMouseEnter(province.name)}
          onMouseLeave={handleMouseLeave}
          onKeyDown={handleKeyDown}
          tabIndex={mode === 'selection' ? 0 : -1}
          role={mode === 'selection' ? 'button' : 'img'}
          aria-label={`${province.name}${data ? ` - ${data.value}人通关` : ''}`}
          aria-pressed={isSelected}
        />
        {/* 省份名称标签 */}
        <text
          x={province.center[0]}
          y={province.center[1]}
          textAnchor="middle"
          dominantBaseline="middle"
          className={styles.provinceLabel}
          fill={isHovered || isSelected ? '#1f2937' : '#374151'}
          fontSize={size === 'small' ? '10px' : size === 'large' ? '14px' : '12px'}
          fontWeight={isSelected ? 'bold' : 'normal'}
        >
          {province.name}
        </text>
        {/* 数据值显示 */}
        {data && showDataVisualization && (
          <text
            x={province.center[0]}
            y={province.center[1] + 15}
            textAnchor="middle"
            dominantBaseline="middle"
            className={styles.dataLabel}
            fill={isHovered || isSelected ? '#374151' : '#6b7280'}
            fontSize={size === 'small' ? '8px' : size === 'large' ? '11px' : '9px'}
          >
            {data.value.toLocaleString()}
          </text>
        )}
      </g>
    );
  };

  // 渲染图例
  const renderLegend = () => {
    if (!showDataVisualization || provinceData.length === 0) return null;

    const steps = 5;
    const stepSize = (maxValue - minValue) / steps;
    
    return (
      <div className={styles.legend}>
        <div className={styles.legendTitle}>通关人数</div>
        <div className={styles.legendGradient}>
          {Array.from({ length: steps }, (_, i) => {
            const value = minValue + stepSize * i;
            const color = calculateProvinceColor(value, minValue, maxValue, colorScheme);
            
            return (
              <div key={i} className={styles.legendItem}>
                <div 
                  className={styles.legendColor}
                  style={{ backgroundColor: color }}
                />
                <span className={styles.legendValue}>
                  {Math.round(value).toLocaleString()}
                </span>
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  // 渲染选中省份信息
  const renderSelectedInfo = () => {
    if (!interactionState.selectedProvince) return null;
    
    const data = getProvinceData(interactionState.selectedProvince);
    
    return (
      <div className={styles.selectedInfo}>
        <h3 className={styles.selectedTitle}>{interactionState.selectedProvince}</h3>
        {data && (
          <p className={styles.selectedData}>
            通关人数: {data.value.toLocaleString()}人
          </p>
        )}
        {mode === 'selection' && (
          <p className={styles.selectedHint}>按Enter键确认选择</p>
        )}
      </div>
    );
  };

  return (
    <div className={`${styles.chinaMap} ${styles[size]} ${className}`}>
      <div className={styles.mapContainer}>
        <svg
          ref={svgRef}
          viewBox="0 0 500 400"
          className={styles.mapSvg}
          preserveAspectRatio="xMidYMid meet"
        >
          {/* 背景 */}
          <rect
            width="500"
            height="400"
            fill="#f9fafb"
            stroke="#e5e7eb"
            strokeWidth="1"
          />
          
          {/* 省份渲染 */}
          {CHINA_PROVINCES.map(renderProvince)}
          
          {/* 标题 */}
          <text
            x="250"
            y="20"
            textAnchor="middle"
            className={styles.mapTitle}
            fill="#374151"
            fontSize="16"
            fontWeight="bold"
          >
            中国省份通关数据
          </text>
        </svg>
        
        {/* 悬停提示 */}
        {interactionState.hoveredProvince && (
          <div className={styles.tooltip}>
            <div className={styles.tooltipContent}>
              <strong>{interactionState.hoveredProvince}</strong>
              {(() => {
                const data = getProvinceData(interactionState.hoveredProvince);
                return data ? (
                  <span> - {data.value.toLocaleString()}人通关</span>
                ) : (
                  <span> - 暂无数据</span>
                );
              })()}
            </div>
          </div>
        )}
      </div>
      
      {renderLegend()}
      {renderSelectedInfo()}
    </div>
  );
});

ChinaMap.displayName = 'ChinaMap';
```

#### 3.4 样式文件
```css
/* src/components/ui/ChinaMap.module.css */
.chinaMap {
  position: relative;
  width: 100%;
  height: 100%;
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.mapContainer {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 400px;
}

.mapSvg {
  width: 100%;
  height: 100%;
  cursor: pointer;
}

.provincePath {
  transition: all 0.3s ease;
  cursor: pointer;
}

.provincePath:hover {
  filter: brightness(1.1);
  transform: scale(1.02);
  transform-origin: center;
}

.provincePath:focus {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
}

.provinceLabel {
  pointer-events: none;
  user-select: none;
  font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
  font-weight: 500;
  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
}

.dataLabel {
  pointer-events: none;
  user-select: none;
  font-family: 'Courier New', monospace;
  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
}

.mapTitle {
  font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
}

.tooltip {
  position: absolute;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  pointer-events: none;
  z-index: 1000;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
  transform: translate(-50%, -100%);
  margin-top: -8px;
}

.tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: rgba(0, 0, 0, 0.9);
}

.tooltipContent {
  white-space: nowrap;
}

.legend {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: rgba(255, 255, 255, 0.95);
  padding: 16px;
  border-radius: 8px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(10px);
}

.legendTitle {
  font-size: 14px;
  font-weight: bold;
  color: #374151;
  margin-bottom: 8px;
  text-align: center;
}

.legendGradient {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.legendItem {
  display: flex;
  align-items: center;
  gap: 8px;
}

.legendColor {
  width: 16px;
  height: 16px;
  border-radius: 3px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.legendValue {
  font-size: 12px;
  color: #6b7280;
  font-family: 'Courier New', monospace;
}

.selectedInfo {
  position: absolute;
  top: 60px;
  left: 20px;
  background: rgba(59, 130, 246, 0.95);
  color: white;
  padding: 12px 16px;
  border-radius: 8px;
  box-shadow: 0 2px 12px rgba(59, 130, 246, 0.3);
  backdrop-filter: blur(10px);
  max-width: 200px;
}

.selectedTitle {
  font-size: 16px;
  font-weight: bold;
  margin: 0 0 4px 0;
}

.selectedData {
  font-size: 14px;
  margin: 0 0 4px 0;
  opacity: 0.9;
}

.selectedHint {
  font-size: 12px;
  margin: 0;
  opacity: 0.8;
  font-style: italic;
}

/* 尺寸变体 */
.small {
  min-height: 300px;
}

.small .mapSvg {
  min-height: 250px;
}

.small .provinceLabel {
  font-size: 10px;
}

.small .dataLabel {
  font-size: 8px;
}

.small .legend {
  padding: 12px;
  bottom: 10px;
  right: 10px;
}

.small .legendTitle {
  font-size: 12px;
}

.small .legendColor {
  width: 12px;
  height: 12px;
}

.small .legendValue {
  font-size: 10px;
}

.small .selectedInfo {
  padding: 8px 12px;
  top: 50px;
  left: 10px;
}

.small .selectedTitle {
  font-size: 14px;
}

.small .selectedData {
  font-size: 12px;
}

.small .selectedHint {
  font-size: 10px;
}

.large {
  min-height: 600px;
}

.large .mapSvg {
  min-height: 500px;
}

.large .provinceLabel {
  font-size: 14px;
}

.large .dataLabel {
  font-size: 11px;
}

.large .legend {
  padding: 20px;
  bottom: 30px;
  right: 30px;
}

.large .legendTitle {
  font-size: 16px;
}

.large .legendColor {
  width: 20px;
  height: 20px;
}

.large .legendValue {
  font-size: 14px;
}

.large .selectedInfo {
  padding: 16px 20px;
  top: 80px;
  left: 30px;
}

.large .selectedTitle {
  font-size: 18px;
}

.large .selectedData {
  font-size: 16px;
}

.large .selectedHint {
  font-size: 14px;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .chinaMap {
    border-radius: 8px;
  }
  
  .mapContainer {
    min-height: 350px;
  }
  
  .legend {
    position: relative;
    bottom: auto;
    right: auto;
    margin: 10px;
    backdrop-filter: none;
  }
  
  .selectedInfo {
    position: relative;
    top: auto;
    left: auto;
    margin: 10px;
    backdrop-filter: none;
  }
  
  .tooltip {
    font-size: 12px;
    padding: 6px 8px;
  }
}

@media (max-width: 480px) {
  .mapContainer {
    min-height: 300px;
  }
  
  .legend {
    padding: 12px;
    margin: 8px;
  }
  
  .selectedInfo {
    padding: 10px 12px;
    margin: 8px;
  }
  
  .provinceLabel {
    font-size: 9px;
  }
  
  .dataLabel {
    font-size: 7px;
  }
}

/* 高对比度模式支持 */
@media (prefers-contrast: high) {
  .provincePath {
    stroke-width: 2;
  }
  
  .provinceLabel {
    text-shadow: 2px 2px 4px rgba(255, 255, 255, 1);
  }
}

/* 减少动画偏好支持 */
@media (prefers-reduced-motion: reduce) {
  .provincePath {
    transition: none;
  }
  
  .provincePath:hover {
    transform: none;
    filter: none;
  }
}
```

#### 3.5 工具函数和自定义Hook
```typescript
// src/hooks/useMapInteraction.ts
import { useState, useCallback, useRef, useEffect } from 'react';
import { MapInteractionState } from '../types/map';

export const useMapInteraction = (initialState?: Partial<MapInteractionState>) => {
  const [state, setState] = useState<MapInteractionState>({
    hoveredProvince: null,
    selectedProvince: null,
    zoomLevel: 1,
    panOffset: [0, 0],
    isDragging: false,
    ...initialState
  });

  const dragStartRef = useRef<{ x: number; y: number } | null>(null);
  const svgRef = useRef<SVGSVGElement | null>(null);

  // 处理鼠标悬停
  const handleMouseEnter = useCallback((provinceName: string) => {
    setState(prev => ({ ...prev, hoveredProvince: provinceName }));
  }, []);

  const handleMouseLeave = useCallback(() => {
    setState(prev => ({ ...prev, hoveredProvince: null }));
  }, []);

  // 处理选择
  const handleSelect = useCallback((provinceName: string) => {
    setState(prev => ({ ...prev, selectedProvince: provinceName }));
  }, []);

  // 处理拖拽
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (!svgRef.current) return;
    
    const rect = svgRef.current.getBoundingClientRect();
    dragStartRef.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
    
    setState(prev => ({ ...prev, isDragging: true }));
  }, []);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!state.isDragging || !dragStartRef.current || !svgRef.current) return;
    
    const rect = svgRef.current.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    const deltaX = currentX - dragStartRef.current.x;
    const deltaY = currentY - dragStartRef.current.y;
    
    setState(prev => ({
      ...prev,
      panOffset: [prev.panOffset[0] + deltaX, prev.panOffset[1] + deltaY]
    }));
    
    dragStartRef.current = { x: currentX, y: currentY };
  }, [state.isDragging]);

  const handleMouseUp = useCallback(() => {
    setState(prev => ({ ...prev, isDragging: false }));
    dragStartRef.current = null;
  }, []);

  // 处理缩放
  const handleZoom = useCallback((delta: number, center?: [number, number]) => {
    setState(prev => {
      const newZoomLevel = Math.max(0.5, Math.min(3, prev.zoomLevel + delta));
      return { ...prev, zoomLevel: newZoomLevel };
    });
  }, []);

  // 重置视图
  const resetView = useCallback(() => {
    setState({
      hoveredProvince: null,
      selectedProvince: state.selectedProvince,
      zoomLevel: 1,
      panOffset: [0, 0],
      isDragging: false
    });
  }, [state.selectedProvince]);

  return {
    state,
    handlers: {
      handleMouseEnter,
      handleMouseLeave,
      handleSelect,
      handleMouseDown,
      handleMouseMove,
      handleMouseUp,
      handleZoom,
      resetView
    },
    refs: {
      svgRef
    }
  };
};
```

#### 3.6 色彩工具函数
```typescript
// src/utils/colorUtils.ts
export interface ColorScheme {
  min: string;
  max: string;
  interpolate: (value: number, min: number, max: number) => string;
}

// HSL色彩空间插值（更自然的渐变）
export const interpolateColorHSL = (
  value: number,
  min: number,
  max: number,
  hueStart: number,
  hueEnd: number,
  saturation: number = 70,
  lightness: number = 50
): string => {
  const ratio = (value - min) / (max - min);
  const hue = hueStart + (hueEnd - hueStart) * ratio;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};

// RGB色彩空间插值
export const interpolateColorRGB = (
  value: number,
  min: number,
  max: number,
  startColor: [number, number, number],
  endColor: [number, number, number]
): string => {
  const ratio = (value - min) / (max - min);
  const r = Math.round(startColor[0] + (endColor[0] - startColor[0]) * ratio);
  const g = Math.round(startColor[1] + (endColor[1] - startColor[1]) * ratio);
  const b = Math.round(startColor[2] + (endColor[2] - startColor[2]) * ratio);
  return `rgb(${r}, ${g}, ${b})`;
};

// 生成渐变色阶
export const generateColorScale = (
  steps: number,
  startColor: string,
  endColor: string
): string[] => {
  const startRGB = hexToRgb(startColor);
  const endRGB = hexToRgb(endColor);
  
  return Array.from({ length: steps }, (_, i) => {
    const ratio = i / (steps - 1);
    return interpolateColorRGB(i, 0, steps - 1, startRGB, endRGB);
  });
};

// 十六进制转RGB
export const hexToRgb = (hex: string): [number, number, number] => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
  ] : [0, 0, 0];
};

// 计算颜色的亮度
export const getColorBrightness = (color: string): number => {
  const rgb = color.startsWith('#') ? hexToRgb(color) : parseRgb(color);
  return (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
};

// 解析RGB字符串
export const parseRgb = (color: string): [number, number, number] => {
  const result = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/.exec(color);
  return result ? [
    parseInt(result[1]),
    parseInt(result[2]),
    parseInt(result[3])
  ] : [0, 0, 0];
};

// 根据背景色获取对比文本色
export const getContrastTextColor = (backgroundColor: string): string => {
  const brightness = getColorBrightness(backgroundColor);
  return brightness > 128 ? '#000000' : '#ffffff';
};
```

### 4. 关键技术点
- SVG路径数据和坐标转换
- 色彩映射算法（深绿到深红渐变）
- 点击事件精确捕捉
- 性能优化（虚拟化、缓存）

### 5. 依赖项
- Epic5基础UI组件
- 中国省份地理数据
- 色彩计算算法
- SVG支持库（可选）

## Milestone

- Day 1: 地图数据准备和基础SVG渲染
- Day 2: 省份交互和选择功能实现
- Day 3: 数据可视化色彩映射
- Day 4: 响应式优化和集成测试

## 测试方案

### 功能点测试
- 省份正确显示和边界准确性
- 点击事件精确响应
- 色彩映射正确性
- 数据更新实时性

### 异常测试
- SVG加载失败处理
- 无效地理数据处理
- 大数据量渲染性能
- 移动端触摸事件兼容

### 性能验证
- 地图渲染时间<500ms
- 交互响应时间<100ms
- 大数据集处理性能
- 内存使用优化验证