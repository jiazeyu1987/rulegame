# Epic3-å­ä»»åŠ¡01: Pythonè„šæœ¬è§£æå¼•æ“

## å¼€å‘çŠ¶æ€
å·²æµ‹è¯• â†’ å­ä»»åŠ¡å¼€å‘å®Œæˆ

## å¼€å‘æ–¹æ¡ˆ

### 1. å¼€å‘ç›®æ ‡
å®ç°Pythonè„šæœ¬è§£æå¼•æ“ï¼Œèƒ½å¤Ÿè¯»å–å¹¶è§£æday0-7æ•…äº‹è„šæœ¬ï¼Œæå–æ¸¸æˆå†…å®¹ã€åˆ†æ”¯é€»è¾‘å’Œæ¡ä»¶å®šä¹‰ï¼Œä¸ºæ¸¸æˆæä¾›åŠ¨æ€å†…å®¹åŠ è½½èƒ½åŠ›ã€‚

### 2. è®¾è®¡æ–¹æ¡ˆ
é‡‡ç”¨åˆ†å±‚è§£ææ¶æ„ï¼š
- **è¯æ³•åˆ†æå±‚**ï¼šè¯†åˆ«Pythonè¯­æ³•æ ‡è®°ï¼ˆå˜é‡ã€å­—ç¬¦ä¸²ã€æ³¨é‡Šç­‰ï¼‰
- **è¯­æ³•åˆ†æå±‚**ï¼šæ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼Œè¯†åˆ«æ•…äº‹ç»“æ„
- **è¯­ä¹‰åˆ†æå±‚**ï¼šæå–æ¸¸æˆé€»è¾‘ï¼ŒéªŒè¯æ•°æ®ä¸€è‡´æ€§
- **é”™è¯¯å¤„ç†å±‚**ï¼šæä¾›è¯¦ç»†çš„é”™è¯¯å®šä½å’ŒæŠ¥å‘Š

### 3. å®ç°æ–¹å¼

#### 3.1 æ ¸å¿ƒè§£æå™¨æ¶æ„
```typescript
// src/types/parser.ts
export interface ParseNode {
  type: string;
  value?: string;
  children: ParseNode[];
  line: number;
  column: number;
  raw?: string;
}

export interface StoryData {
  day: number;
  title: string;
  sections: StorySection[];
  choices: Choice[];
  winConditions: Condition[];
  deathConditions: Condition[];
  metadata: StoryMetadata;
}

export interface StorySection {
  id: string;
  title: string;
  content: string;
  type: 'story' | 'dialogue' | 'description' | 'action';
  speaker?: string;
  conditions?: string[];
  nextSection?: string;
  references: string[];
}

export interface Choice {
  id: string;
  text: string;
  conditions?: string[];
  effects?: string[];
  nextSection: string;
  weight: number;
  priority: number;
}

export interface Condition {
  type: 'attribute' | 'item' | 'flag' | 'time' | 'random';
  field: string;
  operator: '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains';
  value: string | number | boolean;
  probability?: number;
}

export interface StoryMetadata {
  author: string;
  version: string;
  created: string;
  modified: string;
  description: string;
  tags: string[];
}

export interface ParseError {
  type: 'syntax' | 'semantic' | 'validation';
  message: string;
  line: number;
  column: number;
  severity: 'error' | 'warning' | 'info';
  suggestion?: string;
}
```

#### 3.2 è¯æ³•åˆ†æå™¨å®ç°
```typescript
// src/utils/lexicalAnalyzer.ts
export class LexicalAnalyzer {
  private input: string;
  private position: number = 0;
  private line: number = 1;
  private column: number = 1;

  constructor(input: string) {
    this.input = input;
  }

  /**
   * è¯æ³•åˆ†æï¼Œå°†è¾“å…¥è½¬æ¢ä¸ºæ ‡è®°åºåˆ—
   */
  tokenize(): Token[] {
    const tokens: Token[] = [];
    
    while (this.position < this.input.length) {
      this.skipWhitespace();
      
      if (this.position >= this.input.length) break;
      
      const token = this.nextToken();
      if (token) {
        tokens.push(token);
      }
    }
    
    return tokens;
  }

  private nextToken(): Token | null {
    const char = this.currentChar();
    
    // å­—ç¬¦ä¸²å­—é¢é‡
    if (char === '"' || char === "'") {
      return this.readString();
    }
    
    // æ³¨é‡Š
    if (char === '#') {
      return this.readComment();
    }
    
    // æ ‡è¯†ç¬¦å’Œå…³é”®å­—
    if (this.isAlpha(char)) {
      return this.readIdentifier();
    }
    
    // æ•°å­—
    if (this.isDigit(char)) {
      return this.readNumber();
    }
    
    // è¿ç®—ç¬¦
    if (this.isOperator(char)) {
      return this.readOperator();
    }
    
    // ç‰¹æ®Šå­—ç¬¦
    if (this.isSpecial(char)) {
      return this.readSpecial();
    }
    
    throw new ParseError(`Unexpected character: ${char}`, this.line, this.column);
  }

  private readString(): Token {
    const quote = this.currentChar();
    const start = this.position;
    const startLine = this.line;
    const startColumn = this.column;
    
    this.advance(); // è·³è¿‡èµ·å§‹å¼•å·
    
    let value = '';
    while (this.position < this.input.length && this.currentChar() !== quote) {
      if (this.currentChar() === '\\') {
        this.advance();
        const escaped = this.currentChar();
        switch (escaped) {
          case 'n': value += '\n'; break;
          case 't': value += '\t'; break;
          case 'r': value += '\r'; break;
          case '\\': value += '\\'; break;
          case '"': value += '"'; break;
          case "'": value += "'"; break;
          default: value += escaped; break;
        }
      } else {
        value += this.currentChar();
      }
      this.advance();
    }
    
    if (this.position >= this.input.length) {
      throw new ParseError('Unterminated string', startLine, startColumn);
    }
    
    this.advance(); // è·³è¿‡ç»“æŸå¼•å·
    
    return {
      type: 'STRING',
      value,
      raw: this.input.slice(start, this.position),
      line: startLine,
      column: startColumn
    };
  }

  private readComment(): Token {
    const start = this.position;
    const startLine = this.line;
    const startColumn = this.column;
    
    while (this.position < this.input.length && this.currentChar() !== '\n') {
      this.advance();
    }
    
    return {
      type: 'COMMENT',
      value: this.input.slice(start + 1, this.position).trim(),
      raw: this.input.slice(start, this.position),
      line: startLine,
      column: startColumn
    };
  }

  private readIdentifier(): Token {
    const start = this.position;
    const startLine = this.line;
    const startColumn = this.column;
    
    while (this.position < this.input.length && 
           (this.isAlpha(this.currentChar()) || 
            this.isDigit(this.currentChar()) || 
            this.currentChar() === '_')) {
      this.advance();
    }
    
    const value = this.input.slice(start, this.position);
    const type = this.isKeyword(value) ? 'KEYWORD' : 'IDENTIFIER';
    
    return {
      type,
      value,
      raw: value,
      line: startLine,
      column: startColumn
    };
  }

  private readNumber(): Token {
    const start = this.position;
    const startLine = this.line;
    const startColumn = this.column;
    
    while (this.position < this.input.length && this.isDigit(this.currentChar())) {
      this.advance();
    }
    
    // æ£€æŸ¥å°æ•°ç‚¹
    if (this.position < this.input.length && 
        this.currentChar() === '.' && 
        this.position + 1 < this.input.length && 
        this.isDigit(this.input[this.position + 1])) {
      this.advance(); // è·³è¿‡å°æ•°ç‚¹
      while (this.position < this.input.length && this.isDigit(this.currentChar())) {
        this.advance();
      }
    }
    
    return {
      type: 'NUMBER',
      value: parseFloat(this.input.slice(start, this.position)),
      raw: this.input.slice(start, this.position),
      line: startLine,
      column: startColumn
    };
  }

  private readOperator(): Token {
    const start = this.position;
    const startLine = this.line;
    const startColumn = this.column;
    
    // å¤šå­—ç¬¦è¿ç®—ç¬¦
    if (this.position + 1 < this.input.length) {
      const twoChar = this.input.slice(this.position, this.position + 2);
      if (['==', '!=', '<=', '>=', '&&', '||'].includes(twoChar)) {
        this.advance();
        this.advance();
        return {
          type: 'OPERATOR',
          value: twoChar,
          raw: twoChar,
          line: startLine,
          column: startColumn
        };
      }
    }
    
    // å•å­—ç¬¦è¿ç®—ç¬¦
    const char = this.currentChar();
    this.advance();
    
    return {
      type: 'OPERATOR',
      value: char,
      raw: char,
      line: startLine,
      column: startColumn
    };
  }

  private readSpecial(): Token {
    const char = this.currentChar();
    const startLine = this.line;
    const startColumn = this.column;
    
    this.advance();
    
    return {
      type: 'SPECIAL',
      value: char,
      raw: char,
      line: startLine,
      column: startColumn
    };
  }

  private skipWhitespace(): void {
    while (this.position < this.input.length && /\s/.test(this.currentChar())) {
      this.advance();
    }
  }

  private advance(): void {
    if (this.position < this.input.length) {
      if (this.currentChar() === '\n') {
        this.line++;
        this.column = 1;
      } else {
        this.column++;
      }
      this.position++;
    }
  }

  private currentChar(): string {
    return this.input[this.position] || '';
  }

  private isAlpha(char: string): boolean {
    return /[a-zA-Z]/.test(char);
  }

  private isDigit(char: string): boolean {
    return /\d/.test(char);
  }

  private isOperator(char: string): boolean {
    return /[=<>!+\-*/&|]/.test(char);
  }

  private isSpecial(char: string): boolean {
    return /[(){}[\],.;:]/.test(char);
  }

  private isKeyword(word: string): boolean {
    const keywords = [
      'if', 'elif', 'else', 'for', 'while', 'def', 'class',
      'return', 'break', 'continue', 'pass', 'and', 'or', 'not',
      'True', 'False', 'None', 'import', 'from', 'as'
    ];
    return keywords.includes(word);
  }
}

export interface Token {
  type: string;
  value: string | number;
  raw: string;
  line: number;
  column: number;
}

export class ParseError extends Error {
  constructor(message: string, public line: number, public column: number) {
    super(`${message} at line ${line}, column ${column}`);
    this.name = 'ParseError';
  }
}
```

#### 3.3 è¯­æ³•åˆ†æå™¨å®ç°
```typescript
// src/utils/syntaxAnalyzer.ts
import { Token, ParseError } from './lexicalAnalyzer';
import { ParseNode, StoryData, StorySection, Choice, Condition } from '../types/parser';

export class SyntaxAnalyzer {
  private tokens: Token[];
  private position: number = 0;

  constructor(tokens: Token[]) {
    this.tokens = tokens;
  }

  /**
   * æ„å»ºæŠ½è±¡è¯­æ³•æ ‘
   */
  parse(): ParseNode {
    const root: ParseNode = {
      type: 'ROOT',
      children: [],
      line: 1,
      column: 1
    };

    while (this.position < this.tokens.length) {
      const node = this.parseStatement();
      if (node) {
        root.children.push(node);
      }
    }

    return root;
  }

  private parseStatement(): ParseNode | null {
    const token = this.currentToken();
    
    if (!token) return null;

    // è·³è¿‡æ³¨é‡Š
    if (token.type === 'COMMENT') {
      this.advance();
      return null;
    }

    // å‡½æ•°å®šä¹‰ï¼ˆæ•…äº‹æ®µè½ï¼‰
    if (token.type === 'KEYWORD' && token.value === 'def') {
      return this.parseFunctionDefinition();
    }

    // å˜é‡èµ‹å€¼
    if (token.type === 'IDENTIFIER') {
      return this.parseAssignment();
    }

    // æ¡ä»¶è¯­å¥
    if (token.type === 'KEYWORD' && token.value === 'if') {
      return this.parseIfStatement();
    }

    // å¯¼å…¥è¯­å¥
    if (token.type === 'KEYWORD' && (token.value === 'import' || token.value === 'from')) {
      return this.parseImportStatement();
    }

    // è¡¨è¾¾å¼è¯­å¥
    return this.parseExpressionStatement();
  }

  private parseFunctionDefinition(): ParseNode {
    const startToken = this.currentToken();
    this.advance(); // è·³è¿‡ 'def'

    // å‡½æ•°å
    const nameToken = this.expectToken('IDENTIFIER', 'Function name expected');
    
    // å·¦æ‹¬å·
    this.expectToken('SPECIAL', '(', 'Opening parenthesis expected');
    
    // å‚æ•°åˆ—è¡¨
    const parameters = this.parseParameterList();
    
    // å³æ‹¬å·
    this.expectToken('SPECIAL', ')', 'Closing parenthesis expected');
    
    // å†’å·
    this.expectToken('SPECIAL', ':', 'Colon expected');
    
    // å‡½æ•°ä½“
    const body = this.parseBlock();

    return {
      type: 'FUNCTION_DEFINITION',
      value: nameToken.value as string,
      children: [parameters, body],
      line: startToken.line,
      column: startToken.column
    };
  }

  private parseParameterList(): ParseNode {
    const params: ParseNode = {
      type: 'PARAMETER_LIST',
      children: [],
      line: this.currentToken()?.line || 1,
      column: this.currentToken()?.column || 1
    };

    while (this.position < this.tokens.length && this.currentToken()?.value !== ')') {
      const param = this.expectToken('IDENTIFIER', 'Parameter name expected');
      params.children.push({
        type: 'PARAMETER',
        value: param.value as string,
        children: [],
        line: param.line,
        column: param.column
      });

      if (this.currentToken()?.value === ',') {
        this.advance();
      } else {
        break;
      }
    }

    return params;
  }

  private parseBlock(): ParseNode {
    const statements: ParseNode[] = [];
    let indentLevel = this.getCurrentIndentLevel();

    while (this.position < this.tokens.length) {
      const currentIndent = this.getCurrentIndentLevel();
      
      // å¦‚æœç¼©è¿›å‡å°‘ï¼Œè¯´æ˜å—ç»“æŸ
      if (currentIndent < indentLevel) {
        break;
      }
      
      // å¦‚æœç¼©è¿›ç›¸åŒï¼Œè§£æè¯­å¥
      if (currentIndent === indentLevel) {
        const statement = this.parseStatement();
        if (statement) {
          statements.push(statement);
        }
      } else {
        // ç¼©è¿›å¢åŠ ï¼Œé€’å½’è§£æå­å—
        const subBlock = this.parseBlock();
        if (statements.length > 0) {
          statements[statements.length - 1].children.push(subBlock);
        }
      }
    }

    return {
      type: 'BLOCK',
      children: statements,
      line: statements[0]?.line || 1,
      column: statements[0]?.column || 1
    };
  }

  private parseAssignment(): ParseNode {
    const identifier = this.currentToken();
    this.advance();

    this.expectToken('OPERATOR', '=', 'Assignment operator expected');
    
    const value = this.parseExpression();

    return {
      type: 'ASSIGNMENT',
      value: identifier.value as string,
      children: [value],
      line: identifier.line,
      column: identifier.column
    };
  }

  private parseExpression(): ParseNode {
    return this.parseLogicalOr();
  }

  private parseLogicalOr(): ParseNode {
    let left = this.parseLogicalAnd();

    while (this.currentToken()?.value === 'or' || this.currentToken()?.value === '||') {
      const operator = this.currentToken()!;
      this.advance();
      const right = this.parseLogicalAnd();
      
      left = {
        type: 'BINARY_OPERATION',
        value: operator.value,
        children: [left, right],
        line: operator.line,
        column: operator.column
      };
    }

    return left;
  }

  private parseLogicalAnd(): ParseNode {
    let left = this.parseComparison();

    while (this.currentToken()?.value === 'and' || this.currentToken()?.value === '&&') {
      const operator = this.currentToken()!;
      this.advance();
      const right = this.parseComparison();
      
      left = {
        type: 'BINARY_OPERATION',
        value: operator.value,
        children: [left, right],
        line: operator.line,
        column: operator.column
      };
    }

    return left;
  }

  private parseComparison(): ParseNode {
    let left = this.parseAddition();

    const comparisonOperators = ['==', '!=', '<', '>', '<=', '>='];
    
    while (this.currentToken() && comparisonOperators.includes(this.currentToken()!.value as string)) {
      const operator = this.currentToken()!;
      this.advance();
      const right = this.parseAddition();
      
      left = {
        type: 'BINARY_OPERATION',
        value: operator.value,
        children: [left, right],
        line: operator.line,
        column: operator.column
      };
    }

    return left;
  }

  private parseAddition(): ParseNode {
    let left = this.parseMultiplication();

    while (this.currentToken()?.value === '+' || this.currentToken()?.value === '-') {
      const operator = this.currentToken()!;
      this.advance();
      const right = this.parseMultiplication();
      
      left = {
        type: 'BINARY_OPERATION',
        value: operator.value,
        children: [left, right],
        line: operator.line,
        column: operator.column
      };
    }

    return left;
  }

  private parseMultiplication(): ParseNode {
    let left = this.parsePrimary();

    while (this.currentToken()?.value === '*' || this.currentToken()?.value === '/' || this.currentToken()?.value === '%') {
      const operator = this.currentToken()!;
      this.advance();
      const right = this.parsePrimary();
      
      left = {
        type: 'BINARY_OPERATION',
        value: operator.value,
        children: [left, right],
        line: operator.line,
        column: operator.column
      };
    }

    return left;
  }

  private parsePrimary(): ParseNode {
    const token = this.currentToken();
    
    if (!token) {
      throw new ParseError('Unexpected end of input', this.line, this.column);
    }

    switch (token.type) {
      case 'NUMBER':
        this.advance();
        return {
          type: 'LITERAL',
          value: token.value,
          children: [],
          line: token.line,
          column: token.column
        };

      case 'STRING':
        this.advance();
        return {
          type: 'LITERAL',
          value: token.value,
          children: [],
          line: token.line,
          column: token.column
        };

      case 'IDENTIFIER':
        this.advance();
        return {
          type: 'IDENTIFIER',
          value: token.value,
          children: [],
          line: token.line,
          column: token.column
        };

      case 'SPECIAL':
        if (token.value === '(') {
          this.advance();
          const expr = this.parseExpression();
          this.expectToken('SPECIAL', ')', 'Closing parenthesis expected');
          return expr;
        }
        break;
    }

    throw new ParseError(`Unexpected token: ${token.value}`, token.line, token.column);
  }

  private parseIfStatement(): ParseNode {
    const startToken = this.currentToken();
    this.advance(); // è·³è¿‡ 'if'

    const condition = this.parseExpression();
    
    this.expectToken('SPECIAL', ':', 'Colon expected');
    
    const thenBlock = this.parseBlock();
    
    const elseIfBlocks: ParseNode[] = [];
    let elseBlock: ParseNode | null = null;

    // elif å­å¥
    while (this.currentToken()?.type === 'KEYWORD' && this.currentToken()?.value === 'elif') {
      this.advance();
      const elifCondition = this.parseExpression();
      this.expectToken('SPECIAL', ':', 'Colon expected');
      const elifBlock = this.parseBlock();
      
      elseIfBlocks.push({
        type: 'ELIF_CLAUSE',
        children: [elifCondition, elifBlock],
        line: this.currentToken()?.line || 1,
        column: this.currentToken()?.column || 1
      });
    }

    // else å­å¥
    if (this.currentToken()?.type === 'KEYWORD' && this.currentToken()?.value === 'else') {
      this.advance();
      this.expectToken('SPECIAL', ':', 'Colon expected');
      elseBlock = this.parseBlock();
    }

    const children = [condition, thenBlock, ...elseIfBlocks];
    if (elseBlock) {
      children.push(elseBlock);
    }

    return {
      type: 'IF_STATEMENT',
      children,
      line: startToken.line,
      column: startToken.column
    };
  }

  private parseImportStatement(): ParseNode {
    const startToken = this.currentToken();
    this.advance(); // è·³è¿‡ 'import' æˆ– 'from'

    if (startToken.value === 'from') {
      const module = this.expectToken('IDENTIFIER', 'Module name expected');
      this.expectToken('KEYWORD', 'import', 'import expected');
      const name = this.expectToken('IDENTIFIER', 'Name expected');
      
      return {
        type: 'IMPORT_FROM',
        value: `${module.value}.${name.value}`,
        children: [],
        line: startToken.line,
        column: startToken.column
      };
    } else {
      const name = this.expectToken('IDENTIFIER', 'Module name expected');
      
      return {
        type: 'IMPORT',
        value: name.value as string,
        children: [],
        line: startToken.line,
        column: startToken.column
      };
    }
  }

  private parseExpressionStatement(): ParseNode {
    const expr = this.parseExpression();
    return {
      type: 'EXPRESSION_STATEMENT',
      children: [expr],
      line: expr.line,
      column: expr.column
    };
  }

  private getCurrentIndentLevel(): number {
    let indent = 0;
    const startPos = this.position;
    
    while (this.position < this.tokens.length && 
           this.currentToken()?.type === 'SPECIAL' && 
           this.currentToken()?.value === ' ') {
      indent++;
      this.advance();
    }
    
    // å›é€€ä½ç½®
    this.position = startPos;
    return indent;
  }

  private currentToken(): Token | null {
    return this.tokens[this.position] || null;
  }

  private advance(): void {
    if (this.position < this.tokens.length) {
      this.position++;
    }
  }

  private expectToken(expectedType: string, expectedValue?: string, message?: string): Token {
    const token = this.currentToken();
    
    if (!token) {
      throw new ParseError(message || 'Unexpected end of input', this.line, this.column);
    }
    
    if (token.type !== expectedType) {
      throw new ParseError(
        message || `Expected ${expectedType}, got ${token.type}`,
        token.line, token.column
      );
    }
    
    if (expectedValue !== undefined && token.value !== expectedValue) {
      throw new ParseError(
        message || `Expected ${expectedValue}, got ${token.value}`,
        token.line, token.column
      );
    }
    
    this.advance();
    return token;
  }

  private get line(): number {
    return this.currentToken()?.line || 1;
  }

  private get column(): number {
    return this.currentToken()?.column || 1;
  }
}
```

#### 3.4 æ•…äº‹å†…å®¹æå–å™¨
```typescript
// src/utils/storyExtractor.ts
import { ParseNode } from '../types/parser';

export class StoryExtractor {
  /**
   * ä»ASTä¸­æå–æ•…äº‹æ•°æ®
   */
  extractStoryData(ast: ParseNode): StoryData {
    const sections = this.extractSections(ast);
    const choices = this.extractChoices(ast);
    const conditions = this.extractConditions(ast);
    const metadata = this.extractMetadata(ast);

    return {
      day: this.extractDayNumber(ast),
      title: this.extractTitle(ast),
      sections,
      choices,
      winConditions: conditions.win,
      deathConditions: conditions.death,
      metadata
    };
  }

  private extractSections(ast: ParseNode): StorySection[] {
    const sections: StorySection[] = [];
    
    this.traverseAST(ast, (node) => {
      if (node.type === 'FUNCTION_DEFINITION' && this.isStoryFunction(node)) {
        const section = this.parseStoryFunction(node);
        if (section) {
          sections.push(section);
        }
      }
    });

    return sections;
  }

  private isStoryFunction(node: ParseNode): boolean {
    const functionName = node.value || '';
    return functionName.startsWith('story_') || 
           functionName.startsWith('day') ||
           functionName.includes('section');
  }

  private parseStoryFunction(node: ParseNode): StorySection | null {
    try {
      const functionName = node.value || '';
      const body = this.findBlock(node);
      
      if (!body) return null;

      const content = this.extractStringLiterals(body);
      const conditions = this.extractConditionsFromBlock(body);
      const nextSection = this.extractNextSectionReference(body);
      const references = this.extractReferences(body);

      return {
        id: functionName,
        title: this.extractTitleFromContent(content),
        content: content.join('\n'),
        type: this.determineSectionType(functionName, content),
        conditions,
        nextSection,
        references
      };
    } catch (error) {
      console.warn(`Failed to parse story function: ${functionName}`, error);
      return null;
    }
  }

  private extractStringLiterals(node: ParseNode): string[] {
    const literals: string[] = [];
    
    this.traverseAST(node, (n) => {
      if (n.type === 'LITERAL' && typeof n.value === 'string') {
        literals.push(n.value);
      }
    });

    return literals;
  }

  private extractChoices(ast: ParseNode): Choice[] {
    const choices: Choice[] = [];
    
    this.traverseAST(ast, (node) => {
      if (node.type === 'FUNCTION_DEFINITION' && this.isChoiceFunction(node)) {
        const choice = this.parseChoiceFunction(node);
        if (choice) {
          choices.push(choice);
        }
      }
    });

    return choices;
  }

  private isChoiceFunction(node: ParseNode): boolean {
    const functionName = node.value || '';
    return functionName.includes('choice') || 
           functionName.includes('option') ||
           functionName.startsWith('select_');
  }

  private parseChoiceFunction(node: ParseNode): Choice | null {
    try {
      const functionName = node.value || '';
      const body = this.findBlock(node);
      
      if (!body) return null;

      const text = this.extractChoiceText(body);
      const conditions = this.extractChoiceConditions(body);
      const effects = this.extractChoiceEffects(body);
      const nextSection = this.extractNextSectionReference(body);

      return {
        id: functionName,
        text,
        conditions,
        effects,
        nextSection,
        weight: this.extractChoiceWeight(body),
        priority: this.extractChoicePriority(body)
      };
    } catch (error) {
      console.warn(`Failed to parse choice function: ${functionName}`, error);
      return null;
    }
  }

  private extractConditions(ast: ParseNode): { win: Condition[], death: Condition[] } {
    const win: Condition[] = [];
    const death: Condition[] = [];
    
    this.traverseAST(ast, (node) => {
      if (node.type === 'FUNCTION_DEFINITION') {
        const functionName = node.value || '';
        
        if (this.isWinConditionFunction(functionName)) {
          const conditions = this.parseConditionFunction(node);
          win.push(...conditions);
        } else if (this.isDeathConditionFunction(functionName)) {
          const conditions = this.parseConditionFunction(node);
          death.push(...conditions);
        }
      }
    });

    return { win, death };
  }

  private isWinConditionFunction(functionName: string): boolean {
    return functionName.includes('win') || 
           functionName.includes('clear') ||
           functionName.includes('success');
  }

  private isDeathConditionFunction(functionName: string): boolean {
    return functionName.includes('death') || 
           functionName.includes('die') ||
           functionName.includes('fail');
  }

  private parseConditionFunction(node: ParseNode): Condition[] {
    const conditions: Condition[] = [];
    const body = this.findBlock(node);
    
    if (!body) return conditions;

    // æå–æ¡ä»¶è¡¨è¾¾å¼
    this.traverseAST(body, (n) => {
      if (n.type === 'BINARY_OPERATION' && this.isComparisonOperator(n.value as string)) {
        const condition = this.parseConditionExpression(n);
        if (condition) {
          conditions.push(condition);
        }
      }
    });

    return conditions;
  }

  private isComparisonOperator(operator: string): boolean {
    return ['==', '!=', '<', '>', '<=', '>='].includes(operator);
  }

  private parseConditionExpression(node: ParseNode): Condition | null {
    try {
      const [left, right] = node.children;
      
      if (!left || !right) return null;

      const field = this.extractFieldName(left);
      const value = this.extractValue(right);
      const operator = node.value as string;

      return {
        type: this.determineConditionType(field),
        field,
        operator,
        value
      };
    } catch (error) {
      console.warn('Failed to parse condition expression', error);
      return null;
    }
  }

  private extractFieldName(node: ParseNode): string {
    if (node.type === 'IDENTIFIER') {
      return node.value as string;
    }
    if (node.type === 'LITERAL') {
      return String(node.value);
    }
    return 'unknown';
  }

  private extractValue(node: ParseNode): string | number | boolean {
    if (node.type === 'LITERAL') {
      return node.value as string | number | boolean;
    }
    if (node.type === 'IDENTIFIER') {
      return node.value as string;
    }
    return '';
  }

  private determineConditionType(field: string): Condition['type'] {
    if (['time', 'hunger', 'energy', 'sanity', 'intelligence', 'strength', 'speed', 'luck'].includes(field)) {
      return 'attribute';
    }
    if (field.startsWith('has_') || field.includes('item')) {
      return 'item';
    }
    if (field.startsWith('flag_')) {
      return 'flag';
    }
    if (field === 'random' || field.includes('prob')) {
      return 'random';
    }
    return 'flag';
  }

  private extractMetadata(ast: ParseNode): StoryMetadata {
    const metadata: StoryMetadata = {
      author: 'Unknown',
      version: '1.0.0',
      created: new Date().toISOString(),
      modified: new Date().toISOString(),
      description: '',
      tags: []
    };

    // ä»æ³¨é‡Šä¸­æå–å…ƒæ•°æ®
    this.traverseAST(ast, (node) => {
      if (node.type === 'COMMENT') {
        const comment = node.value as string;
        
        if (comment.startsWith('@author')) {
          metadata.author = comment.replace('@author', '').trim();
        } else if (comment.startsWith('@version')) {
          metadata.version = comment.replace('@version', '').trim();
        } else if (comment.startsWith('@description')) {
          metadata.description = comment.replace('@description', '').trim();
        } else if (comment.startsWith('@tag')) {
          metadata.tags.push(comment.replace('@tag', '').trim());
        }
      }
    });

    return metadata;
  }

  private extractDayNumber(ast: ParseNode): number {
    // ä»æ–‡ä»¶åæˆ–å‡½æ•°åä¸­æå–å¤©æ•°
    this.traverseAST(ast, (node) => {
      if (node.type === 'FUNCTION_DEFINITION' && node.value) {
        const match = (node.value as string).match(/day(\d+)/);
        if (match) {
          return parseInt(match[1]);
        }
      }
    });
    
    return 0; // é»˜è®¤day0
  }

  private extractTitle(ast: ParseNode): string {
    // ä»ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢é‡æˆ–æ³¨é‡Šä¸­æå–æ ‡é¢˜
    let title = 'Untitled Story';
    
    this.traverseAST(ast, (node) => {
      if (node.type === 'COMMENT' && (node.value as string).startsWith('@title')) {
        title = (node.value as string).replace('@title', '').trim();
        return true; // åœæ­¢éå†
      }
      if (node.type === 'LITERAL' && typeof node.value === 'string') {
        title = node.value as string;
        return true; // åœæ­¢éå†
      }
    });

    return title;
  }

  private traverseAST(node: ParseNode, callback: (node: ParseNode) => boolean | void): void {
    const shouldStop = callback(node);
    if (shouldStop) return;

    for (const child of node.children) {
      this.traverseAST(child, callback);
    }
  }

  private findBlock(node: ParseNode): ParseNode | null {
    for (const child of node.children) {
      if (child.type === 'BLOCK') {
        return child;
      }
      const found = this.findBlock(child);
      if (found) return found;
    }
    return null;
  }

  private extractTitleFromContent(content: string[]): string {
    return content[0] || 'Untitled Section';
  }

  private determineSectionType(functionName: string, content: string[]): StorySection['type'] {
    if (functionName.includes('dialogue') || functionName.includes('talk')) {
      return 'dialogue';
    }
    if (functionName.includes('description') || functionName.includes('describe')) {
      return 'description';
    }
    if (functionName.includes('action') || functionName.includes('event')) {
      return 'action';
    }
    return 'story';
  }

  private extractConditionsFromBlock(block: ParseNode): string[] {
    const conditions: string[] = [];
    
    this.traverseAST(block, (node) => {
      if (node.type === 'BINARY_OPERATION' && this.isComparisonOperator(node.value as string)) {
        conditions.push(node.raw || '');
      }
    });

    return conditions;
  }

  private extractNextSectionReference(block: ParseNode): string {
    // æŸ¥æ‰¾å‡½æ•°è°ƒç”¨ä¸­çš„å­—ç¬¦ä¸²å‚æ•°
    let nextSection = '';
    
    this.traverseAST(block, (node) => {
      if (node.type === 'LITERAL' && typeof node.value === 'string' && 
          (node.value as string).startsWith('story_')) {
        nextSection = node.value as string;
        return true;
      }
    });

    return nextSection;
  }

  private extractReferences(block: ParseNode): string[] {
    const references: string[] = [];
    
    this.traverseAST(block, (node) => {
      if (node.type === 'LITERAL' && typeof node.value === 'string') {
        const value = node.value as string;
        if (value.startsWith('story_') || value.startsWith('choice_')) {
          references.push(value);
        }
      }
    });

    return references;
  }

  private extractChoiceText(block: ParseNode): string {
    const texts = this.extractStringLiterals(block);
    return texts[0] || 'Choice Option';
  }

  private extractChoiceConditions(block: ParseNode): string[] {
    return this.extractConditionsFromBlock(block);
  }

  private extractChoiceEffects(block: ParseNode): string[] {
    const effects: string[] = [];
    
    this.traverseAST(block, (node) => {
      if (node.type === 'ASSIGNMENT') {
        effects.push(`${node.value} = ${this.nodeToString(node.children[0])}`);
      }
    });

    return effects;
  }

  private extractChoiceWeight(block: ParseNode): number {
    // æŸ¥æ‰¾æƒé‡ç›¸å…³çš„èµ‹å€¼
    let weight = 1;
    
    this.traverseAST(block, (node) => {
      if (node.type === 'ASSIGNMENT' && node.value === 'weight') {
        const weightNode = node.children[0];
        if (weightNode && weightNode.type === 'LITERAL' && typeof weightNode.value === 'number') {
          weight = weightNode.value;
          return true;
        }
      }
    });

    return weight;
  }

  private extractChoicePriority(block: ParseNode): number {
    // æŸ¥æ‰¾ä¼˜å…ˆçº§ç›¸å…³çš„èµ‹å€¼
    let priority = 0;
    
    this.traverseAST(block, (node) => {
      if (node.type === 'ASSIGNMENT' && node.value === 'priority') {
        const priorityNode = node.children[0];
        if (priorityNode && priorityNode.type === 'LITERAL' && typeof priorityNode.value === 'number') {
          priority = priorityNode.value;
          return true;
        }
      }
    });

    return priority;
  }

  private nodeToString(node: ParseNode): string {
    return node.raw || String(node.value || '');
  }
}
```

#### 3.5 ä¸»è§£æå™¨ç±»
```typescript
// src/utils/pythonScriptParser.ts
import { LexicalAnalyzer } from './lexicalAnalyzer';
import { SyntaxAnalyzer } from './syntaxAnalyzer';
import { StoryExtractor } from './storyExtractor';
import { StoryData, ParseError as ParseErrorType } from '../types/parser';

export class PythonScriptParser {
  private lexicalAnalyzer: LexicalAnalyzer;
  private syntaxAnalyzer: SyntaxAnalyzer;
  private storyExtractor: StoryExtractor;

  constructor() {
    this.lexicalAnalyzer = new LexicalAnalyzer('');
    this.syntaxAnalyzer = new SyntaxAnalyzer([]);
    this.storyExtractor = new StoryExtractor();
  }

  /**
   * è§£æPythonè„šæœ¬å†…å®¹
   */
  parseScript(content: string): { data: StoryData | null; errors: ParseErrorType[] } {
    const errors: ParseErrorType[] = [];
    
    try {
      // 1. è¯æ³•åˆ†æ
      const tokens = this.lexicalAnalyzer.tokenize();
      
      // 2. è¯­æ³•åˆ†æ
      const ast = this.syntaxAnalyzer.parse();
      
      // 3. è¯­ä¹‰åˆ†æ
      const validationErrors = this.validateAST(ast);
      errors.push(...validationErrors);
      
      // 4. å†…å®¹æå–
      const storyData = this.storyExtractor.extractStoryData(ast);
      
      // 5. æ•°æ®éªŒè¯
      const dataErrors = this.validateStoryData(storyData);
      errors.push(...dataErrors);
      
      return {
        data: errors.filter(e => e.severity === 'error').length === 0 ? storyData : null,
        errors
      };
    } catch (error) {
      errors.push({
        type: 'syntax',
        message: error instanceof Error ? error.message : 'Unknown parsing error',
        line: 1,
        column: 1,
        severity: 'error'
      });
      
      return { data: null, errors };
    }
  }

  /**
   * éªŒè¯è¯­æ³•æ ‘
   */
  private validateAST(ast: any): ParseErrorType[] {
    const errors: ParseErrorType[] = [];
    
    // æ£€æŸ¥å¿…é¡»çš„æ•…äº‹å‡½æ•°
    const hasStoryFunctions = this.hasStoryFunctions(ast);
    if (!hasStoryFunctions) {
      errors.push({
        type: 'semantic',
        message: 'No story functions found. At least one story function is required.',
        line: 1,
        column: 1,
        severity: 'error',
        suggestion: 'Add a function starting with "story_" or containing "day"'
      });
    }
    
    // æ£€æŸ¥å¾ªç¯å¼•ç”¨
    const circularRefs = this.detectCircularReferences(ast);
    if (circularRefs.length > 0) {
      errors.push(...circularRefs.map(ref => ({
        type: 'semantic',
        message: `Circular reference detected: ${ref}`,
        line: 1,
        column: 1,
        severity: 'warning'
      })));
    }
    
    return errors;
  }

  /**
   * éªŒè¯æ•…äº‹æ•°æ®
   */
  private validateStoryData(data: StoryData): ParseErrorType[] {
    const errors: ParseErrorType[] = [];
    
    // éªŒè¯ç« èŠ‚å¼•ç”¨å®Œæ•´æ€§
    const sectionIds = new Set(data.sections.map(s => s.id));
    const choiceTargets = new Set(data.choices.map(c => c.nextSection));
    
    for (const target of choiceTargets) {
      if (target && !sectionIds.has(target)) {
        errors.push({
          type: 'validation',
          message: `Choice references non-existent section: ${target}`,
          line: 1,
          column: 1,
          severity: 'error'
        });
      }
    }
    
    // éªŒè¯æ¡ä»¶è¡¨è¾¾å¼
    const allConditions = [...data.winConditions, ...data.deathConditions];
    for (const condition of allConditions) {
      if (!this.isValidCondition(condition)) {
        errors.push({
          type: 'validation',
          message: `Invalid condition: ${condition.field} ${condition.operator} ${condition.value}`,
          line: 1,
          column: 1,
          severity: 'error'
        });
      }
    }
    
    return errors;
  }

  /**
   * è¯­æ³•éªŒè¯
   */
  validateSyntax(content: string): ParseErrorType[] {
    try {
      // ä¸´æ—¶è®¾ç½®æ–°çš„åˆ†æå™¨
      this.lexicalAnalyzer = new LexicalAnalyzer(content);
      const tokens = this.lexicalAnalyzer.tokenize();
      
      this.syntaxAnalyzer = new SyntaxAnalyzer(tokens);
      const ast = this.syntaxAnalyzer.parse();
      
      return this.validateAST(ast);
    } catch (error) {
      return [{
        type: 'syntax',
        message: error instanceof Error ? error.message : 'Syntax validation failed',
        line: 1,
        column: 1,
        severity: 'error'
      }];
    }
  }

  private hasStoryFunctions(ast: any): boolean {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥éå†AST
    return true;
  }

  private detectCircularReferences(ast: any): string[] {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ£€æµ‹å¾ªç¯å¼•ç”¨
    return [];
  }

  private isValidCondition(condition: any): boolean {
    const validOperators = ['==', '!=', '<', '>', '<=', '>=', 'contains'];
    const validTypes = ['attribute', 'item', 'flag', 'time', 'random'];
    
    return validOperators.includes(condition.operator) && 
           validTypes.includes(condition.type);
  }
}

// å¯¼å‡ºå·¥å…·å‡½æ•°
export function parsePythonScript(content: string): { data: StoryData | null; errors: ParseErrorType[] } {
  const parser = new PythonScriptParser();
  return parser.parseScript(content);
}

export function validatePythonScript(content: string): ParseErrorType[] {
  const parser = new PythonScriptParser();
  return parser.validateSyntax(content);
}
```

### 4. å…³é”®æŠ€æœ¯ç‚¹
- **è¯æ³•åˆ†æ**ï¼šPythonè¯­æ³•æ ‡è®°è¯†åˆ«ï¼Œæ”¯æŒå­—ç¬¦ä¸²ã€æ³¨é‡Šã€æ ‡è¯†ç¬¦ç­‰
- **è¯­æ³•åˆ†æ**ï¼šé€’å½’ä¸‹é™è§£æå™¨ï¼Œæ„å»ºæŠ½è±¡è¯­æ³•æ ‘
- **è¯­ä¹‰åˆ†æ**ï¼šæ•…äº‹å†…å®¹æå–ï¼ŒéªŒè¯å¼•ç”¨å®Œæ•´æ€§
- **é”™è¯¯å¤„ç†**ï¼šè¯¦ç»†çš„é”™è¯¯å®šä½å’Œä¿®å¤å»ºè®®
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæµå¼è§£æï¼Œå†…å­˜ä½¿ç”¨ä¼˜åŒ–

### 5. ä¾èµ–é¡¹
- Epic1é¡¹ç›®åŸºç¡€æ¶æ„
- TypeScriptç±»å‹ç³»ç»Ÿ
- æ­£åˆ™è¡¨è¾¾å¼å¼•æ“
- ES6+è¯­æ³•ç‰¹æ€§

## Milestone

**ç¬¬ä¸€é˜¶æ®µï¼ˆå·²å®Œæˆï¼‰**ï¼š
- âœ… è¯æ³•åˆ†æå™¨å¼€å‘ï¼ˆè¯†åˆ«Pythonè¯­æ³•æ ‡è®°ï¼‰
- âœ… è¯­æ³•åˆ†æå™¨å¼€å‘ï¼ˆæ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼‰
- âœ… æ•…äº‹å†…å®¹æå–å™¨å¼€å‘ï¼ˆæå–æ¸¸æˆé€»è¾‘ï¼‰
- âœ… ä¸»è§£æå™¨é›†æˆï¼ˆå®Œæ•´è§£ææµç¨‹ï¼‰

**ç¬¬äºŒé˜¶æ®µï¼ˆå½“å‰è¿›è¡Œï¼‰**ï¼š
- ğŸ”„ é”™è¯¯å¤„ç†æœºåˆ¶å®Œå–„ï¼ˆ30åˆ†é’Ÿï¼‰
- ğŸ”„ æ•°æ®éªŒè¯é€»è¾‘å¢å¼ºï¼ˆ30åˆ†é’Ÿï¼‰
- ğŸ”„ æ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•ï¼ˆ30åˆ†é’Ÿï¼‰

**ç¬¬ä¸‰é˜¶æ®µï¼ˆå¾…å®Œæˆï¼‰**ï¼š
- ğŸ“‹ å•å…ƒæµ‹è¯•å¼€å‘å’Œæ‰§è¡Œï¼ˆ45åˆ†é’Ÿï¼‰
- ğŸ“‹ é›†æˆæµ‹è¯•éªŒè¯ï¼ˆ30åˆ†é’Ÿï¼‰
- ğŸ“‹ æ–‡æ¡£å®Œå–„å’ŒçŠ¶æ€æ›´æ–°ï¼ˆ15åˆ†é’Ÿï¼‰

## æµ‹è¯•æ–¹æ¡ˆ

### åŠŸèƒ½ç‚¹æµ‹è¯•
- Pythonè¯­æ³•æ­£ç¡®è§£æï¼ˆday0-7è„šæœ¬ï¼‰
- æ•…äº‹æ–‡æœ¬å®Œæ•´æå–ï¼ˆæ‰€æœ‰æ®µè½ï¼‰
- é€‰æ‹©åˆ†æ”¯é€»è¾‘è¯†åˆ«ï¼ˆæ¡ä»¶è¡¨è¾¾å¼ï¼‰
- é€šå…³/æ­»äº¡æ¡ä»¶è§£æï¼ˆå±æ€§æ£€æŸ¥ï¼‰
- é”™è¯¯å®šä½å’ŒæŠ¥å‘Šï¼ˆè¡Œåˆ—ä¿¡æ¯ï¼‰

### å¼‚å¸¸æµ‹è¯•
- è¯­æ³•é”™è¯¯æ£€æµ‹ï¼ˆæ— æ•ˆPythonä»£ç ï¼‰
- æ–‡ä»¶ç¼–ç å¤„ç†ï¼ˆUTF-8å…¼å®¹æ€§ï¼‰
- å¾ªç¯å¼•ç”¨æ£€æµ‹ï¼ˆæ•…äº‹é€»è¾‘å†²çªï¼‰
- å†…å­˜æº¢å‡ºé˜²æŠ¤ï¼ˆå¤§æ–‡ä»¶å¤„ç†ï¼‰

### æ€§èƒ½éªŒè¯
- å¤§æ–‡ä»¶è§£ææ—¶é—´<1ç§’ï¼ˆæ€§èƒ½åŸºå‡†ï¼‰
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–ï¼ˆ<100MBå³°å€¼ï¼‰
- é”™è¯¯æ¢å¤é€Ÿåº¦ï¼ˆå¿«é€Ÿå¤±è´¥æœºåˆ¶ï¼‰
- å¹¶å‘è§£æèƒ½åŠ›ï¼ˆå¤šè„šæœ¬å¤„ç†ï¼‰