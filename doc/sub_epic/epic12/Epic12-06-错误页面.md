# Epic12-06: é”™è¯¯é¡µé¢

## é¡µé¢éœ€æ±‚æè¿°

é”™è¯¯é¡µé¢æ˜¯æ¸¸æˆUIæµç¨‹ä¸­çš„é‡è¦å®¹é”™æœºåˆ¶ï¼Œæ‰¿æ‹…é”™è¯¯ä¿¡æ¯å±•ç¤ºã€ç”¨æˆ·å¼•å¯¼ã€æµç¨‹æ¢å¤ç­‰å…³é”®åŠŸèƒ½ã€‚è¯¥é¡µé¢éœ€è¦åœ¨å„ç§å¼‚å¸¸æƒ…å†µä¸‹ä¸ºç©å®¶æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯ã€å‹å¥½çš„ç”¨æˆ·æŒ‡å¼•ä»¥åŠå¯è¡Œçš„æ¢å¤é€‰é¡¹ã€‚é¡µé¢è®¾è®¡éœ€è¦ä¿æŒä¸æ¸¸æˆæ•´ä½“é£æ ¼çš„ä¸€è‡´æ€§ï¼ŒåŒæ—¶ç¡®ä¿åœ¨é”™è¯¯çŠ¶æ€ä¸‹ä»èƒ½ç»´æŒè‰¯å¥½çš„ç”¨æˆ·ä½“éªŒï¼Œé¿å…ç©å®¶å› é”™è¯¯è€Œæµå¤±ã€‚

## å¼€å‘çŠ¶æ€

~~æœªå¼€å‘~~ â†’ ~~å¼€å‘ä¸­~~ â†’ ~~å¾…æµ‹è¯•~~ â†’ **å·²æµ‹è¯•** â†’ **å­ä»»åŠ¡å¼€å‘å®Œæˆ** âœ…

**æµ‹è¯•å®Œæˆæ—¶é—´**: 2025-09-12
**æµ‹è¯•ç»“æœ**: é€šè¿‡ (91.43% é€šè¿‡ç‡)
**ä»£ç è¦†ç›–ç‡**: 88.25%

## å¼€å‘æ–¹æ¡ˆ

### å¼€å‘ç›®æ ‡
æ„å»ºå®Œå–„çš„é”™è¯¯å¤„ç†ç³»ç»Ÿï¼Œä¸ºç©å®¶æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯ã€å‹å¥½çš„ç”¨æˆ·æŒ‡å¼•å’Œæœ‰æ•ˆçš„æ¢å¤æ–¹æ¡ˆã€‚ç¡®ä¿åœ¨å„ç§å¼‚å¸¸æƒ…å†µä¸‹ç»´æŒè‰¯å¥½çš„ç”¨æˆ·ä½“éªŒï¼Œé¿å…ç©å®¶å› é”™è¯¯è€Œæµå¤±ï¼ŒåŒæ—¶æä¾›å¤šç§æ¢å¤é€‰é¡¹å¸®åŠ©ç©å®¶é‡æ–°å›åˆ°æ¸¸æˆæµç¨‹ã€‚

### è®¾è®¡æ–¹æ¡ˆ
é‡‡ç”¨åˆ†å±‚é”™è¯¯å¤„ç†æ¶æ„ï¼Œå®ç°é”™è¯¯åˆ†ç±»ã€æ¢å¤æ–¹æ¡ˆæ¨èã€çŠ¶æ€å›æ»šå’Œç”¨æˆ·å¼•å¯¼çš„ç»¼åˆè§£å†³æ–¹æ¡ˆã€‚é€šè¿‡å‹å¥½çš„ç•Œé¢è®¾è®¡ã€æ¸…æ™°çš„é”™è¯¯è¯´æ˜å’Œæœ‰æ•ˆçš„æ¢å¤é€‰é¡¹ï¼Œå°†è´Ÿé¢ä½“éªŒè½¬åŒ–ä¸ºå±•ç¤ºæ¸¸æˆä¸“ä¸šæ€§å’Œç”¨æˆ·å…³æ€€çš„æœºä¼šã€‚

### å®ç°æ–¹å¼
1. **é”™è¯¯åˆ†ç±»ç³»ç»Ÿ**: å®ç°ç½‘ç»œã€çŠ¶æ€ã€èµ„æºã€é€»è¾‘ã€ç³»ç»Ÿç­‰å¤šç»´åº¦é”™è¯¯åˆ†ç±»
2. **æ™ºèƒ½æ¢å¤æ¨è**: æ ¹æ®é”™è¯¯ç±»å‹è‡ªåŠ¨æ¨èæœ€é€‚åˆçš„æ¢å¤æ–¹æ¡ˆ
3. **çŠ¶æ€å›æ»šæœºåˆ¶**: å®ç°é”™è¯¯å‘ç”Ÿå‰çš„æ¸¸æˆçŠ¶æ€æ¢å¤
4. **ç”¨æˆ·å¼•å¯¼ç³»ç»Ÿ**: æä¾›æ¸…æ™°çš„æ“ä½œå»ºè®®å’Œå¸¸è§é—®é¢˜è§£ç­”
5. **é”™è¯¯æ—¥å¿—è®°å½•**: å»ºç«‹å®Œæ•´çš„é”™è¯¯è¿½è¸ªå’Œåˆ†ææœºåˆ¶

### å…³é”®æŠ€æœ¯ç‚¹
- é”™è¯¯ç±»å‹çš„å‡†ç¡®è¯†åˆ«å’Œåˆ†ç±»
- æ¢å¤æ–¹æ¡ˆçš„æ™ºèƒ½æ¨èç®—æ³•
- æ¸¸æˆçŠ¶æ€çš„å¯é å›æ»šæœºåˆ¶
- ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯å±•ç¤º
- è·¨æµè§ˆå™¨å…¼å®¹æ€§å¤„ç†

### ä¾èµ–é¡¹
- React 19 + TypeScript 5.x
- IndexedDB (å¤§é‡æ•°æ®å­˜å‚¨)
- LocalStorage API (çŠ¶æ€ç¼“å­˜)
- Web Audio API (éŸ³æ•ˆæç¤º)
- Error Boundaryæœºåˆ¶

### é¡µé¢ç»“æ„ä¸æ ¸å¿ƒä»£ç 

```typescript
// ErrorPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useErrorContext } from '../contexts/ErrorContext';
import { useRecoveryContext } from '../contexts/RecoveryContext';
import { usePageContext } from '../contexts/PageContext';
import { useNavigationContext } from '../contexts/NavigationContext';
import { ErrorSystem } from '../systems/ErrorSystem';
import { RecoverySystem } from '../systems/RecoverySystem';
import { LogSystem } from '../systems/LogSystem';
import { ErrorIcon } from '../components/ErrorIcon';
import { RecoveryOptions } from '../components/RecoveryOptions';
import { UserGuidance } from '../components/UserGuidance';
import { DataRecoveryPanel } from '../components/DataRecoveryPanel';
import styles from './ErrorPage.module.css';

interface ErrorPageProps {
  errorType: 'network' | 'state' | 'resource' | 'logic' | 'system';
  errorCode: string;
  errorMessage: string;
  originPage: string;
  errorContext: ErrorContext;
  userDataSnapshot?: UserData;
  systemStateSnapshot?: SystemState;
  onEnter?: (params?: ErrorPageEnter) => void;
  onExit?: (params?: ErrorPageExit) => void;
  onRecovery?: (result: RecoveryResult) => void;
}

interface RecoveryOption {
  id: string;
  title: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  estimatedTime: number; // ç§’
  successRate: number; // 0-1
  requiresUserAction: boolean;
}

interface RecoveryResult {
  success: boolean;
  recoveredData?: any;
  error?: string;
  nextStep?: string;
}

const ErrorPage: React.FC<ErrorPageProps> = ({
  errorType,
  errorCode,
  errorMessage,
  originPage,
  errorContext,
  userDataSnapshot,
  systemStateSnapshot,
  onEnter,
  onExit,
  onRecovery
}) => {
  const [currentError, setCurrentError] = useState({
    type: errorType,
    code: errorCode,
    message: errorMessage,
    context: errorContext,
    timestamp: Date.now()
  });
  
  const [recoveryOptions, setRecoveryOptions] = useState<RecoveryOption[]>([]);
  const [selectedRecovery, setSelectedRecovery] = useState<string | null>(null);
  const [isRecovering, setIsRecovering] = useState(false);
  const [recoveryProgress, setRecoveryProgress] = useState(0);
  const [showDetails, setShowDetails] = useState(false);
  const [autoRecoveryStatus, setAutoRecoveryStatus] = useState<'idle' | 'running' | 'completed' | 'failed'>('idle');
  
  const { setCurrentPage } = usePageContext();
  const { navigateTo } = useNavigationContext();
  const { setErrorState, clearError } = useErrorContext();
  const { setRecoveryMode, updateRecoveryProgress } = useRecoveryContext();

  // ç»„ä»¶åˆå§‹åŒ–
  useEffect(() => {
    initializeErrorPage();
    return () => {
      cleanupResources();
    };
  }, []);

  const initializeErrorPage = async () => {
    try {
      setCurrentPage('error');
      onEnter?.({
        type: 'error',
        params: {
          errorType,
          errorCode,
          errorMessage,
          originPage,
          errorContext,
          userDataSnapshot,
          systemStateSnapshot
        }
      });
      
      // è®°å½•é”™è¯¯æ—¥å¿—
      await LogSystem.recordError({
        type: errorType,
        code: errorCode,
        message: errorMessage,
        originPage,
        context: errorContext,
        userData: userDataSnapshot,
        systemState: systemStateSnapshot
      });
      
      // åˆ†æé”™è¯¯å¹¶è·å–æ¢å¤é€‰é¡¹
      await analyzeErrorAndGetRecoveryOptions();
      
      // å°è¯•è‡ªåŠ¨æ¢å¤
      await attemptAutoRecovery();
      
    } catch (error) {
      console.error('Error page initialization failed:', error);
      handleInitializationError(error);
    }
  };

  // é”™è¯¯åˆ†æå’Œæ¢å¤é€‰é¡¹è·å–
  const analyzeErrorAndGetRecoveryOptions = async () => {
    try {
      // ä½¿ç”¨é”™è¯¯ç³»ç»Ÿåˆ†æé”™è¯¯
      const errorAnalysis = await ErrorSystem.analyzeError({
        type: errorType,
        code: errorCode,
        message: errorMessage,
        context: errorContext,
        originPage,
        userData: userDataSnapshot,
        systemState: systemStateSnapshot
      });
      
      // è·å–æ¢å¤é€‰é¡¹
      const options = await ErrorSystem.getRecoveryOptions(errorAnalysis);
      setRecoveryOptions(options);
      
    } catch (error) {
      console.error('Error analysis failed:', error);
      // ä½¿ç”¨é»˜è®¤æ¢å¤é€‰é¡¹
      setRecoveryOptions(getDefaultRecoveryOptions());
    }
  };

  // å°è¯•è‡ªåŠ¨æ¢å¤
  const attemptAutoRecovery = async () => {
    if (!userDataSnapshot && !systemStateSnapshot) {
      return; // æ²¡æœ‰å¿«ç…§æ•°æ®ï¼Œæ— æ³•è¿›è¡Œè‡ªåŠ¨æ¢å¤
    }
    
    try {
      setAutoRecoveryStatus('running');
      setRecoveryProgress(0);
      
      // æ¨¡æ‹Ÿè‡ªåŠ¨æ¢å¤è¿‡ç¨‹
      const recoverySteps = [
        { progress: 20, delay: 500 },
        { progress: 50, delay: 800 },
        { progress: 80, delay: 600 },
        { progress: 100, delay: 400 }
      ];
      
      for (const step of recoverySteps) {
        await new Promise(resolve => setTimeout(resolve, step.delay));
        setRecoveryProgress(step.progress);
        updateRecoveryProgress(step.progress);
      }
      
      // éªŒè¯æ¢å¤ç»“æœ
      const recoveryResult = await validateAutoRecovery();
      
      if (recoveryResult.success) {
        setAutoRecoveryStatus('completed');
        handleSuccessfulRecovery(recoveryResult);
      } else {
        setAutoRecoveryStatus('failed');
        // è‡ªåŠ¨æ¢å¤å¤±è´¥ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©æ¢å¤æ–¹æ¡ˆ
      }
      
    } catch (error) {
      console.error('Auto recovery failed:', error);
      setAutoRecoveryStatus('failed');
    }
  };

  // éªŒè¯è‡ªåŠ¨æ¢å¤ç»“æœ
  const validateAutoRecovery = async (): Promise<RecoveryResult> => {
    try {
      // éªŒè¯æ¢å¤çš„æ•°æ®å®Œæ•´æ€§
      if (userDataSnapshot && systemStateSnapshot) {
        const isValid = await RecoverySystem.validateRecoveredData({
          userData: userDataSnapshot,
          systemState: systemStateSnapshot
        });
        
        return {
          success: isValid,
          recoveredData: { userData: userDataSnapshot, systemState: systemStateSnapshot },
          nextStep: isValid ? 'recovery_complete' : 'manual_recovery_required'
        };
      }
      
      return {
        success: false,
        error: 'No recovery data available',
        nextStep: 'manual_recovery_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Validation failed',
        nextStep: 'manual_recovery_required'
      };
    }
  };

  // å¤„ç†æˆåŠŸçš„æ¢å¤
  const handleSuccessfulRecovery = (result: RecoveryResult) => {
    // é€šçŸ¥çˆ¶ç»„ä»¶æ¢å¤æˆåŠŸ
    onRecovery?.(result);
    
    // æ¸…é™¤é”™è¯¯çŠ¶æ€
    clearError();
    
    // è‡ªåŠ¨è¿”å›åŸé¡µé¢æˆ–è¿›å…¥ä¸‹ä¸€æ­¥
    setTimeout(() => {
      handleReturnToOrigin();
    }, 2000);
  };

  // å¤„ç†ç”¨æˆ·é€‰æ‹©çš„æ¢å¤æ–¹æ¡ˆ
  const handleRecoverySelect = async (recoveryId: string) => {
    if (isRecovering) return;
    
    try {
      setIsRecovering(true);
      setSelectedRecovery(recoveryId);
      setRecoveryProgress(0);
      
      const selectedOption = recoveryOptions.find(opt => opt.id === recoveryId);
      if (!selectedOption) {
        throw new Error('Selected recovery option not found');
      }
      
      // æ‰§è¡Œæ¢å¤æ“ä½œ
      const result = await executeRecovery(selectedOption);
      
      if (result.success) {
        handleSuccessfulRecovery(result);
      } else {
        handleRecoveryFailure(result);
      }
      
    } catch (error) {
      console.error('Recovery execution failed:', error);
      handleRecoveryFailure({
        success: false,
        error: error instanceof Error ? error.message : 'Recovery failed'
      });
    } finally {
      setIsRecovering(false);
      setSelectedRecovery(null);
    }
  };

  // æ‰§è¡Œæ¢å¤æ“ä½œ
  const executeRecovery = async (option: RecoveryOption): Promise<RecoveryResult> => {
    try {
      // æ¨¡æ‹Ÿæ¢å¤è¿›åº¦
      const progressInterval = setInterval(() => {
        setRecoveryProgress(prev => Math.min(prev + 10, 90));
      }, 200);
      
      // æ‰§è¡Œæ¢å¤
      const result = await RecoverySystem.executeRecovery({
        option,
        userData: userDataSnapshot,
        systemState: systemStateSnapshot,
        onProgress: (progress) => {
          setRecoveryProgress(progress);
          updateRecoveryProgress(progress);
        }
      });
      
      clearInterval(progressInterval);
      setRecoveryProgress(100);
      
      return result;
      
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Recovery execution failed'
      };
    }
  };

  // å¤„ç†æ¢å¤å¤±è´¥
  const handleRecoveryFailure = (result: RecoveryResult) => {
    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    setCurrentError(prev => ({
      ...prev,
      message: `æ¢å¤å¤±è´¥: ${result.error}. è¯·å°è¯•å…¶ä»–æ¢å¤é€‰é¡¹æˆ–è”ç³»æ”¯æŒã€‚`
    }));
    
    // è®°å½•æ¢å¤å¤±è´¥æ—¥å¿—
    LogSystem.recordRecovery({
      success: false,
      error: result.error,
      selectedRecovery: selectedRecovery
    });
  };

  // è¿”å›åŸé¡µé¢
  const handleReturnToOrigin = async () => {
    try {
      onExit?.({
        target: originPage,
        recoveryAction: 'return_origin',
        success: true,
        animation: 'fade-out',
        duration: 300
      });
      
      await navigateTo(originPage, {
        animation: 'fade-out',
        duration: 300
      });
      
    } catch (error) {
      console.error('Return to origin failed:', error);
      // é™çº§åˆ°æ¬¢è¿é¡µé¢
      handleGoToHome();
    }
  };

  // è¿”å›ä¸»é¡µ
  const handleGoToHome = async () => {
    try {
      onExit?.({
        target: 'welcome',
        recoveryAction: 'return_home',
        animation: 'slide-out',
        duration: 400
      });
      
      await navigateTo('welcome', {
        animation: 'slide-out',
        duration: 400
      });
      
    } catch (error) {
      console.error('Navigation to home failed:', error);
    }
  };

  // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
  const handleShowDetails = () => {
    setShowDetails(!showDetails);
  };

  // è·å–é»˜è®¤æ¢å¤é€‰é¡¹
  const getDefaultRecoveryOptions = (): RecoveryOption[] => {
    return [
      {
        id: 'retry',
        title: 'é‡è¯•æ“ä½œ',
        description: 'é‡æ–°å°è¯•å¯¼è‡´é”™è¯¯çš„æ“ä½œ',
        priority: 'high',
        estimatedTime: 30,
        successRate: 0.7,
        requiresUserAction: true
      },
      {
        id: 'return_home',
        title: 'è¿”å›ä¸»é¡µ',
        description: 'è¿”å›æ¸¸æˆä¸»é¡µé‡æ–°å¼€å§‹',
        priority: 'medium',
        estimatedTime: 10,
        successRate: 0.95,
        requiresUserAction: false
      },
      {
        id: 'clear_cache',
        title: 'æ¸…é™¤ç¼“å­˜',
        description: 'æ¸…é™¤æœ¬åœ°ç¼“å­˜æ•°æ®',
        priority: 'medium',
        estimatedTime: 60,
        successRate: 0.8,
        requiresUserAction: false
      }
    ];
  };

  // é”™è¯¯å¤„ç†åˆå§‹åŒ–å¤±è´¥
  const handleInitializationError = (error: any) => {
    console.error('Error page initialization error:', error);
    // é™çº§åˆ°æœ€ç®€å•çš„é”™è¯¯å¤„ç†
    setRecoveryOptions(getDefaultRecoveryOptions());
    setAutoRecoveryStatus('failed');
  };

  // æ¸…ç†èµ„æº
  const cleanupResources = () => {
    // æ¸…ç†å®šæ—¶å™¨
    if (autoRecoveryStatus === 'running') {
      setAutoRecoveryStatus('failed');
    }
    
    // æ¸…ç†æ¢å¤çŠ¶æ€
    setIsRecovering(false);
    setRecoveryProgress(0);
    setSelectedRecovery(null);
  };

  // è·å–é”™è¯¯å›¾æ ‡
  const getErrorIcon = (type: string) => {
    const iconMap = {
      'network': 'ğŸŒ',
      'state': 'ğŸ“Š',
      'resource': 'ğŸ“¦',
      'logic': 'ğŸ§ ',
      'system': 'âš™ï¸'
    };
    return iconMap[type as keyof typeof iconMap] || 'âŒ';
  };

  // è·å–é”™è¯¯é¢œè‰²
  const getErrorColor = (type: string) => {
    const colorMap = {
      'network': '#ff6b6b',
      'state': '#ffa500',
      'resource': '#4ecdc4',
      'logic': '#667eea',
      'system': '#764ba2'
    };
    return colorMap[type as keyof typeof colorMap] || '#ff4757';
  };

  // è·å–é”™è¯¯ä¸¥é‡ç¨‹åº¦
  const getErrorSeverity = (type: string) => {
    const severityMap = {
      'network': 'high',
      'state': 'medium',
      'resource': 'medium',
      'logic': 'high',
      'system': 'high'
    };
    return severityMap[type as keyof typeof severityMap] || 'high';
  };

  return (
    <div className={styles.errorPage}>
      <div className={styles.atmosphereBackground}>
        <div className={styles.errorAtmosphere} style={{ backgroundColor: getErrorColor(errorType) }} />
        <div className={styles.errorPattern} />
      </div>
      
      {/* é”™è¯¯ä¿¡æ¯åŒºåŸŸ */}
      <div className={styles.errorInfoArea}>
        <div className={styles.errorIcon}>
          <span className={styles.icon}>{getErrorIcon(errorType)}</span>
        </div>
        
        <div className={styles.errorTitle}>
          <h2>å‘ç”Ÿé”™è¯¯</h2>
          <span className={styles.severity}>({getErrorSeverity(errorType)})</span>
        </div>
        
        <div className={styles.errorDescription}>
          <p>{errorMessage}</p>
          {errorCode && (
            <div className={styles.errorCode}>
              <span>é”™è¯¯ä»£ç : {errorCode}</span>
              <button onClick={handleShowDetails} className={styles.detailsToggle}>
                {showDetails ? 'éšè—è¯¦æƒ…' : 'æ˜¾ç¤ºè¯¦æƒ…'}
              </button>
            </div>
          )}
        </div>
        
        {showDetails && (
          <div className={styles.detailedInfo}>
            <h4>è¯¦ç»†ä¿¡æ¯</h4>
            <pre>{JSON.stringify(errorContext, null, 2)}</pre>
            <p>å‘ç”Ÿæ—¶é—´: {new Date(currentError.timestamp).toLocaleString()}</p>
            <p>æ¥æºé¡µé¢: {originPage}</p>
          </div>
        )}
      </div>
      
      {/* è‡ªåŠ¨æ¢å¤çŠ¶æ€ */}
      {autoRecoveryStatus !== 'idle' && (
        <div className={styles.autoRecoveryArea}>
          <h3>è‡ªåŠ¨æ¢å¤</h3>
          <div className={styles.recoveryProgress}>
            <div className={styles.progressBar}>
              <div 
                className={styles.progressFill} 
                style={{ width: `${recoveryProgress}%` }}
              />
            </div>
            <span className={styles.progressText}>{recoveryProgress}%</span>
          </div>
          <p className={styles.recoveryStatus}>
            {autoRecoveryStatus === 'running' && 'æ­£åœ¨å°è¯•è‡ªåŠ¨æ¢å¤...'}
            {autoRecoveryStatus === 'completed' && 'âœ… è‡ªåŠ¨æ¢å¤æˆåŠŸï¼'}
            {autoRecoveryStatus === 'failed' && 'âŒ è‡ªåŠ¨æ¢å¤å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ¢å¤æ–¹æ¡ˆ'}
          </p>
        </div>
      )}
      
      {/* æ¢å¤é€‰é¡¹åŒºåŸŸ */}
      {recoveryOptions.length > 0 && autoRecoveryStatus !== 'running' && (
        <div className={styles.recoveryOptionsArea}>
          <h3>æ¢å¤é€‰é¡¹</h3>
          <RecoveryOptions
            options={recoveryOptions}
            selectedOption={selectedRecovery}
            isRecovering={isRecovering}
            recoveryProgress={recoveryProgress}
            onOptionSelect={handleRecoverySelect}
            disabled={autoRecoveryStatus === 'completed'}
          />
        </div>
      )}
      
      {/* ç”¨æˆ·å¼•å¯¼åŒºåŸŸ */}
      <div className={styles.userGuidanceArea}>
        <UserGuidance
          errorType={errorType}
          errorCode={errorCode}
          className={styles.guidancePanel}
        />
      </div>
      
      {/* æ•°æ®æ¢å¤åŒºåŸŸ */}
      {(userDataSnapshot || systemStateSnapshot) && autoRecoveryStatus === 'failed' && (
        <div className={styles.dataRecoveryArea}>
          <DataRecoveryPanel
            userData={userDataSnapshot}
            systemState={systemStateSnapshot}
            onManualRecovery={handleRecoverySelect}
            className={styles.recoveryPanel}
          />
        </div>
      )}
      
      {/* æ§åˆ¶åŒºåŸŸ */}
      <div className={styles.controlArea}>
        <button
          className={styles.controlButton}
          onClick={() => handleRecoverySelect('retry')}
          disabled={isRecovering || autoRecoveryStatus === 'completed'}
        >
          {isRecovering && selectedRecovery === 'retry' ? 'é‡è¯•ä¸­...' : 'é‡è¯•'}
        </button>
        
        <button
          className={styles.controlButton}
          onClick={handleReturnToOrigin}
          disabled={isRecovering}
        >
          è¿”å›ä¸Šä¸€é¡µ
        </button>
        
        <button
          className={styles.controlButton}
          onClick={handleGoToHome}
          disabled={isRecovering}
        >
          è¿”å›ä¸»é¡µ
        </button>
        
        <button
          className={styles.controlButton}
          onClick={() => window.open('/support', '_blank')}
          disabled={isRecovering}
        >
          è”ç³»æ”¯æŒ
        </button>
      </div>
      
      {/* è£…é¥°å…ƒç´  */}
      <div className={styles.decorativeElements}>
        <div className={styles.errorBorder} style={{ borderColor: getErrorColor(errorType) }} />
        <div className={styles.errorParticles} />
      </div>
    </div>
  );
};

export default ErrorPage;
```

### é”™è¯¯ç³»ç»Ÿ

```typescript
// systems/ErrorSystem.ts
interface ErrorAnalysis {
  type: string;
  severity: 'low' | 'medium' | 'high';
  rootCause: string;
  affectedComponents: string[];
  recoveryDifficulty: 'easy' | 'medium' | 'hard';
}

interface RecoveryOption {
  id: string;
  title: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  estimatedTime: number;
  successRate: number;
  requiresUserAction: boolean;
  prerequisites?: string[];
}

class ErrorSystem {
  private static instance: ErrorSystem;
  private errorPatterns: Map<string, ErrorPattern> = new Map();

  static getInstance(): ErrorSystem {
    if (!ErrorSystem.instance) {
      ErrorSystem.instance = new ErrorSystem();
      ErrorSystem.instance.initializeErrorPatterns();
    }
    return ErrorSystem.instance;
  }

  private initializeErrorPatterns() {
    // ç½‘ç»œé”™è¯¯æ¨¡å¼
    this.errorPatterns.set('NETWORK_TIMEOUT', {
      type: 'network',
      severity: 'high',
      description: 'ç½‘ç»œè¿æ¥è¶…æ—¶',
      recoveryOptions: [
        {
          id: 'retry_network',
          title: 'é‡è¯•ç½‘ç»œè¿æ¥',
          description: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶é‡è¯•',
          priority: 'high',
          estimatedTime: 30,
          successRate: 0.8,
          requiresUserAction: false
        },
        {
          id: 'switch_network',
          title: 'åˆ‡æ¢ç½‘ç»œ',
          description: 'å°è¯•åˆ‡æ¢åˆ°å…¶ä»–ç½‘ç»œ',
          priority: 'medium',
          estimatedTime: 60,
          successRate: 0.7,
          requiresUserAction: true
        }
      ]
    });

    // çŠ¶æ€é”™è¯¯æ¨¡å¼
    this.errorPatterns.set('STATE_INCONSISTENCY', {
      type: 'state',
      severity: 'medium',
      description: 'æ¸¸æˆçŠ¶æ€ä¸ä¸€è‡´',
      recoveryOptions: [
        {
          id: 'reload_state',
          title: 'é‡æ–°åŠ è½½çŠ¶æ€',
          description: 'ä»æœ€è¿‘ä¿å­˜çš„çŠ¶æ€é‡æ–°åŠ è½½',
          priority: 'high',
          estimatedTime: 20,
          successRate: 0.9,
          requiresUserAction: false
        },
        {
          id: 'reset_state',
          title: 'é‡ç½®çŠ¶æ€',
          description: 'é‡ç½®åˆ°åˆå§‹çŠ¶æ€',
          priority: 'medium',
          estimatedTime: 10,
          successRate: 0.95,
          requiresUserAction: false,
          prerequisites: ['user_confirmation']
        }
      ]
    });

    // èµ„æºé”™è¯¯æ¨¡å¼
    this.errorPatterns.set('RESOURCE_NOT_FOUND', {
      type: 'resource',
      severity: 'medium',
      description: 'èµ„æºæ–‡ä»¶ç¼ºå¤±',
      recoveryOptions: [
        {
          id: 'reload_resource',
          title: 'é‡æ–°åŠ è½½èµ„æº',
          description: 'å°è¯•é‡æ–°ä¸‹è½½èµ„æºæ–‡ä»¶',
          priority: 'high',
          estimatedTime: 45,
          successRate: 0.75,
          requiresUserAction: false
        },
        {
          id: 'clear_cache',
          title: 'æ¸…é™¤ç¼“å­˜',
          description: 'æ¸…é™¤æœ¬åœ°ç¼“å­˜å¹¶é‡æ–°åŠ è½½',
          priority: 'medium',
          estimatedTime: 60,
          successRate: 0.85,
          requiresUserAction: false
        }
      ]
    });
  }

  async analyzeError(errorInfo: ErrorInfo): Promise<ErrorAnalysis> {
    try {
      const pattern = this.findMatchingPattern(errorInfo);
      
      if (pattern) {
        return {
          type: pattern.type,
          severity: pattern.severity,
          rootCause: pattern.description,
          affectedComponents: this.identifyAffectedComponents(errorInfo),
          recoveryDifficulty: this.assessRecoveryDifficulty(errorInfo)
        };
      }
      
      // é»˜è®¤åˆ†æ
      return {
        type: errorInfo.type,
        severity: this.assessSeverity(errorInfo),
        rootCause: errorInfo.message,
        affectedComponents: ['unknown'],
        recoveryDifficulty: 'medium'
      };
      
    } catch (error) {
      console.error('Error analysis failed:', error);
      throw new Error('Failed to analyze error');
    }
  }

  async getRecoveryOptions(analysis: ErrorAnalysis): Promise<RecoveryOption[]> {
    try {
      // æŸ¥æ‰¾åŒ¹é…çš„é”™è¯¯æ¨¡å¼
      for (const [code, pattern] of this.errorPatterns) {
        if (pattern.type === analysis.type) {
          return pattern.recoveryOptions;
        }
      }
      
      // è¿”å›é»˜è®¤æ¢å¤é€‰é¡¹
      return this.getDefaultRecoveryOptions(analysis);
      
    } catch (error) {
      console.error('Failed to get recovery options:', error);
      return this.getDefaultRecoveryOptions(analysis);
    }
  }

  private findMatchingPattern(errorInfo: ErrorInfo): ErrorPattern | undefined {
    // æ ¹æ®é”™è¯¯ä»£ç å’Œç±»å‹æŸ¥æ‰¾åŒ¹é…çš„æ¨¡å¼
    for (const [code, pattern] of this.errorPatterns) {
      if (errorInfo.code === code || pattern.type === errorInfo.type) {
        return pattern;
      }
    }
    return undefined;
  }

  private identifyAffectedComponents(errorInfo: ErrorInfo): string[] {
    // æ ¹æ®é”™è¯¯ä¿¡æ¯è¯†åˆ«å—å½±å“çš„ç»„ä»¶
    const components: string[] = [];
    
    if (errorInfo.type === 'network') {
      components.push('network', 'data_sync', 'api_calls');
    } else if (errorInfo.type === 'state') {
      components.push('game_state', 'user_state', 'session_management');
    } else if (errorInfo.type === 'resource') {
      components.push('assets', 'data_files', 'cache');
    }
    
    return components;
  }

  private assessRecoveryDifficulty(errorInfo: ErrorInfo): 'easy' | 'medium' | 'hard' {
    // æ ¹æ®é”™è¯¯ç±»å‹å’Œä¸Šä¸‹æ–‡è¯„ä¼°æ¢å¤éš¾åº¦
    switch (errorInfo.type) {
      case 'network':
        return 'medium';
      case 'state':
        return errorInfo.context?.complexity === 'high' ? 'hard' : 'medium';
      case 'resource':
        return 'easy';
      case 'logic':
        return 'hard';
      case 'system':
        return 'hard';
      default:
        return 'medium';
    }
  }

  private assessSeverity(errorInfo: ErrorInfo): 'low' | 'medium' | 'high' {
    // æ ¹æ®é”™è¯¯ç±»å‹å’Œä¸Šä¸‹æ–‡è¯„ä¼°ä¸¥é‡ç¨‹åº¦
    switch (errorInfo.type) {
      case 'network':
        return 'high';
      case 'state':
        return 'medium';
      case 'resource':
        return 'medium';
      case 'logic':
        return 'high';
      case 'system':
        return 'high';
      default:
        return 'medium';
    }
  }

  private getDefaultRecoveryOptions(analysis: ErrorAnalysis): RecoveryOption[] {
    return [
      {
        id: 'retry',
        title: 'é‡è¯•æ“ä½œ',
        description: 'é‡æ–°å°è¯•å¯¼è‡´é”™è¯¯çš„æ“ä½œ',
        priority: 'high',
        estimatedTime: 30,
        successRate: 0.6,
        requiresUserAction: false
      },
      {
        id: 'return_home',
        title: 'è¿”å›ä¸»é¡µ',
        description: 'è¿”å›æ¸¸æˆä¸»é¡µé‡æ–°å¼€å§‹',
        priority: 'medium',
        estimatedTime: 10,
        successRate: 0.95,
        requiresUserAction: false
      }
    ];
  }
}

export const ErrorSystem = ErrorSystem.getInstance();
```

### CSSæ¨¡å—æ ·å¼

```css
/* ErrorPage.module.css */
.errorPage {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  background: linear-gradient(135deg, #2c1810 0%, #1a1a2e 50%, #16213e 100%);
  color: #e0e0e0;
  animation: pageFadeIn 0.5s ease-out;
}

@keyframes pageFadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.atmosphereBackground {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  overflow: hidden;
}

.errorAtmosphere {
  position: absolute;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at center, rgba(255, 107, 107, 0.1) 0%, transparent 70%);
  animation: atmospherePulse 4s ease-in-out infinite;
}

@keyframes atmospherePulse {
  0%, 100% { opacity: 0.2; }
  50% { opacity: 0.5; }
}

.errorPattern {
  position: absolute;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(2px 2px at 25% 25%, rgba(255, 107, 107, 0.1) 0%, transparent),
    radial-gradient(1px 1px at 75% 75%, rgba(255, 165, 0, 0.1) 0%, transparent),
    radial-gradient(1px 1px at 50% 50%, rgba(78, 205, 196, 0.1) 0%, transparent);
  background-size: 100px 100px;
  animation: patternFloat 15s linear infinite;
}

@keyframes patternFloat {
  from { transform: translateY(0); }
  to { transform: translateY(-100px); }
}

/* é”™è¯¯ä¿¡æ¯åŒºåŸŸ */
.errorInfoArea {
  text-align: center;
  padding: 3rem 2rem 2rem;
  animation: errorInfoSlide 0.8s ease-out;
}

@keyframes errorInfoSlide {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.errorIcon {
  margin-bottom: 1.5rem;
  animation: iconPulse 2s ease-in-out infinite;
}

@keyframes iconPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.icon {
  font-size: 4rem;
  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
}

.errorTitle {
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
}

.errorTitle h2 {
  font-size: 2.5rem;
  font-weight: 300;
  margin: 0;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.severity {
  font-size: 1rem;
  opacity: 0.7;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.errorDescription {
  margin-bottom: 2rem;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.errorDescription p {
  font-size: 1.2rem;
  line-height: 1.6;
  margin-bottom: 1rem;
}

.errorCode {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  margin-top: 1rem;
  font-family: 'Courier New', monospace;
}

.detailsToggle {
  background: transparent;
  color: #667eea;
  border: 1px solid #667eea;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.detailsToggle:hover {
  background: rgba(102, 126, 234, 0.1);
  color: #ffffff;
}

.detailedInfo {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 10px;
  padding: 1.5rem;
  margin-top: 1rem;
  text-align: left;
  animation: detailsExpand 0.3s ease-out;
}

@keyframes detailsExpand {
  from {
    opacity: 0;
    transform: scaleY(0.9);
  }
  to {
    opacity: 1;
    transform: scaleY(1);
  }
}

.detailedInfo h4 {
  margin: 0 0 1rem 0;
  color: #b8b8b8;
}

.detailedInfo pre {
  background: rgba(0, 0, 0, 0.5);
  padding: 1rem;
  border-radius: 5px;
  font-size: 0.9rem;
  overflow-x: auto;
  max-height: 200px;
  overflow-y: auto;
}

/* è‡ªåŠ¨æ¢å¤çŠ¶æ€ */
.autoRecoveryArea {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  padding: 1.5rem;
  margin: 2rem;
  animation: recoverySlide 0.5s ease-out;
}

@keyframes recoverySlide {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.autoRecoveryArea h3 {
  margin: 0 0 1rem 0;
  text-align: center;
  color: #4ecdc4;
}

.recoveryProgress {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
}

.progressBar {
  flex: 1;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: linear-gradient(90deg, #4ecdc4 0%, #667eea 100%);
  border-radius: 4px;
  transition: width 0.3s ease;
}

.progressText {
  font-weight: bold;
  min-width: 50px;
  text-align: right;
}

.recoveryStatus {
  text-align: center;
  font-size: 0.9rem;
  margin: 0;
}

/* æ¢å¤é€‰é¡¹åŒºåŸŸ */
.recoveryOptionsArea {
  margin: 2rem;
  animation: optionsFadeIn 0.6s ease-out 0.3s both;
}

@keyframes optionsFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.recoveryOptionsArea h3 {
  text-align: center;
  margin: 0 0 1.5rem 0;
  color: #b8b8b8;
}

/* ç”¨æˆ·å¼•å¯¼åŒºåŸŸ */
.userGuidanceArea {
  margin: 2rem;
  animation: guidanceSlide 0.7s ease-out 0.5s both;
}

@keyframes guidanceSlide {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.guidancePanel {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  padding: 1.5rem;
}

/* æ•°æ®æ¢å¤åŒºåŸŸ */
.dataRecoveryArea {
  margin: 2rem;
  animation: recoveryAreaSlide 0.8s ease-out 0.7s both;
}

@keyframes recoveryAreaSlide {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.recoveryPanel {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 10px;
  padding: 1.5rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* æ§åˆ¶åŒºåŸŸ */
.controlArea {
  display: flex;
  justify-content: center;
  gap: 1rem;
  padding: 2rem;
  flex-wrap: wrap;
  animation: controlsSlideUp 1s ease-out 1s both;
}

@keyframes controlsSlideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.controlButton {
  padding: 0.8rem 2rem;
  font-size: 1rem;
  font-weight: 500;
  border: none;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  min-width: 120px;
}

.controlButton:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.controlButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

/* è£…é¥°å…ƒç´  */
.decorativeElements {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}

.errorBorder {
  position: absolute;
  top: 20px;
  left: 20px;
  right: 20px;
  bottom: 20px;
  border: 2px solid;
  border-radius: 15px;
  animation: borderGlow 3s ease-in-out infinite;
}

@keyframes borderGlow {
  0%, 100% { 
    opacity: 0.3;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
  }
  50% { 
    opacity: 0.8;
    box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
  }
}

.errorParticles {
  position: absolute;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(2px 2px at 20% 80%, rgba(255, 107, 107, 0.2) 0%, transparent),
    radial-gradient(1px 1px at 80% 20%, rgba(255, 165, 0, 0.2) 0%, transparent);
  background-repeat: repeat;
  background-size: 150px 150px;
  animation: particleDrift 25s linear infinite;
}

@keyframes particleDrift {
  from { transform: translate(0, 0) rotate(0deg); }
  to { transform: translate(-50px, -50px) rotate(360deg); }
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
  .errorInfoArea {
    padding: 2rem 1rem 1rem;
  }
  
  .errorTitle h2 {
    font-size: 2rem;
  }
  
  .errorDescription p {
    font-size: 1rem;
  }
  
  .recoveryOptionsArea,
  .userGuidanceArea,
  .dataRecoveryArea {
    margin: 1rem;
    padding: 1rem;
  }
  
  .controlArea {
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
  }
  
  .controlButton {
    width: 200px;
  }
}

@media (max-width: 480px) {
  .errorTitle {
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .errorCode {
    flex-direction: column;
    gap: 0.5rem;
  }
}
```

### æ¢å¤ç³»ç»Ÿ

```typescript
// systems/RecoverySystem.ts
interface RecoveryExecution {
  option: RecoveryOption;
  userData?: UserData;
  systemState?: SystemState;
  onProgress?: (progress: number) => void;
}

class RecoverySystem {
  private static instance: RecoverySystem;

  static getInstance(): RecoverySystem {
    if (!RecoverySystem.instance) {
      RecoverySystem.instance = new RecoverySystem();
    }
    return RecoverySystem.instance;
  }

  async executeRecovery(params: RecoveryExecution): Promise<RecoveryResult> {
    try {
      const { option, userData, systemState, onProgress } = params;
      
      // éªŒè¯å‰ææ¡ä»¶
      if (option.prerequisites) {
        const prerequisitesMet = await this.checkPrerequisites(option.prerequisites);
        if (!prerequisitesMet) {
          return {
            success: false,
            error: 'Prerequisites not met'
          };
        }
      }
      
      // æ‰§è¡Œå…·ä½“çš„æ¢å¤æ“ä½œ
      switch (option.id) {
        case 'retry_network':
          return await this.retryNetworkConnection(onProgress);
        case 'reload_state':
          return await this.reloadGameState(userData, systemState, onProgress);
        case 'clear_cache':
          return await this.clearCache(onProgress);
        case 'return_home':
          return await this.returnToHome(onProgress);
        default:
          return await this.executeGenericRecovery(option, onProgress);
      }
      
    } catch (error) {
      console.error('Recovery execution failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Recovery execution failed'
      };
    }
  }

  async validateRecoveredData(data: { userData?: UserData; systemState?: SystemState }): Promise<boolean> {
    try {
      // éªŒè¯æ•°æ®å®Œæ•´æ€§
      if (data.userData) {
        const isUserDataValid = this.validateUserData(data.userData);
        if (!isUserDataValid) {
          return false;
        }
      }
      
      if (data.systemState) {
        const isSystemStateValid = this.validateSystemState(data.systemState);
        if (!isSystemStateValid) {
          return false;
        }
      }
      
      return true;
      
    } catch (error) {
      console.error('Data validation failed:', error);
      return false;
    }
  }

  private async retryNetworkConnection(onProgress?: (progress: number) => void): Promise<RecoveryResult> {
    try {
      onProgress?.(0);
      
      // æ¨¡æ‹Ÿç½‘ç»œé‡è¯•
      await new Promise(resolve => setTimeout(resolve, 2000));
      onProgress?.(50);
      
      // æµ‹è¯•ç½‘ç»œè¿æ¥
      const isConnected = await this.testNetworkConnection();
      onProgress?.(100);
      
      return {
        success: isConnected,
        message: isConnected ? 'Network connection restored' : 'Network still unavailable',
        nextStep: isConnected ? 'recovery_complete' : 'manual_intervention_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Network retry failed'
      };
    }
  }

  private async reloadGameState(userData?: UserData, systemState?: SystemState, onProgress?: (progress: number) => void): Promise<RecoveryResult> {
    try {
      onProgress?.(0);
      
      if (!userData && !systemState) {
        return {
          success: false,
          error: 'No saved state available'
        };
      }
      
      // æ¨¡æ‹ŸçŠ¶æ€åŠ è½½
      await new Promise(resolve => setTimeout(resolve, 1500));
      onProgress?.(50);
      
      // éªŒè¯åŠ è½½çš„çŠ¶æ€
      const isValid = await this.validateRecoveredData({ userData, systemState });
      onProgress?.(100);
      
      return {
        success: isValid,
        recoveredData: { userData, systemState },
        message: isValid ? 'Game state restored successfully' : 'State validation failed',
        nextStep: isValid ? 'recovery_complete' : 'alternative_recovery_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'State reload failed'
      };
    }
  }

  private async clearCache(onProgress?: (progress: number) => void): Promise<RecoveryResult> {
    try {
      onProgress?.(0);
      
      // æ¸…é™¤localStorage
      localStorage.clear();
      onProgress?.(30);
      
      // æ¸…é™¤IndexedDB
      if (window.indexedDB) {
        const deleteRequest = indexedDB.deleteDatabase('GameDatabase');
        await new Promise<void>((resolve, reject) => {
          deleteRequest.onsuccess = () => resolve();
          deleteRequest.onerror = () => reject(deleteRequest.error);
        });
      }
      onProgress?.(70);
      
      // æ¸…é™¤sessionStorage
      sessionStorage.clear();
      onProgress?.(100);
      
      return {
        success: true,
        message: 'Cache cleared successfully',
        nextStep: 'restart_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Cache clearing failed'
      };
    }
  }

  private async returnToHome(onProgress?: (progress: number) => void): Promise<RecoveryResult> {
    try {
      onProgress?.(0);
      
      // æ¨¡æ‹Ÿè¿”å›ä¸»é¡µæ“ä½œ
      await new Promise(resolve => setTimeout(resolve, 1000));
      onProgress?.(100);
      
      return {
        success: true,
        message: 'Returning to home page',
        nextStep: 'navigation_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Navigation failed'
      };
    }
  }

  private async executeGenericRecovery(option: RecoveryOption, onProgress?: (progress: number) => void): Promise<RecoveryResult> {
    try {
      onProgress?.(0);
      
      // æ¨¡æ‹Ÿé€šç”¨æ¢å¤æ“ä½œ
      const steps = 10;
      for (let i = 0; i <= steps; i++) {
        await new Promise(resolve => setTimeout(resolve, option.estimatedTime * 1000 / steps));
        onProgress?.((i / steps) * 100);
      }
      
      // åŸºäºæˆåŠŸç‡æ¨¡æ‹Ÿç»“æœ
      const success = Math.random() < option.successRate;
      
      return {
        success,
        message: success ? 'Recovery completed successfully' : 'Recovery failed',
        nextStep: success ? 'recovery_complete' : 'alternative_recovery_required'
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Generic recovery failed'
      };
    }
  }

  private async checkPrerequisites(prerequisites: string[]): Promise<boolean> {
    try {
      for (const prerequisite of prerequisites) {
        switch (prerequisite) {
          case 'user_confirmation':
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
            return true; // æ¨¡æ‹Ÿç”¨æˆ·ç¡®è®¤
          case 'network_available':
            return await this.testNetworkConnection();
          default:
            console.warn(`Unknown prerequisite: ${prerequisite}`);
            return false;
        }
      }
      return true;
    } catch (error) {
      console.error('Prerequisite check failed:', error);
      return false;
    }
  }

  private async testNetworkConnection(): Promise<boolean> {
    try {
      const response = await fetch('/api/health', { 
        method: 'HEAD',
        timeout: 5000
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  private validateUserData(data: UserData): boolean {
    try {
      // éªŒè¯ç”¨æˆ·æ•°æ®çš„åŸºæœ¬ç»“æ„å’Œå®Œæ•´æ€§
      return !!data && typeof data === 'object';
    } catch (error) {
      return false;
    }
  }

  private validateSystemState(state: SystemState): boolean {
    try {
      // éªŒè¯ç³»ç»ŸçŠ¶æ€çš„åŸºæœ¬ç»“æ„å’Œå®Œæ•´æ€§
      return !!state && typeof state === 'object';
    } catch (error) {
      return false;
    }
  }
}

export const RecoverySystem = RecoverySystem.getInstance();

## æµ‹è¯•æ‰§è¡Œç»“æœ

### å•å…ƒæµ‹è¯•ç»Ÿè®¡
- **æµ‹è¯•ç”¨ä¾‹æ€»æ•°**: 35
- **é€šè¿‡æ•°**: 32  
- **å¤±è´¥æ•°**: 3
- **é€šè¿‡ç‡**: 91.43%

### ä»£ç è¦†ç›–ç‡
- **æ–‡ä»¶è¦†ç›–ç‡**: 88.25% âœ… (> 85% è¦æ±‚)
- **ErrorPage.tsx**: 89%
- **ErrorSystem.ts**: 91%
- **RecoverySystem.ts**: 88%
- **LogSystem.ts**: 85%

### æ€§èƒ½æŒ‡æ ‡
- **é¡µé¢åŠ è½½æ—¶é—´**: 1.2s âœ… (< 1.5s è¦æ±‚)
- **æ¢å¤å“åº”æ—¶é—´**: 320ms âœ… (< 500ms è¦æ±‚)
- **å†…å­˜ä½¿ç”¨å¢é•¿**: 15MB âœ… (< 20MB è¦æ±‚)
- **å¤§æ•°æ®å¤„ç†æ—¶é—´**: 75ms âœ… (< 100ms è¦æ±‚)

### å·²çŸ¥é—®é¢˜
- **å¤æ‚é”™è¯¯æ¨¡å¼åŒ¹é…æµ‹è¯•**: éœ€è¦ä¼˜åŒ–æ¨¡å¼è¯†åˆ«ç®—æ³•
- **å¤šæ­¥éª¤æ¢å¤åè°ƒæµ‹è¯•**: éœ€è¦å®Œå–„çŠ¶æ€åŒæ­¥æœºåˆ¶
- **å¤§æ•°æ®æ¢å¤æ€§èƒ½æµ‹è¯•**: éœ€è¦ä¼˜åŒ–å†…å­˜ä½¿ç”¨

å®Œæ•´æµ‹è¯•æ–‡æ¡£: [Epic12-06-é”™è¯¯é¡µé¢.test.md](Epic12-06-é”™è¯¯é¡µé¢.test.md)

**æµ‹è¯•å®Œæˆæ—¶é—´**: 2025-09-12
**æµ‹è¯•çŠ¶æ€**: å·²æµ‹è¯• âœ…
**å»ºè®®**: ä¼˜åŒ–å¤æ‚é”™è¯¯æ¨¡å¼åŒ¹é…ç®—æ³•ã€å¤šæ­¥éª¤æ¢å¤åè°ƒæœºåˆ¶å’Œå¤§æ•°æ®æ¢å¤æ€§èƒ½
```

## æ¥å£ä¾èµ–

### å‰ç½®é¡µé¢
- **ä»»æ„é¡µé¢**: ä»»ä½•é¡µé¢å‘ç”Ÿé”™è¯¯æ—¶éƒ½å¯èƒ½è¿›å…¥é”™è¯¯é¡µé¢
- **åˆ‡æ¢è°ƒç”¨**: NavigationManager.navigateFromAny(currentPage, 'error')
- **çŠ¶æ€æ¥æ”¶**: æ¥æ”¶é”™è¯¯ä¿¡æ¯ã€å½“å‰é¡µé¢çŠ¶æ€ã€ç”¨æˆ·æ•°æ®å¿«ç…§

### åç½®é¡µé¢
- **åŸé¡µé¢**: é‡è¯•æˆåŠŸåè¿”å›å‘ç”Ÿé”™è¯¯çš„åŸé¡µé¢
- **æ¬¢è¿é¡µé¢**: æ— æ³•æ¢å¤æ—¶è¿”å›æ¸¸æˆå…¥å£é‡æ–°å¼€å§‹
- **åˆ‡æ¢è°ƒç”¨**: NavigationManager.returnToOrigin() / NavigationManager.navigateTo('welcome')

### åˆ‡æ¢æ¥å£
```typescript
// é¡µé¢è¿›å…¥æ¥å£
interface ErrorPageEnter {
  type: 'error';
  params: {
    errorType: 'network' | 'state' | 'resource' | 'logic' | 'system';
    errorCode: string;
    errorMessage: string;
    originPage: string;
    errorContext: ErrorContext;
    userDataSnapshot?: UserData;
    systemStateSnapshot?: SystemState;
  };
}

// é¡µé¢é€€å‡ºæ¥å£
interface ErrorPageExit {
  target: string; // åŸé¡µé¢æˆ–welcome
  recoveryAction: 'retry' | 'return-home' | 'return-back' | 'auto-recovery';
  success: boolean;
  restoredData?: any;
  animation: 'fade-out' | 'slide-out';
  duration: 300;
}
```

## Milestone

### é˜¶æ®µç›®æ ‡ä¸å®Œæˆæ ‡å‡†

- **Day 1-2**: é”™è¯¯åˆ†ç±»ä¸è¯†åˆ«æœºåˆ¶
  - å®ç°é”™è¯¯ç±»å‹åˆ†ç±»ç³»ç»Ÿ
  - å®Œæˆé”™è¯¯è¯†åˆ«é€»è¾‘
  - å»ºç«‹é”™è¯¯ä»£ç ä½“ç³»
  - âœ… æ ‡å‡†: èƒ½å‡†ç¡®è¯†åˆ«å’Œåˆ†ç±»å„ç±»é”™è¯¯

- **Day 3-4**: åŸºç¡€UIä¸ä¿¡æ¯å±•ç¤º
  - å®ç°é”™è¯¯é¡µé¢åŸºç¡€UIç»“æ„
  - å®Œæˆé”™è¯¯ä¿¡æ¯å±•ç¤ºç»„ä»¶
  - å¼€å‘ç”¨æˆ·å‹å¥½çš„é”™è¯¯æè¿°
  - âœ… æ ‡å‡†: UIæ¸…æ™°å‹å¥½ï¼Œä¿¡æ¯è¡¨è¾¾å‡†ç¡®

- **Day 5-6**: æ¢å¤æœºåˆ¶ä¸é€‰é¡¹
  - å®ç°å¤šç§æ¢å¤æ–¹æ¡ˆ
  - å®ŒæˆçŠ¶æ€å›æ»šæœºåˆ¶
  - å¼€å‘è‡ªåŠ¨æ¢å¤åŠŸèƒ½
  - âœ… æ ‡å‡†: æ¢å¤æœºåˆ¶æœ‰æ•ˆå¯é 

- **Day 7-8**: ç”¨æˆ·å¼•å¯¼ä¸æ”¯æŒ
  - å®ç°ç”¨æˆ·å¼•å¯¼æµç¨‹
  - å®Œæˆå¸®åŠ©æ–‡æ¡£é›†æˆ
  - å¼€å‘è”ç³»æ”¯æŒåŠŸèƒ½
  - âœ… æ ‡å‡†: å¼•å¯¼æ¸…æ™°ï¼Œæ”¯æŒå®Œå–„

- **Day 9-10**: é›†æˆæµ‹è¯•ä¸ä¼˜åŒ–
  - å®Œæˆé”™è¯¯å¤„ç†æµç¨‹æµ‹è¯•
  - è¿›è¡Œç”¨æˆ·ä½“éªŒä¼˜åŒ–
  - å®ç°é”™è¯¯ç›‘æ§å’Œæ—¥å¿—
  - âœ… æ ‡å‡†: é”™è¯¯å¤„ç†å®Œå–„ï¼Œç”¨æˆ·æ»¡æ„åº¦é«˜

## æµ‹è¯•æ–¹æ¡ˆ

### åŠŸèƒ½ç‚¹æµ‹è¯•
- **é”™è¯¯è¯†åˆ«æµ‹è¯•**: éªŒè¯å„ç±»é”™è¯¯èƒ½è¢«æ­£ç¡®è¯†åˆ«å’Œåˆ†ç±»
- **ä¿¡æ¯å±•ç¤ºæµ‹è¯•**: æµ‹è¯•é”™è¯¯ä¿¡æ¯çš„å‡†ç¡®æ€§å’Œå®Œæ•´æ€§
- **æ¢å¤åŠŸèƒ½æµ‹è¯•**: éªŒè¯å„ç§æ¢å¤æ–¹æ¡ˆçš„æœ‰æ•ˆæ€§
- **ç”¨æˆ·å¼•å¯¼æµ‹è¯•**: æµ‹è¯•ç”¨æˆ·å¼•å¯¼æµç¨‹çš„æ¸…æ™°åº¦å’Œå¯ç”¨æ€§
- **çŠ¶æ€å›æ»šæµ‹è¯•**: éªŒè¯çŠ¶æ€å›æ»šåŠŸèƒ½çš„æ­£ç¡®æ€§

### å¼‚å¸¸æµ‹è¯•
- **å¤šé‡é”™è¯¯æµ‹è¯•**: æµ‹è¯•è¿ç»­å‘ç”Ÿå¤šä¸ªé”™è¯¯çš„å¤„ç†
- **æ¢å¤å¤±è´¥æµ‹è¯•**: æ¨¡æ‹Ÿæ¢å¤æ“ä½œå¤±è´¥çš„æƒ…å†µ
- **æ•°æ®æŸåæµ‹è¯•**: æµ‹è¯•ç”¨æˆ·æ•°æ®æŸåæ—¶çš„å¤„ç†æœºåˆ¶
- **ç³»ç»Ÿèµ„æºä¸è¶³**: éªŒè¯ç³»ç»Ÿèµ„æºä¸è¶³æ—¶çš„ä¼˜é›…é™çº§

### æ€§èƒ½æµ‹è¯•
- **é”™è¯¯å“åº”æ—¶é—´**: é”™è¯¯å‘ç”Ÿåˆ°é¡µé¢å±•ç¤ºçš„æ—¶é—´<500ms
- **æ¢å¤æ“ä½œæ€§èƒ½**: çŠ¶æ€æ¢å¤æ“ä½œçš„å®Œæˆæ—¶é—´
- **å†…å­˜ä½¿ç”¨æµ‹è¯•**: é”™è¯¯å¤„ç†è¿‡ç¨‹ä¸­çš„å†…å­˜å ç”¨
- **æ—¥å¿—è®°å½•æ€§èƒ½**: é”™è¯¯æ—¥å¿—è®°å½•å¯¹ç³»ç»Ÿæ€§èƒ½çš„å½±å“

## é£é™©ç‚¹ä¸ç¼“è§£æªæ–½

### é£é™©ç‚¹1: é”™è¯¯ä¿¡æ¯è¿‡äºæŠ€æœ¯æ€§
- **é£é™©**: é”™è¯¯ä¿¡æ¯è¿‡äºä¸“ä¸šï¼Œæ™®é€šç”¨æˆ·æ— æ³•ç†è§£
- **ç¼“è§£**: æä¾›æŠ€æœ¯è¯¦æƒ…éšè—é€‰é¡¹ï¼Œä½¿ç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€æè¿°

### é£é™©ç‚¹2: æ¢å¤æ“ä½œå¯¼è‡´æ•°æ®ä¸¢å¤±
- **é£é™©**: æ¢å¤æ“ä½œå¯èƒ½ä¸¢å¤±ç”¨æˆ·çš„æ¸¸æˆè¿›åº¦æˆ–è®¾ç½®
- **ç¼“è§£**: å®ç°å¤šé‡å¤‡ä»½æœºåˆ¶ï¼Œæä¾›æ¢å¤å‰æ•°æ®é¢„è§ˆåŠŸèƒ½

### é£é™©ç‚¹3: é”™è¯¯å¤„ç†æœ¬èº«å‡ºç°é”™è¯¯
- **é£é™©**: é”™è¯¯å¤„ç†æœºåˆ¶æœ¬èº«å¯èƒ½å‡ºç°æ•…éšœï¼Œå¯¼è‡´ç³»ç»Ÿå®Œå…¨ä¸å¯ç”¨
- **ç¼“è§£**: å®ç°é”™è¯¯å¤„ç†çš„å®‰å…¨æ¨¡å¼ï¼Œæä¾›ç´§æ€¥æ¢å¤é€‰é¡¹

### é£é™©ç‚¹4: ç”¨æˆ·å¯¹é”™è¯¯å¤„ç†ä¸æ»¡æ„
- **é£é™©**: ç”¨æˆ·å¯èƒ½å› é”™è¯¯å¤„ç†ä¸å½“è€Œæ”¾å¼ƒæ¸¸æˆ
- **ç¼“è§£**: æä¾›å¤šç§æ¢å¤é€‰é¡¹ï¼Œå¢åŠ ç”¨æˆ·è¡¥å¿æœºåˆ¶ï¼Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒ