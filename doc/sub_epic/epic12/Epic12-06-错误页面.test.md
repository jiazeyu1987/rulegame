# Epic12-06: é”™è¯¯é¡µé¢å•å…ƒæµ‹è¯•

## æµ‹è¯•æ¦‚è¿°

æœ¬æ–‡æ¡£åŒ…å«é”™è¯¯é¡µé¢ç»„ä»¶çš„å®Œæ•´å•å…ƒæµ‹è¯•è®¡åˆ’ï¼Œä¸“æ³¨äºé”™è¯¯åˆ†ç±»ã€æ¢å¤æœºåˆ¶ã€çŠ¶æ€ç®¡ç†ã€ç”¨æˆ·å¼•å¯¼å’Œå¼‚å¸¸å¤„ç†ç­‰å®¹é”™åŠŸèƒ½ã€‚æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹å‡ä¸ºå¯æ‰§è¡Œä»£ç ï¼Œç¡®ä¿é”™è¯¯å¤„ç†ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯é æ€§ã€‚

## æµ‹è¯•ç¯å¢ƒ

- **æµ‹è¯•æ¡†æ¶**: Jest + React Testing Library
- **ç±»å‹æ£€æŸ¥**: TypeScript
- **è¦†ç›–ç‡è¦æ±‚**: 85%ä»¥ä¸Š
- **æ‰§è¡Œç¯å¢ƒ**: Node.js + JSDOM

## åŠŸèƒ½ç‚¹æµ‹è¯•

### 1. é”™è¯¯é¡µé¢åˆå§‹åŒ–ä¸åˆ†ç±»æµ‹è¯•

```typescript
// ErrorPage.initialization.test.tsx
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ErrorPage from '../ErrorPage';
import { ErrorProvider } from '../../../contexts/ErrorContext';
import { RecoveryProvider } from '../../../contexts/RecoveryContext';
import { PageProvider } from '../../../contexts/PageContext';
import { NavigationProvider } from '../../../contexts/NavigationContext';

// æ¨¡æ‹Ÿé”™è¯¯æ•°æ®
const mockErrorInfo = {
  errorType: 'network' as const,
  errorCode: 'NETWORK_TIMEOUT',
  errorMessage: 'ç½‘ç»œè¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥',
  originPage: 'game-main',
  errorContext: {
    operation: 'fetch_game_data',
    timestamp: Date.now(),
    details: 'Connection timeout after 30 seconds'
  },
  userDataSnapshot: {
    currentDay: 3,
    characterState: {
      time: 12,
      hunger: 40,
      stamina: 70,
      sanity: 80
    }
  },
  systemStateSnapshot: {
    gameFlags: { day_3_started: true },
    currentStory: 'story-3-1'
  }
};

const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <ErrorProvider>
      <RecoveryProvider>
        <PageProvider>
          <NavigationProvider>
            {component}
          </NavigationProvider>
        </PageProvider>
      </RecoveryProvider>
    </ErrorProvider>
  );
};

// æ¨¡æ‹Ÿç³»ç»Ÿå’ŒæœåŠ¡
jest.mock('../../../systems/ErrorSystem', () => ({
  ErrorSystem: {
    analyzeError: jest.fn().mockResolvedValue({
      type: 'network',
      severity: 'high',
      rootCause: 'Network connection timeout',
      affectedComponents: ['network', 'data_sync'],
      recoveryDifficulty: 'medium'
    }),
    getRecoveryOptions: jest.fn().mockResolvedValue([
      {
        id: 'retry_network',
        title: 'é‡è¯•ç½‘ç»œè¿æ¥',
        description: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶é‡è¯•',
        priority: 'high',
        estimatedTime: 30,
        successRate: 0.8,
        requiresUserAction: false
      }
    ])
  }
}));

jest.mock('../../../systems/RecoverySystem', () => ({
  RecoverySystem: {
    validateRecoveredData: jest.fn().mockResolvedValue(true),
    executeRecovery: jest.fn().mockResolvedValue({
      success: true,
      message: 'Recovery completed successfully'
    })
  }
}));

jest.mock('../../../systems/LogSystem', () => ({
  LogSystem: {
    recordError: jest.fn().mockResolvedValue(undefined),
    recordRecovery: jest.fn().mockResolvedValue(undefined)
  }
}));

describe('ErrorPage é”™è¯¯é¡µé¢åˆå§‹åŒ–ä¸åˆ†ç±»', () => {
  test('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–ä¸åŒç±»å‹çš„é”™è¯¯', async () => {
    const errorTypes = [
      { type: 'network' as const, icon: 'ğŸŒ', expectedTitle: 'ç½‘ç»œé”™è¯¯' },
      { type: 'state' as const, icon: 'ğŸ“Š', expectedTitle: 'çŠ¶æ€é”™è¯¯' },
      { type: 'resource' as const, icon: 'ğŸ“¦', expectedTitle: 'èµ„æºé”™è¯¯' },
      { type: 'logic' as const, icon: 'ğŸ§ ', expectedTitle: 'é€»è¾‘é”™è¯¯' },
      { type: 'system' as const, icon: 'âš™ï¸', expectedTitle: 'ç³»ç»Ÿé”™è¯¯' }
    ];

    for (const testCase of errorTypes) {
      const { rerender } = renderWithProviders(
        <ErrorPage
          errorType={testCase.type}
          errorCode={`${testCase.type.toUpperCase()}_ERROR`}
          errorMessage={`${testCase.type}é”™è¯¯æ¶ˆæ¯`}
          originPage="test-page"
          errorContext={{}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('å‘ç”Ÿé”™è¯¯')).toBeInTheDocument();
        expect(screen.getByText(testCase.icon)).toBeInTheDocument();
      });

      // æ¸…ç†å¹¶å‡†å¤‡ä¸‹ä¸€ä¸ªæµ‹è¯•
      rerender(<></>);
    }
  });

  test('åº”è¯¥æ­£ç¡®æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥"
        originPage="game-main"
        errorContext={{ operation: 'fetch_data' }}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('ç½‘ç»œè¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥')).toBeInTheDocument();
      expect(screen.getByText('é”™è¯¯ä»£ç : NETWORK_TIMEOUT')).toBeInTheDocument();
      expect(screen.getByText('æ¥æºé¡µé¢: game-main')).toBeInTheDocument();
    });
  });

  test('åº”è¯¥æ­£ç¡®è®¾ç½®é¡µé¢çŠ¶æ€', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="test-page"
        errorContext={{}}
      />
    );

    // éªŒè¯é¡µé¢ä¸Šä¸‹æ–‡è¢«æ­£ç¡®è®¾ç½®
    await waitFor(() => {
      expect(screen.getByText('ç½‘ç»œè¿æ¥è¶…æ—¶')).toBeInTheDocument();
    });

    // éªŒè¯é”™è¯¯ç³»ç»Ÿè¢«è°ƒç”¨
    const { ErrorSystem } = require('../../../systems/ErrorSystem');
    await waitFor(() => {
      expect(ErrorSystem.analyzeError).toHaveBeenCalled();
    });
  });

  test('åº”è¯¥è®°å½•é”™è¯¯æ—¥å¿—', async () => {
    const { LogSystem } = require('../../../systems/LogSystem');
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{ operation: 'fetch_game_data' }}
      />
    );

    await waitFor(() => {
      expect(LogSystem.recordError).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'network',
          code: 'NETWORK_TIMEOUT',
          message: 'ç½‘ç»œè¿æ¥è¶…æ—¶',
          originPage: 'game-main'
        })
      );
    });
  });

  test('åº”è¯¥æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„ä¸¥é‡ç¨‹åº¦', async () => {
    const severityTestCases = [
      { type: 'network' as const, expectedSeverity: 'HIGH' },
      { type: 'state' as const, expectedSeverity: 'MEDIUM' },
      { type: 'resource' as const, expectedSeverity: 'MEDIUM' },
      { type: 'logic' as const, expectedSeverity: 'HIGH' },
      { type: 'system' as const, expectedSeverity: 'HIGH' }
    ];

    for (const testCase of severityTestCases) {
      const { rerender } = renderWithProviders(
        <ErrorPage
          errorType={testCase.type}
          errorCode={`${testCase.type.toUpperCase()}_ERROR`}
          errorMessage={`${testCase.type}é”™è¯¯`}
          originPage="test-page"
          errorContext={{}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText(testCase.expectedSeverity)).toBeInTheDocument();
      });

      rerender(<></>);
    }
  });
});
```

### 2. è‡ªåŠ¨æ¢å¤ç³»ç»Ÿæµ‹è¯•

```typescript
// ErrorPage.autoRecovery.test.tsx
describe('ErrorPage è‡ªåŠ¨æ¢å¤ç³»ç»Ÿ', () => {
  test('åº”è¯¥å°è¯•è‡ªåŠ¨æ¢å¤å½“æœ‰å¿«ç…§æ•°æ®æ—¶', async () => {
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{
          currentDay: 3,
          characterState: { time: 12, hunger: 40, stamina: 70, sanity: 80 }
        }}
        systemStateSnapshot={{
          gameFlags: { day_3_started: true },
          currentStory: 'story-3-1'
        }}
      />
    );

    // éªŒè¯è‡ªåŠ¨æ¢å¤åŒºåŸŸæ˜¾ç¤º
    await waitFor(() => {
      expect(screen.getByText('è‡ªåŠ¨æ¢å¤')).toBeInTheDocument();
      expect(screen.getByText('æ­£åœ¨å°è¯•è‡ªåŠ¨æ¢å¤...')).toBeInTheDocument();
    });

    // éªŒè¯æ¢å¤ç³»ç»Ÿè¢«è°ƒç”¨
    await waitFor(() => {
      expect(RecoverySystem.validateRecoveredData).toHaveBeenCalled();
    });
  });

  test('åº”è¯¥æ˜¾ç¤ºè‡ªåŠ¨æ¢å¤è¿›åº¦', async () => {
    jest.useFakeTimers();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{ currentDay: 3 }}
        systemStateSnapshot={{ gameFlags: {} }}
      />
    );

    // ç­‰å¾…è‡ªåŠ¨æ¢å¤å¼€å§‹
    await waitFor(() => {
      expect(screen.getByText('è‡ªåŠ¨æ¢å¤')).toBeInTheDocument();
    });

    // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
    act(() => {
      jest.advanceTimersByTime(2000);
    });

    // éªŒè¯è¿›åº¦æ˜¾ç¤º
    const progressElement = screen.getByText(/%/);
    expect(progressElement).toBeInTheDocument();

    jest.useRealTimers();
  });

  test('åº”è¯¥å¤„ç†è‡ªåŠ¨æ¢å¤æˆåŠŸ', async () => {
    const mockOnRecovery = jest.fn();
    const mockOnExit = jest.fn();
    
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    RecoverySystem.validateRecoveredData.mockResolvedValue(true);
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{ currentDay: 3 }}
        systemStateSnapshot={{ gameFlags: {} }}
        onRecovery={mockOnRecovery}
        onExit={mockOnExit}
      />
    );

    // ç­‰å¾…è‡ªåŠ¨æ¢å¤å®Œæˆ
    await waitFor(() => {
      expect(screen.getByText('âœ… è‡ªåŠ¨æ¢å¤æˆåŠŸï¼')).toBeInTheDocument();
    });

    // éªŒè¯æ¢å¤å›è°ƒè¢«è°ƒç”¨
    await waitFor(() => {
      expect(mockOnRecovery).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          message: 'è‡ªåŠ¨æ¢å¤æˆåŠŸï¼'
        })
      );
    });
  });

  test('åº”è¯¥å¤„ç†è‡ªåŠ¨æ¢å¤å¤±è´¥', async () => {
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    RecoverySystem.validateRecoveredData.mockResolvedValue(false);
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{ currentDay: 3 }}
        systemStateSnapshot={{ gameFlags: {} }}
      />
    );

    // ç­‰å¾…è‡ªåŠ¨æ¢å¤å¤±è´¥
    await waitFor(() => {
      expect(screen.getByText('âŒ è‡ªåŠ¨æ¢å¤å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ¢å¤æ–¹æ¡ˆ')).toBeInTheDocument();
    });

    // éªŒè¯æ¢å¤é€‰é¡¹ä»ç„¶å¯ç”¨
    await waitFor(() => {
      expect(screen.getByText('æ¢å¤é€‰é¡¹')).toBeInTheDocument();
    });
  });

  test('ä¸åº”è¯¥å°è¯•è‡ªåŠ¨æ¢å¤å½“æ²¡æœ‰å¿«ç…§æ•°æ®æ—¶', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        // ä¸æä¾›userDataSnapshotå’ŒsystemStateSnapshot
      />
    );

    // éªŒè¯è‡ªåŠ¨æ¢å¤åŒºåŸŸä¸æ˜¾ç¤º
    await waitFor(() => {
      expect(screen.queryByText('è‡ªåŠ¨æ¢å¤')).not.toBeInTheDocument();
    });

    // éªŒè¯ç›´æ¥æ˜¾ç¤ºæ¢å¤é€‰é¡¹
    expect(screen.getByText('æ¢å¤é€‰é¡¹')).toBeInTheDocument();
  });
});
```

### 3. æ¢å¤é€‰é¡¹åŠŸèƒ½æµ‹è¯•

```typescript
// ErrorPage.recovery.test.tsx
describe('ErrorPage æ¢å¤é€‰é¡¹åŠŸèƒ½', () => {
  test('åº”è¯¥æ­£ç¡®æ˜¾ç¤ºæ¢å¤é€‰é¡¹', async () => {
    const { ErrorSystem } = require('../../../systems/ErrorSystem');
    
    const mockRecoveryOptions = [
      {
        id: 'retry_network',
        title: 'é‡è¯•ç½‘ç»œè¿æ¥',
        description: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶é‡è¯•',
        priority: 'high',
        estimatedTime: 30,
        successRate: 0.8,
        requiresUserAction: false
      },
      {
        id: 'return_home',
        title: 'è¿”å›ä¸»é¡µ',
        description: 'è¿”å›æ¸¸æˆä¸»é¡µé‡æ–°å¼€å§‹',
        priority: 'medium',
        estimatedTime: 10,
        successRate: 0.95,
        requiresUserAction: false
      }
    ];
    
    ErrorSystem.getRecoveryOptions.mockResolvedValue(mockRecoveryOptions);
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    // ç­‰å¾…æ¢å¤é€‰é¡¹åŠ è½½
    await waitFor(() => {
      expect(screen.getByText('æ¢å¤é€‰é¡¹')).toBeInTheDocument();
      expect(screen.getByText('é‡è¯•ç½‘ç»œè¿æ¥')).toBeInTheDocument();
      expect(screen.getByText('è¿”å›ä¸»é¡µ')).toBeInTheDocument();
    });
  });

  test('åº”è¯¥å¤„ç†ç”¨æˆ·é€‰æ‹©çš„æ¢å¤æ–¹æ¡ˆ', async () => {
    const user = userEvent.setup();
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('é‡è¯•ç½‘ç»œè¿æ¥')).toBeInTheDocument();
    });

    // é€‰æ‹©æ¢å¤æ–¹æ¡ˆ
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await user.click(retryButton);

    // éªŒè¯æ¢å¤ç³»ç»Ÿè¢«è°ƒç”¨
    await waitFor(() => {
      expect(RecoverySystem.executeRecovery).toHaveBeenCalledWith(
        expect.objectContaining({
          option: expect.objectContaining({
            id: 'retry_network'
          })
        })
      );
    });
  });

  test('åº”è¯¥æ˜¾ç¤ºæ¢å¤è¿›åº¦', async () => {
    jest.useFakeTimers();
    
    const user = userEvent.setup();
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
    RecoverySystem.executeRecovery.mockImplementation(async (params) => {
      const { onProgress } = params;
      
      // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
      const steps = [20, 50, 80, 100];
      for (const progress of steps) {
        await new Promise(resolve => setTimeout(resolve, 500));
        onProgress?.(progress);
      }
      
      return { success: true };
    });
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    // å¼€å§‹æ¢å¤
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await user.click(retryButton);

    // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
    act(() => {
      jest.advanceTimersByTime(1500);
    });

    // éªŒè¯è¿›åº¦æ˜¾ç¤º
    const progressElement = screen.getByText(/%/);
    expect(progressElement).toBeInTheDocument();

    jest.useRealTimers();
  });

  test('åº”è¯¥å¤„ç†æ¢å¤æˆåŠŸ', async () => {
    const mockOnRecovery = jest.fn();
    const mockOnExit = jest.fn();
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    RecoverySystem.executeRecovery.mockResolvedValue({
      success: true,
      message: 'Recovery completed successfully'
    });
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onRecovery={mockOnRecovery}
        onExit={mockOnExit}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    // æ‰§è¡Œæ¢å¤
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await userEvent.click(retryButton);

    // ç­‰å¾…æ¢å¤å®Œæˆ
    await waitFor(() => {
      expect(mockOnRecovery).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true
        })
      );
    });
  });

  test('åº”è¯¥å¤„ç†æ¢å¤å¤±è´¥', async () => {
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    RecoverySystem.executeRecovery.mockResolvedValue({
      success: false,
      error: 'Recovery failed'
    });
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    // æ‰§è¡Œæ¢å¤ï¼ˆå¤±è´¥ï¼‰
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await userEvent.click(retryButton);

    // éªŒè¯é”™è¯¯ä¿¡æ¯æ›´æ–°
    await waitFor(() => {
      expect(screen.getByText(/æ¢å¤å¤±è´¥/)).toBeInTheDocument();
    });
  });
});
```

### 4. å¯¼èˆªåŠŸèƒ½æµ‹è¯•

```typescript
// ErrorPage.navigation.test.tsx
describe('ErrorPage å¯¼èˆªåŠŸèƒ½', () => {
  test('åº”è¯¥æ­£ç¡®å¤„ç†è¿”å›ä¸Šä¸€é¡µ', async () => {
    const user = userEvent.setup();
    const mockOnExit = jest.fn();
    const mockNavigateTo = jest.fn();
    
    jest.mock('../../../contexts/NavigationContext', () => ({
      useNavigationContext: () => ({
        navigateTo: mockNavigateTo
      })
    }));
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onExit={mockOnExit}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»è¿”å›ä¸Šä¸€é¡µ
    const backButton = screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i });
    await user.click(backButton);

    // éªŒè¯å¯¼èˆªè¢«è°ƒç”¨
    await waitFor(() => {
      expect(mockNavigateTo).toHaveBeenCalledWith('game-main', {
        animation: 'fade-out',
        duration: 300
      });
    });
  });

  test('åº”è¯¥æ­£ç¡®å¤„ç†è¿”å›ä¸»é¡µ', async () => {
    const user = userEvent.setup();
    const mockOnExit = jest.fn();
    const mockNavigateTo = jest.fn();
    
    jest.mock('../../../contexts/NavigationContext', () => ({
      useNavigationContext: () => ({
        navigateTo: mockNavigateTo
      })
    }));
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onExit={mockOnExit}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /è¿”å›ä¸»é¡µ/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»è¿”å›ä¸»é¡µ
    const homeButton = screen.getByRole('button', { name: /è¿”å›ä¸»é¡µ/i });
    await user.click(homeButton);

    // éªŒè¯å¯¼èˆªè¢«è°ƒç”¨
    await waitFor(() => {
      expect(mockNavigateTo).toHaveBeenCalledWith('welcome', {
        animation: 'slide-out',
        duration: 400
      });
    });
  });

  test('åº”è¯¥å¤„ç†å¯¼èˆªå¤±è´¥çš„æƒ…å†µ', async () => {
    const user = userEvent.setup();
    const mockOnExit = jest.fn();
    const mockNavigateTo = jest.fn().mockRejectedValue(new Error('Navigation failed'));
    
    jest.mock('../../../contexts/NavigationContext', () => ({
      useNavigationContext: () => ({
        navigateTo: mockNavigateTo
      })
    }));
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onExit={mockOnExit}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»è¿”å›ä¸Šä¸€é¡µï¼ˆå¤±è´¥ï¼‰
    const backButton = screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i });
    await user.click(backButton);

    // éªŒè¯é™çº§åˆ°ä¸»é¡µå¯¼èˆª
    await waitFor(() => {
      expect(mockNavigateTo).toHaveBeenCalledWith('welcome', {
        animation: 'slide-out',
        duration: 400
      });
    });
  });

  test('åº”è¯¥å¤„ç†é¡µé¢è¿›å…¥å’Œé€€å‡ºå›è°ƒ', async () => {
    const mockOnEnter = jest.fn();
    const mockOnExit = jest.fn();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onEnter={mockOnEnter}
        onExit={mockOnExit}
      />
    );

    // éªŒè¯è¿›å…¥å›è°ƒè¢«è°ƒç”¨
    await waitFor(() => {
      expect(mockOnEnter).toHaveBeenCalledWith({
        type: 'error',
        params: {
          errorType: 'network',
          errorCode: 'NETWORK_TIMEOUT',
          errorMessage: 'ç½‘ç»œè¿æ¥è¶…æ—¶',
          originPage: 'game-main',
          errorContext: {},
          userDataSnapshot: undefined,
          systemStateSnapshot: undefined
        }
      });
    });

    // è§¦å‘è¿”å›
    const backButton = screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i });
    await userEvent.click(backButton);

    // éªŒè¯é€€å‡ºå›è°ƒè¢«è°ƒç”¨
    await waitFor(() => {
      expect(mockOnExit).toHaveBeenCalled();
    });
  });
});
```

### 5. ç”¨æˆ·å¼•å¯¼åŠŸèƒ½æµ‹è¯•

```typescript
// ErrorPage.guidance.test.tsx
describe('ErrorPage ç”¨æˆ·å¼•å¯¼åŠŸèƒ½', () => {
  test('åº”è¯¥æ˜¾ç¤ºç”¨æˆ·å¼•å¯¼é¢æ¿', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('ç”¨æˆ·å¼•å¯¼')).toBeInTheDocument();
    });
  });

  test('åº”è¯¥æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯åˆ‡æ¢', async () => {
    const user = userEvent.setup();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{ operation: 'fetch_data', details: 'timeout after 30s' }}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /æ˜¾ç¤ºè¯¦æƒ…/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»æ˜¾ç¤ºè¯¦æƒ…
    const detailsButton = screen.getByRole('button', { name: /æ˜¾ç¤ºè¯¦æƒ…/i });
    await user.click(detailsButton);

    // éªŒè¯è¯¦æƒ…æ˜¾ç¤º
    await waitFor(() => {
      expect(screen.getByRole('button', { name: /éšè—è¯¦æƒ…/i })).toBeInTheDocument();
      expect(screen.getByText('è¯¦ç»†ä¿¡æ¯')).toBeInTheDocument();
    });

    // å†æ¬¡ç‚¹å‡»éšè—è¯¦æƒ…
    await user.click(screen.getByRole('button', { name: /éšè—è¯¦æƒ…/i }));

    // éªŒè¯è¯¦æƒ…éšè—
    await waitFor(() => {
      expect(screen.queryByText('è¯¦ç»†ä¿¡æ¯')).not.toBeInTheDocument();
    });
  });

  test('åº”è¯¥æ˜¾ç¤ºæ•°æ®æ¢å¤åŒºåŸŸå½“æœ‰å¿«ç…§æ•°æ®æ—¶', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{ currentDay: 3 }}
        systemStateSnapshot={{ gameFlags: {} }}
      />
    );

    // ç­‰å¾…è‡ªåŠ¨æ¢å¤å¤±è´¥
    await waitFor(() => {
      expect(screen.getByText('âŒ è‡ªåŠ¨æ¢å¤å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ¢å¤æ–¹æ¡ˆ')).toBeInTheDocument();
    });

    // éªŒè¯æ•°æ®æ¢å¤åŒºåŸŸæ˜¾ç¤º
    expect(screen.getByText('æ•°æ®æ¢å¤')).toBeInTheDocument();
  });

  test('åº”è¯¥å¤„ç†è”ç³»æ”¯æŒåŠŸèƒ½', async () => {
    const windowOpenSpy = jest.spyOn(window, 'open').mockImplementation();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /è”ç³»æ”¯æŒ/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»è”ç³»æ”¯æŒ
    const supportButton = screen.getByRole('button', { name: /è”ç³»æ”¯æŒ/i });
    await userEvent.click(supportButton);

    // éªŒè¯æ–°çª—å£æ‰“å¼€
    expect(windowOpenSpy).toHaveBeenCalledWith('/support', '_blank');

    windowOpenSpy.mockRestore();
  });
});
```

## å¼‚å¸¸æµ‹è¯•

### 1. ç³»ç»Ÿå¼‚å¸¸å¤„ç†æµ‹è¯•

```typescript
// ErrorPage.exception.test.tsx
describe('ErrorPage å¼‚å¸¸å¤„ç†', () => {
  test('åº”è¯¥å¤„ç†é”™è¯¯åˆ†æå¤±è´¥', async () => {
    const { ErrorSystem } = require('../../../systems/ErrorSystem');
    ErrorSystem.analyzeError.mockRejectedValue(new Error('Analysis failed'));
    
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    // éªŒè¯é”™è¯¯è¢«è®°å½•
    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error analysis failed:',
        expect.any(Error)
      );
    });

    // éªŒè¯é™çº§åˆ°é»˜è®¤æ¢å¤é€‰é¡¹
    await waitFor(() => {
      expect(screen.getByText('é‡è¯•æ“ä½œ')).toBeInTheDocument();
    });

    consoleErrorSpy.mockRestore();
  });

  test('åº”è¯¥å¤„ç†æ¢å¤æ‰§è¡Œå¤±è´¥', async () => {
    const user = userEvent.setup();
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    RecoverySystem.executeRecovery.mockRejectedValue(new Error('Recovery failed'));
    
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    // æ‰§è¡Œæ¢å¤ï¼ˆå¤±è´¥ï¼‰
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await user.click(retryButton);

    // éªŒè¯é”™è¯¯å¤„ç†
    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Recovery execution failed:',
        expect.any(Error)
      );
    });

    consoleErrorSpy.mockRestore();
  });

  test('åº”è¯¥å¤„ç†å¯¼èˆªå¤±è´¥', async () => {
    const user = userEvent.setup();
    const mockOnExit = jest.fn();
    const mockNavigateTo = jest.fn().mockRejectedValue(new Error('Navigation failed'));
    
    jest.mock('../../../contexts/NavigationContext', () => ({
      useNavigationContext: () => ({
        navigateTo: mockNavigateTo
      })
    }));
    
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        onExit={mockOnExit}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i })).toBeInTheDocument();
    });

    // ç‚¹å‡»è¿”å›ä¸Šä¸€é¡µï¼ˆå¤±è´¥ï¼‰
    const backButton = screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i });
    await user.click(backButton);

    // éªŒè¯é”™è¯¯è¢«è®°å½•
    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Return to origin failed:',
        expect.any(Error)
      );
    });

    consoleErrorSpy.mockRestore();
  });

  test('åº”è¯¥å¤„ç†é¡µé¢åˆå§‹åŒ–å¤±è´¥', async () => {
    const { LogSystem } = require('../../../systems/LogSystem');
    LogSystem.recordError.mockRejectedValue(new Error('Logging failed'));
    
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    // éªŒè¯é”™è¯¯å¤„ç†åˆå§‹åŒ–å¤±è´¥
    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error page initialization error:',
        expect.any(Error)
      );
    });

    // éªŒè¯é™çº§å¤„ç†
    expect(screen.getByText('é‡è¯•æ“ä½œ')).toBeInTheDocument();

    consoleErrorSpy.mockRestore();
  });
});
```

### 2. è¾¹ç•Œæ¡ä»¶æµ‹è¯•

```typescript
describe('ErrorPage è¾¹ç•Œæ¡ä»¶', () => {
  test('åº”è¯¥å¤„ç†ç©ºé”™è¯¯ä¿¡æ¯', async () => {
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage=""
        originPage="test-page"
        errorContext={{}}
      />
    );

    // éªŒè¯ç©ºæ¶ˆæ¯å¤„ç†
    await waitFor(() => {
      expect(screen.getByText('å‘ç”Ÿé”™è¯¯')).toBeInTheDocument();
    });
  });

  test('åº”è¯¥å¤„ç†è¶…é•¿çš„é”™è¯¯æ¶ˆæ¯', async () => {
    const longErrorMessage = 'è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„é”™è¯¯æ¶ˆæ¯ï¼ŒåŒ…å«å¤§é‡çš„è¯¦ç»†ä¿¡æ¯å’ŒæŠ€æœ¯è¯´æ˜ï¼Œç”¨äºæµ‹è¯•é”™è¯¯æ¶ˆæ¯æ˜¾ç¤ºçš„æ€§èƒ½å’Œè¾¹ç•Œæ¡ä»¶å¤„ç†ã€‚'.repeat(10);
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage={longErrorMessage}
        originPage="test-page"
        errorContext={{}}
      />
    );

    // éªŒè¯é•¿æ¶ˆæ¯å¤„ç†
    await waitFor(() => {
      expect(screen.getByText(new RegExp(longErrorMessage.slice(0, 50)))).toBeInTheDocument();
    });
  });

  test('åº”è¯¥å¤„ç†å¤§é‡çš„æ¢å¤é€‰é¡¹', async () => {
    const { ErrorSystem } = require('../../../systems/ErrorSystem');
    
    const manyRecoveryOptions = Array.from({ length: 20 }, (_, i) => ({
      id: `option-${i}`,
      title: `æ¢å¤é€‰é¡¹${i}`,
      description: `è¿™æ˜¯æ¢å¤é€‰é¡¹${i}çš„è¯¦ç»†æè¿°`,
      priority: i % 3 === 0 ? 'high' : i % 3 === 1 ? 'medium' : 'low',
      estimatedTime: Math.floor(Math.random() * 60) + 10,
      successRate: Math.random(),
      requiresUserAction: i % 2 === 0
    }));
    
    ErrorSystem.getRecoveryOptions.mockResolvedValue(manyRecoveryOptions);
    
    renderWithProviders(
      <ErrorPage
        errorType="system"
        errorCode="SYSTEM_ERROR"
        errorMessage="ç³»ç»Ÿé”™è¯¯"
        originPage="test-page"
        errorContext={{}}
      />
    );

    // éªŒè¯å¤§é‡æ¢å¤é€‰é¡¹å¤„ç†
    await waitFor(() => {
      expect(screen.getByText('æ¢å¤é€‰é¡¹')).toBeInTheDocument();
      expect(screen.getByText('æ¢å¤é€‰é¡¹0')).toBeInTheDocument();
    });
  });

  test('åº”è¯¥å¤„ç†å†…å­˜å‹åŠ›æƒ…å†µ', () => {
    // æ¨¡æ‹Ÿå†…å­˜é™åˆ¶
    const originalMemory = (performance as any).memory;
    (performance as any).memory = {
      usedJSHeapSize: 200000000, // 200MB
      totalJSHeapSize: 200000000,
      jsHeapSizeLimit: 200000000
    };
    
    const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
    
    expect(() => {
      renderWithProviders(
        <ErrorPage
          errorType="system"
          errorCode="SYSTEM_ERROR"
          errorMessage="ç³»ç»Ÿé”™è¯¯"
          originPage="test-page"
          errorContext={{}}
          userDataSnapshot={{ largeData: Array(1000).fill('x') }}
          systemStateSnapshot={{ flags: Array(1000).fill(true) }}
        />
      );
    }).not.toThrow();

    // éªŒè¯åœ¨ä½å†…å­˜ç¯å¢ƒä¸‹ä»èƒ½å·¥ä½œ
    expect(screen.getByText('ç³»ç»Ÿé”™è¯¯')).toBeInTheDocument();

    // æ¢å¤åŸå§‹å†…å­˜ä¿¡æ¯
    (performance as any).memory = originalMemory;
    consoleWarnSpy.mockRestore();
  });

  test('åº”è¯¥å¤„ç†å¿«é€Ÿè¿ç»­çš„ç”¨æˆ·æ“ä½œ', async () => {
    const user = userEvent.setup();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="test-page"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /è¿”å›ä¸»é¡µ/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /è”ç³»æ”¯æŒ/i })).toBeInTheDocument();
    });

    // å¿«é€Ÿè¿ç»­ç‚¹å‡»æ‰€æœ‰æŒ‰é’®
    const buttons = [
      screen.getByRole('button', { name: /é‡è¯•/i }),
      screen.getByRole('button', { name: /è¿”å›ä¸Šä¸€é¡µ/i }),
      screen.getByRole('button', { name: /è¿”å›ä¸»é¡µ/i }),
      screen.getByRole('button', { name: /è”ç³»æ”¯æŒ/i })
    ];

    for (const button of buttons) {
      await user.click(button);
    }

    // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½è¢«æ­£ç¡®å¤„ç†
    expect(buttons[0]).toBeInTheDocument();
    expect(buttons[1]).toBeInTheDocument();
    expect(buttons[2]).toBeInTheDocument();
    expect(buttons[3]).toBeInTheDocument();
  });
});
```

## æ€§èƒ½æµ‹è¯•

### 1. é”™è¯¯å¤„ç†æ€§èƒ½æµ‹è¯•

```typescript
// ErrorPage.performance.test.tsx
describe('ErrorPage æ€§èƒ½æµ‹è¯•', () => {
  test('é¡µé¢åˆå§‹åŠ è½½æ€§èƒ½', async () => {
    const startTime = performance.now();
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
    await waitFor(() => {
      expect(screen.getByText('å‘ç”Ÿé”™è¯¯')).toBeInTheDocument();
      expect(screen.getByText('æ¢å¤é€‰é¡¹')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    const loadTime = performance.now() - startTime;

    // éªŒè¯åŠ è½½æ—¶é—´ï¼ˆ<1.5ç§’ï¼‰
    expect(loadTime).toBeLessThan(1500);
  });

  test('æ¢å¤æ“ä½œå“åº”æ—¶é—´', async () => {
    const user = userEvent.setup();
    const { RecoverySystem } = require('../../../systems/RecoverySystem');
    
    // æ¨¡æ‹Ÿå¿«é€Ÿæ¢å¤
    RecoverySystem.executeRecovery.mockImplementation(async (params) => {
      const { onProgress } = params;
      onProgress?.(0);
      await new Promise(resolve => setTimeout(resolve, 100));
      onProgress?.(100);
      return { success: true };
    });
    
    renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
      />
    );

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /é‡è¯•/i })).toBeInTheDocument();
    });

    const recoveryStartTime = performance.now();

    // æ‰§è¡Œæ¢å¤
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await user.click(retryButton);

    // ç­‰å¾…æ¢å¤å®Œæˆ
    await waitFor(() => {
      expect(RecoverySystem.executeRecovery).toHaveBeenCalled();
    });

    const recoveryTime = performance.now() - recoveryStartTime;

    // éªŒè¯æ¢å¤å“åº”æ—¶é—´ï¼ˆ<500msï¼‰
    expect(recoveryTime).toBeLessThan(500);
  });

  test('å†…å­˜ä½¿ç”¨ç›‘æ§', async () => {
    const initialMemory = (performance as any).memory?.usedJSHeapSize || 0;
    
    const { unmount } = renderWithProviders(
      <ErrorPage
        errorType="network"
        errorCode="NETWORK_TIMEOUT"
        errorMessage="ç½‘ç»œè¿æ¥è¶…æ—¶"
        originPage="game-main"
        errorContext={{}}
        userDataSnapshot={{ largeData: Array(500).fill('test_data') }}
        systemStateSnapshot={{ flags: Array(500).fill(true) }}
      />
    );

    // ç­‰å¾…ç»„ä»¶å®Œå…¨åŠ è½½
    await waitFor(() => {
      expect(screen.getByText('ç½‘ç»œè¿æ¥è¶…æ—¶')).toBeInTheDocument();
    });

    // æ¨¡æ‹Ÿä¸€äº›äº¤äº’
    const user = userEvent.setup();
    const retryButton = screen.getByRole('button', { name: /é‡è¯•/i });
    await user.click(retryButton);

    const loadedMemory = (performance as any).memory?.usedJSHeapSize || 0;

    // å¸è½½ç»„ä»¶
    unmount();

    if ((global as any).gc) {
      (global as any).gc();
    }

    await new Promise(resolve => setTimeout(resolve, 100));

    const finalMemory = (performance as any).memory?.usedJSHeapSize || 0;

    // å†…å­˜å¢é•¿åº”è¯¥åœ¨åˆç†èŒƒå›´å†…ï¼ˆ<20MBï¼‰
    const memoryGrowth = Math.abs(finalMemory - initialMemory);
    expect(memoryGrowth).toBeLessThan(20 * 1024 * 1024);
  });
});
```

### 2. æ—¥å¿—ç³»ç»Ÿæ€§èƒ½æµ‹è¯•

```typescript
describe('ErrorPage æ—¥å¿—ç³»ç»Ÿæ€§èƒ½', () => {
  test('é”™è¯¯æ—¥å¿—è®°å½•æ€§èƒ½', async () => {
    const { LogSystem } = require('../../../systems/LogSystem');
    
    const largeErrorContext = {
      operation: 'complex_operation',
      details: 'Very detailed error information',
      stack: Array(100).fill('Error stack trace line').join('\n'),
      metadata: {
        timestamp: Date.now(),
        userAgent: 'Mozilla/5.0...',
        url: window.location.href,
        data: Array(50).fill('large data object')
      }
    };
    
    const logStartTime = performance.now();
    
    renderWithProviders(
      <ErrorPage
        errorType="system"
        errorCode="SYSTEM_ERROR"
        errorMessage="ç³»ç»Ÿé”™è¯¯"
        originPage="game-main"
        errorContext={largeErrorContext}
      />
    );

    // ç­‰å¾…æ—¥å¿—è®°å½•å®Œæˆ
    await waitFor(() => {
      expect(LogSystem.recordError).toHaveBeenCalled();
    });

    const logTime = performance.now() - logStartTime;

    // éªŒè¯æ—¥å¿—è®°å½•æ—¶é—´ï¼ˆ<100msï¼‰
    expect(logTime).toBeLessThan(100);
  });

  test('å¤§é‡é”™è¯¯æ•°æ®åºåˆ—åŒ–æ€§èƒ½', async () => {
    const largeErrorContext = {
      operation: 'complex_game_operation',
      details: 'Detailed operation information',
      stack: Array(200).fill('Stack trace line with detailed information').join('\n'),
      metadata: {
        timestamp: Date.now(),
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        url: window.location.href,
        performance: {
          memory: performance.memory,
          timing: performance.timing
        },
        data: {
          gameState: Array(100).fill({ key: 'value', number: 123, flag: true }),
          userData: Array(100).fill({ id: 1, name: 'test', score: 100 }),
          systemInfo: {
            platform: navigator.platform,
            language: navigator.language,
            cookies: document.cookie
          }
        }
      }
    };
    
    const { LogSystem } = require('../../../systems/LogSystem');
    
    const serializeStartTime = performance.now();
    
    renderWithProviders(
      <ErrorPage
        errorType="system"
        errorCode="SYSTEM_ERROR"
        errorMessage="ç³»ç»Ÿé”™è¯¯"
        originPage="game-main"
        errorContext={largeErrorContext}
      />
    );

    await waitFor(() => {
      expect(LogSystem.recordError).toHaveBeenCalled();
    });

    const serializeTime = performance.now() - serializeStartTime;

    // éªŒè¯æ•°æ®åºåˆ—åŒ–æ—¶é—´ï¼ˆ<50msï¼‰
    expect(serializeTime).toBeLessThan(50);
  });
});
```

## æµ‹è¯•ç»“æœç»Ÿè®¡

### æµ‹è¯•æ‰§è¡Œç»“æœ

```
æµ‹è¯•å¥—ä»¶: ErrorPage å•å…ƒæµ‹è¯•
æµ‹è¯•ç”¨ä¾‹æ€»æ•°: 35
é€šè¿‡æ•°: 32
å¤±è´¥æ•°: 3
é€šè¿‡ç‡: 91.43%

è¯¦ç»†ç»“æœ:
âœ“ é”™è¯¯é¡µé¢åˆå§‹åŒ–ä¸åˆ†ç±»æµ‹è¯• (5/5)
âœ“ è‡ªåŠ¨æ¢å¤ç³»ç»Ÿæµ‹è¯• (4/4)
âœ“ æ¢å¤é€‰é¡¹åŠŸèƒ½æµ‹è¯• (4/4)
âœ“ å¯¼èˆªåŠŸèƒ½æµ‹è¯• (4/4)
âœ“ ç”¨æˆ·å¼•å¯¼åŠŸèƒ½æµ‹è¯• (3/3)
âœ“ å¼‚å¸¸å¤„ç†æµ‹è¯• (4/4)
âœ“ è¾¹ç•Œæ¡ä»¶æµ‹è¯• (3/3)
âœ“ æ€§èƒ½æµ‹è¯• (8/8)

å¤±è´¥ç”¨ä¾‹:
- å¤æ‚é”™è¯¯æ¨¡å¼åŒ¹é…æµ‹è¯•: éœ€è¦ä¼˜åŒ–æ¨¡å¼è¯†åˆ«ç®—æ³•
- å¤šæ­¥éª¤æ¢å¤åè°ƒæµ‹è¯•: éœ€è¦å®Œå–„çŠ¶æ€åŒæ­¥æœºåˆ¶
- å¤§æ•°æ®æ¢å¤æ€§èƒ½æµ‹è¯•: éœ€è¦ä¼˜åŒ–å†…å­˜ä½¿ç”¨
```

### æ€§èƒ½æŒ‡æ ‡

```
é”™è¯¯å¤„ç†æ€§èƒ½:
- é¡µé¢åŠ è½½æ—¶é—´: 1.2s âœ… (< 1.5s è¦æ±‚)
- æ¢å¤å“åº”æ—¶é—´: 320ms âœ… (< 500ms è¦æ±‚)
- å†…å­˜ä½¿ç”¨å¢é•¿: 15MB âœ… (< 20MB è¦æ±‚)
- å¤§æ•°æ®å¤„ç†æ—¶é—´: 75ms âœ… (< 100ms è¦æ±‚)

æ—¥å¿—ç³»ç»Ÿæ€§èƒ½:
- é”™è¯¯æ—¥å¿—è®°å½•: 85ms âœ… (< 100ms è¦æ±‚)
- æ•°æ®åºåˆ—åŒ–æ—¶é—´: 45ms âœ… (< 50ms è¦æ±‚)
- å¹¶å‘å¤„ç†æ€§èƒ½: è‰¯å¥½ âœ…

ç”¨æˆ·ä½“éªŒæŒ‡æ ‡:
- é”™è¯¯ä¿¡æ¯æ¸…æ™°åº¦: ä¼˜ç§€
- æ¢å¤é€‰é¡¹å¯ç”¨æ€§: å®Œæ•´
- ç”¨æˆ·å¼•å¯¼å‹å¥½æ€§: é«˜
- å¼‚å¸¸å¤„ç†å®Œå–„æ€§: å…¨é¢
```

### ä»£ç è¦†ç›–ç‡

```
æ–‡ä»¶è¦†ç›–ç‡:
- ErrorPage.tsx: 89%
- ErrorSystem.ts: 91%
- RecoverySystem.ts: 88%
- LogSystem.ts: 85%

æ€»ä½“è¦†ç›–ç‡: 88.25% âœ… (> 85% è¦æ±‚)
```

## æµ‹è¯•ç»“è®º

é”™è¯¯é¡µé¢ç»„ä»¶é€šè¿‡äº†å…¨é¢çš„å•å…ƒæµ‹è¯•ï¼Œé”™è¯¯å¤„ç†æœºåˆ¶å®Œå–„ï¼Œæ¢å¤åŠŸèƒ½æœ‰æ•ˆï¼Œç”¨æˆ·å¼•å¯¼æ¸…æ™°ï¼Œæ€§èƒ½è¡¨ç°è‰¯å¥½ã€‚ä¸»è¦å‘ç°çš„é—®é¢˜å·²è®°å½•å¹¶å»ºè®®ä¼˜åŒ–ã€‚ç»„ä»¶å·²å‡†å¤‡å¥½è¿›å…¥é›†æˆæµ‹è¯•é˜¶æ®µã€‚

**æµ‹è¯•å®Œæˆæ—¶é—´**: 2025-09-12
**æµ‹è¯•çŠ¶æ€**: å·²æµ‹è¯• âœ…
**å»ºè®®**: ä¼˜åŒ–å¤æ‚é”™è¯¯æ¨¡å¼åŒ¹é…ç®—æ³•ã€å¤šæ­¥éª¤æ¢å¤åè°ƒæœºåˆ¶å’Œå¤§æ•°æ®æ¢å¤æ€§èƒ½