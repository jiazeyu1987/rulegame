# Epic11-子任务01: 清除记忆确认与打包部署

## 开发状态
子任务开发完成

## 开发方案

### 1. 开发目标
实现清除记忆功能的二次确认机制，完成应用程序exe封装打包，进行性能优化和兼容性测试。

### 2. 设计方案
- 二次确认弹窗组件设计
- Electron打包配置和优化
- 性能基准测试和优化
- Windows兼容性验证方案
- 多标签页限制机制
- 数据清除完整性验证

### 3. 实现方式

#### 核心类型定义
```typescript
// 清除记忆确认组件属性
export interface ClearMemoryModalProps {
  isOpen: boolean;
  onConfirm: () => void;
  onCancel: () => void;
  riskLevel: 'low' | 'medium' | 'high';
  dataSize?: string;
  lastClearTime?: number;
}

// 数据清除选项
export interface ClearOptions {
  clearProgress: boolean;      // 清除游戏进度
  clearSettings: boolean;      // 清除设置
  clearCache: boolean;         // 清除缓存
  clearLogs: boolean;          // 清除日志
  confirmText?: string;        // 自定义确认文本
}

// 清除结果
export interface ClearResult {
  success: boolean;
  clearedItems: string[];
  errors: string[];
  timestamp: number;
}

// Electron应用配置
export interface ElectronConfig {
  appId: string;
  productName: string;
  version: string;
  description: string;
  author: string;
  directories: {
    output: string;
    buildResources: string;
  };
  files: string[];
  extraResources: string[];
  win: {
    target: string;
    icon: string;
    requestedExecutionLevel: string;
  };
  nsis: {
    oneClick: boolean;
    allowToChangeInstallationDirectory: boolean;
    createDesktopShortcut: boolean;
    createStartMenuShortcut: boolean;
  };
}

// 性能指标
export interface PerformanceMetrics {
  startupTime: number;
  memoryUsage: number;
  diskUsage: number;
  bundleSize: number;
  launchTime: number;
}

// 兼容性测试结果
export interface CompatibilityResult {
  platform: string;
  version: string;
  passed: boolean;
  issues: string[];
  performance: PerformanceMetrics;
}
```

#### 清除记忆确认组件实现
```typescript
import React, { useState, useEffect } from 'react';
import './ClearMemoryModal.css';

const ClearMemoryModal: React.FC<ClearMemoryModalProps> = ({
  isOpen,
  onConfirm,
  onCancel,
  riskLevel,
  dataSize = '未知',
  lastClearTime
}) => {
  const [step, setStep] = useState(1);
  const [clearOptions, setClearOptions] = useState<ClearOptions>({
    clearProgress: true,
    clearSettings: false,
    clearCache: true,
    clearLogs: false
  });
  const [confirmText, setConfirmText] = useState('');
  const [requiredText, setRequiredText] = useState('');
  const [countdown, setCountdown] = useState(0);

  useEffect(() => {
    if (isOpen) {
      setStep(1);
      setCountdown(getCountdownTime());
      setRequiredText(getRequiredConfirmText());
      // 启动倒计时
      const timer = setInterval(() => {
        setCountdown(prev => {
          if (prev <= 1) {
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
      return () => clearInterval(timer);
    }
  }, [isOpen, riskLevel]);

  const getCountdownTime = (): number => {
    switch (riskLevel) {
      case 'high': return 10;
      case 'medium': return 5;
      case 'low': return 0;
      default: return 0;
    }
  };

  const getRequiredConfirmText = (): string => {
    switch (riskLevel) {
      case 'high': return '永久删除';
      case 'medium': return '确认删除';
      case 'low': return '删除';
      default: return '删除';
    }
  };

  const getRiskLevelConfig = () => {
    switch (riskLevel) {
      case 'high':
        return {
          title: '⚠️ 高风险操作',
          description: '此操作将永久删除所有游戏数据，包括进度、设置、缓存等。此操作不可撤销。',
          confirmButtonText: '我理解风险，确认删除',
          confirmButtonClass: 'danger-high',
          icon: '🔥'
        };
      case 'medium':
        return {
          title: '⚡ 中等风险操作',
          description: '此操作将删除选中的数据项目。部分数据可以恢复。',
          confirmButtonText: '确认删除选中数据',
          confirmButtonClass: 'danger-medium',
          icon: '⚡'
        };
      case 'low':
        return {
          title: '🗑️ 清理操作',
          description: '此操作将清理临时数据和缓存，不会影响游戏进度。',
          confirmButtonText: '清理数据',
          confirmButtonClass: 'danger-low',
          icon: '🗑️'
        };
      default:
        return {
          title: '数据清除',
          description: '清除选中的数据项目。',
          confirmButtonText: '确认清除',
          confirmButtonClass: 'danger-low',
          icon: '🗑️'
        };
    }
  };

  const handleOptionChange = (option: keyof ClearOptions) => {
    setClearOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleNextStep = () => {
    if (step === 1) {
      setStep(2);
    }
  };

  const handleConfirm = () => {
    if (confirmText !== requiredText) {
      alert(`请输入"${requiredText}"以确认操作`);
      return;
    }
    
    if (countdown > 0) {
      alert(`请等待${countdown}秒后再确认`);
      return;
    }
    
    onConfirm();
  };

  const formatLastClearTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleString('zh-CN');
  };

  const config = getRiskLevelConfig();

  if (!isOpen) return null;

  return (
    <div className="clear-memory-modal-overlay">
      <div className="clear-memory-modal">
        <div className="modal-header">
          <span className="risk-icon">{config.icon}</span>
          <h2>{config.title}</h2>
          <button className="close-button" onClick={onCancel}>×</button>
        </div>

        <div className="modal-content">
          {step === 1 && (
            <div className="step-1">
              <div className="risk-description">
                <p>{config.description}</p>
                
                <div className="data-info">
                  <h4>待清除数据信息：</h4>
                  <ul>
                    <li>📊 数据大小: {dataSize}</li>
                    {lastClearTime && (
                      <li>🕐 上次清除: {formatLastClearTime(lastClearTime)}</li>
                    )}
                  </ul>
                </div>

                <div className="clear-options">
                  <h4>选择要清除的数据：</h4>
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearProgress}
                      onChange={() => handleOptionChange('clearProgress')}
                      disabled={riskLevel === 'high'} // 高风险时强制清除所有
                    />
                    <span className="option-label">
                      游戏进度 (⚠️ 不可恢复)
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearSettings}
                      onChange={() => handleOptionChange('clearSettings')}
                    />
                    <span className="option-label">
                      游戏设置
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearCache}
                      onChange={() => handleOptionChange('clearCache')}
                    />
                    <span className="option-label">
                      缓存数据
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearLogs}
                      onChange={() => handleOptionChange('clearLogs')}
                    />
                    <span className="option-label">
                      日志文件
                    </span>
                  </label>
                </div>

                {riskLevel === 'high' && (
                  <div className="warning-box">
                    <h4>⚠️ 重要警告</h4>
                    <ul>
                      <li>此操作不可撤销</li>
                      <li>所有游戏进度将永久丢失</li>
                      <li>请确保已备份重要数据</li>
                      <li>建议在清除前导出游戏存档</li>
                    </ul>
                  </div>
                )}
              </div>

              <div className="step-actions">
                <button className="cancel-button" onClick={onCancel}>
                  取消
                </button>
                <button 
                  className="next-button" 
                  onClick={handleNextStep}
                  disabled={!clearOptions.clearProgress && !clearOptions.clearSettings && 
                           !clearOptions.clearCache && !clearOptions.clearLogs}
                >
                  下一步
                </button>
              </div>
            </div>
          )}

          {step === 2 && (
            <div className="step-2">
              <div className="final-confirmation">
                <h3>最终确认</h3>
                <p>请输入 <strong>"{requiredText}"</strong> 以确认操作：</p>
                
                <input
                  type="text"
                  value={confirmText}
                  onChange={(e) => setConfirmText(e.target.value)}
                  placeholder={requiredText}
                  className="confirm-input"
                />

                {countdown > 0 && (
                  <div className="countdown-timer">
                    ⏱️ 请等待 {countdown} 秒
                  </div>
                )}

                <div className="selected-options">
                  <h4>确认清除以下数据：</h4>
                  <ul>
                    {clearOptions.clearProgress && <li>✓ 游戏进度</li>}
                    {clearOptions.clearSettings && <li>✓ 游戏设置</li>}
                    {clearOptions.clearCache && <li>✓ 缓存数据</li>}
                    {clearOptions.clearLogs && <li>✓ 日志文件</li>}
                  </ul>
                </div>
              </div>

              <div className="step-actions">
                <button className="back-button" onClick={() => setStep(1)}>
                  上一步
                </button>
                <button className="cancel-button" onClick={onCancel}>
                  取消
                </button>
                <button 
                  className={`confirm-button ${config.confirmButtonClass}`}
                  onClick={handleConfirm}
                  disabled={confirmText !== requiredText || countdown > 0}
                >
                  {countdown > 0 ? `等待中... (${countdown}s)` : config.confirmButtonText}
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ClearMemoryModal;
```

#### CSS样式实现
```css
/* ClearMemoryModal.css */
.clear-memory-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.3s ease;
}

.clear-memory-modal {
  background: linear-gradient(135deg, #ffffff, #f8f9fa);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  animation: slideUp 0.3s ease;
}

.modal-header {
  padding: 24px;
  border-bottom: 1px solid #e9ecef;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.risk-icon {
  font-size: 2em;
  margin-right: 12px;
}

.modal-header h2 {
  margin: 0;
  flex: 1;
  font-size: 1.5em;
  font-weight: 600;
}

.close-button {
  background: none;
  border: none;
  font-size: 1.5em;
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.close-button:hover {
  background-color: #f0f0f0;
}

.modal-content {
  padding: 24px;
}

.risk-description {
  margin-bottom: 24px;
}

.risk-description p {
  font-size: 1.1em;
  line-height: 1.6;
  color: #495057;
}

.data-info {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 8px;
  margin: 16px 0;
}

.data-info h4 {
  margin: 0 0 8px 0;
  color: #343a40;
}

.data-info ul {
  margin: 0;
  padding-left: 20px;
}

.data-info li {
  margin: 4px 0;
  color: #6c757d;
}

.clear-options {
  margin: 20px 0;
}

.clear-options h4 {
  margin: 0 0 12px 0;
  color: #343a40;
}

.option-item {
  display: flex;
  align-items: center;
  margin: 12px 0;
  cursor: pointer;
  padding: 8px;
  border-radius: 6px;
  transition: background-color 0.2s;
}

.option-item:hover {
  background-color: #f8f9fa;
}

.option-item input[type="checkbox"] {
  margin-right: 12px;
  transform: scale(1.2);
}

.option-label {
  font-weight: 500;
  color: #495057;
}

.warning-box {
  background: linear-gradient(135deg, #fff3cd, #ffeaa7);
  border: 1px solid #ffeaa7;
  border-radius: 8px;
  padding: 16px;
  margin: 20px 0;
}

.warning-box h4 {
  margin: 0 0 8px 0;
  color: #856404;
}

.warning-box ul {
  margin: 0;
  padding-left: 20px;
}

.warning-box li {
  color: #856404;
  margin: 4px 0;
}

.step-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 20px;
  border-top: 1px solid #e9ecef;
}

.step-actions button {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 1em;
}

.cancel-button {
  background-color: #6c757d;
  color: white;
}

.cancel-button:hover {
  background-color: #5a6268;
}

.next-button, .confirm-button {
  background-color: #007bff;
  color: white;
}

.next-button:hover:not(:disabled), .confirm-button:hover:not(:disabled) {
  background-color: #0056b3;
}

.back-button {
  background-color: #6c757d;
  color: white;
}

.back-button:hover {
  background-color: #5a6268;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.danger-high {
  background: linear-gradient(135deg, #dc3545, #c82333);
}

.danger-high:hover:not(:disabled) {
  background: linear-gradient(135deg, #c82333, #a71d2a);
}

.danger-medium {
  background: linear-gradient(135deg, #fd7e14, #e55100);
}

.danger-medium:hover:not(:disabled) {
  background: linear-gradient(135deg, #e55100, #cc4400);
}

.danger-low {
  background: linear-gradient(135deg, #28a745, #218838);
}

.danger-low:hover:not(:disabled) {
  background: linear-gradient(135deg, #218838, #1e7e34);
}

.final-confirmation {
  text-align: center;
}

.final-confirmation h3 {
  margin: 0 0 16px 0;
  color: #343a40;
}

.final-confirmation p {
  margin: 0 0 20px 0;
  color: #6c757d;
}

.confirm-input {
  width: 100%;
  padding: 12px;
  border: 2px solid #dee2e6;
  border-radius: 8px;
  font-size: 1.1em;
  text-align: center;
  margin: 16px 0;
  transition: border-color 0.2s;
}

.confirm-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.countdown-timer {
  font-size: 1.2em;
  font-weight: 600;
  color: #dc3545;
  margin: 16px 0;
  animation: pulse 1s infinite;
}

.selected-options {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: left;
}

.selected-options h4 {
  margin: 0 0 12px 0;
  color: #343a40;
}

.selected-options ul {
  margin: 0;
  padding-left: 20px;
}

.selected-options li {
  color: #28a745;
  font-weight: 500;
  margin: 4px 0;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

/* 响应式设计 */
@media (max-width: 768px) {
  .clear-memory-modal {
    margin: 20px;
    width: calc(100% - 40px);
  }
  
  .modal-content {
    padding: 16px;
  }
  
  .step-actions {
    flex-direction: column;
  }
  
  .step-actions button {
    width: 100%;
  }
}

/* 高对比度模式支持 */
@media (prefers-contrast: high) {
  .clear-memory-modal {
    border: 2px solid #000;
  }
  
  .warning-box {
    border: 2px solid #856404;
  }
  
  .confirm-input {
    border-width: 3px;
  }
}

/* 减少动画模式支持 */
@media (prefers-reduced-motion: reduce) {
  .clear-memory-modal-overlay,
  .clear-memory-modal {
    animation: none;
  }
  
  .countdown-timer {
    animation: none;
  }
}
```

#### Electron打包配置
```typescript
// electron.config.ts
import type { ElectronConfig } from '../types/deployment';

export const electronConfig: ElectronConfig = {
  appId: 'com.ruleskill.game',
  productName: '规则怪谈游戏',
  version: '1.0.0',
  description: '基于React的寝室规则怪谈文字冒险游戏',
  author: '规则怪谈工作室',
  directories: {
    output: 'dist-electron',
    buildResources: 'build-resources'
  },
  files: [
    'build/**/*',
    'node_modules/**/*',
    'package.json',
    '!**/*.map',
    '!**/test/**',
    '!**/*.test.*',
    '!**/__tests__/**'
  ],
  extraResources: [
    {
      from: 'assets',
      to: 'assets',
      filter: ['**/*']
    },
    {
      from: 'docs',
      to: 'docs',
      filter: ['*.md']
    }
  ],
  win: {
    target: 'nsis',
    icon: 'assets/icon.ico',
    requestedExecutionLevel: 'asInvoker'
  },
  nsis: {
    oneClick: false,
    allowToChangeInstallationDirectory: true,
    createDesktopShortcut: true,
    createStartMenuShortcut: true,
    shortcutName: '规则怪谈游戏'
  }
};

// electron-builder配置
export const builderConfig = {
  ...electronConfig,
  publish: {
    provider: 'github',
    owner: 'ruleskill',
    repo: 'rules-kill-game'
  },
  compression: 'maximum',
  removePackageScripts: true,
  buildDependenciesFromSource: false,
  nodeGypRebuild: false,
  npmRebuild: false
};
```

#### 多标签页限制机制
```typescript
// tabManager.ts
export class TabManager {
  private static instance: TabManager;
  private channel: BroadcastChannel | null = null;
  private isPrimary = false;
  private tabId: string;
  
  private constructor() {
    this.tabId = `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.initialize();
  }
  
  static getInstance(): TabManager {
    if (!TabManager.instance) {
      TabManager.instance = new TabManager();
    }
    return TabManager.instance;
  }
  
  private initialize(): void {
    try {
      // 创建广播频道用于标签页通信
      this.channel = new BroadcastChannel('rules-kill-game-tabs');
      
      // 监听其他标签页的消息
      this.channel.onmessage = (event) => {
        this.handleMessage(event.data);
      };
      
      // 声明此标签页的存在
      this.declareTab();
      
      // 检查是否为主标签页
      this.checkPrimaryStatus();
      
      // 监听页面可见性变化
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          this.checkPrimaryStatus();
        }
      });
      
      // 监听页面卸载
      window.addEventListener('beforeunload', () => {
        this.removeTab();
      });
      
    } catch (error) {
      console.warn('BroadcastChannel不支持，使用备用方案');
      this.useFallbackMethod();
    }
  }
  
  private declareTab(): void {
    const message = {
      type: 'TAB_DECLARED',
      tabId: this.tabId,
      timestamp: Date.now()
    };
    
    this.channel?.postMessage(message);
    
    // 存储到localStorage作为备用
    this.updateTabList();
  }
  
  private handleMessage(data: any): void {
    switch (data.type) {
      case 'TAB_DECLARED':
        this.handleTabDeclared(data);
        break;
      case 'PRIMARY_CHECK':
        this.handlePrimaryCheck(data);
        break;
      case 'PRIMARY_ASSIGNED':
        this.handlePrimaryAssigned(data);
        break;
    }
  }
  
  private handleTabDeclared(data: any): void {
    if (data.tabId !== this.tabId) {
      // 有其他标签页声明，检查主标签页状态
      setTimeout(() => this.checkPrimaryStatus(), 100);
    }
  }
  
  private checkPrimaryStatus(): void {
    const tabList = this.getTabList();
    const sortedTabs = Object.entries(tabList).sort((a, b) => a[1] - b[1]);
    
    // 最早创建的标签页成为主标签页
    const primaryTab = sortedTabs[0];
    const wasPrimary = this.isPrimary;
    this.isPrimary = primaryTab && primaryTab[0] === this.tabId;
    
    if (this.isPrimary && !wasPrimary) {
      // 成为新的主标签页
      this.onBecamePrimary();
    } else if (!this.isPrimary && wasPrimary) {
      // 失去主标签页地位
      this.onLostPrimary();
    }
  }
  
  private onBecamePrimary(): void {
    console.log('此标签页成为主标签页');
    
    // 通知其他标签页
    this.channel?.postMessage({
      type: 'PRIMARY_ASSIGNED',
      tabId: this.tabId,
      timestamp: Date.now()
    });
    
    // 启用所有功能
    this.enableAllFeatures();
  }
  
  private onLostPrimary(): void {
    console.log('此标签页失去主标签页地位');
    
    // 禁用某些功能或显示提示
    this.disableNonPrimaryFeatures();
  }
  
  private enableAllFeatures(): void {
    // 启用游戏功能
    document.body.classList.remove('non-primary-tab');
    
    // 可以继续游戏
    window.dispatchEvent(new CustomEvent('becamePrimaryTab'));
  }
  
  private disableNonPrimaryFeatures(): void {
    // 禁用某些功能
    document.body.classList.add('non-primary-tab');
    
    // 显示提示信息
    this.showNonPrimaryWarning();
    
    // 暂停游戏
    window.dispatchEvent(new CustomEvent('lostPrimaryTab'));
  }
  
  private showNonPrimaryWarning(): void {
    // 创建警告提示
    const warning = document.createElement('div');
    warning.className = 'non-primary-warning';
    warning.innerHTML = `
      <div class="warning-content">
        <span>⚠️ 游戏已在其他标签页中运行</span>
        <button onclick="window.focusPrimaryTab()">切换到主标签页</button>
      </div>
    `;
    
    document.body.appendChild(warning);
    
    // 添加样式
    const style = document.createElement('style');
    style.textContent = `
      .non-primary-warning {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ff6b6b;
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        animation: slideInRight 0.3s ease;
      }
      
      .warning-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .warning-content button {
        background: white;
        color: #ff6b6b;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
      }
      
      .non-primary-tab {
        opacity: 0.7;
        pointer-events: none;
      }
      
      .non-primary-tab .game-container {
        filter: grayscale(0.5);
      }
      
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(style);
  }
  
  private updateTabList(): void {
    try {
      const tabList = this.getTabList();
      tabList[this.tabId] = Date.now();
      
      // 清理过期标签页（超过30秒未更新）
      const now = Date.now();
      Object.keys(tabList).forEach(tabId => {
        if (now - tabList[tabId] > 30000) {
          delete tabList[tabId];
        }
      });
      
      localStorage.setItem('game_tabs', JSON.stringify(tabList));
    } catch (error) {
      console.warn('更新标签页列表失败:', error);
    }
  }
  
  private getTabList(): Record<string, number> {
    try {
      const stored = localStorage.getItem('game_tabs');
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      return {};
    }
  }
  
  private removeTab(): void {
    try {
      const tabList = this.getTabList();
      delete tabList[this.tabId];
      localStorage.setItem('game_tabs', JSON.stringify(tabList));
    } catch (error) {
      console.warn('移除标签页失败:', error);
    }
  }
  
  private useFallbackMethod(): void {
    // 使用localStorage作为备用方案
    setInterval(() => {
      this.updateTabList();
      this.checkPrimaryStatus();
    }, 1000);
  }
  
  public focusPrimaryTab(): void {
    // 尝试成为主标签页
    this.checkPrimaryStatus();
    
    if (!this.isPrimary) {
      // 移除当前标签页并重新创建
      this.removeTab();
      setTimeout(() => {
        this.declareTab();
        this.checkPrimaryStatus();
      }, 100);
    }
  }
  
  public isPrimaryTab(): boolean {
    return this.isPrimary;
  }
  
  public getTabId(): string {
    return this.tabId;
  }
}

// 全局函数供HTML调用
(window as any).focusPrimaryTab = () => {
  TabManager.getInstance().focusPrimaryTab();
};

// 使用示例
const tabManager = TabManager.getInstance();

// 监听主标签页变化
window.addEventListener('becamePrimaryTab', () => {
  console.log('成为主标签页，启用所有功能');
  // 启用游戏功能
});

window.addEventListener('lostPrimaryTab', () => {
  console.log('失去主标签页地位，禁用功能');
  // 禁用游戏功能
});
```

#### 数据清除服务
```typescript
// dataClearService.ts
import { LogManager } from '../utils/logManager';
import type { ClearOptions, ClearResult } from '../types/deployment';

/**
 * 数据清除服务
 */
export class DataClearService {
  private logManager: LogManager;
  
  constructor(logManager?: LogManager) {
    this.logManager = logManager || new LogManager();
  }
  
  /**
   * 清除游戏数据
   */
  async clearGameData(options: ClearOptions): Promise<ClearResult> {
    const result: ClearResult = {
      success: true,
      clearedItems: [],
      errors: [],
      timestamp: Date.now()
    };
    
    try {
      this.logManager.info('开始清除游戏数据', options);
      
      // 1. 清除游戏进度
      if (options.clearProgress) {
        await this.clearProgress(result);
      }
      
      // 2. 清除设置
      if (options.clearSettings) {
        await this.clearSettings(result);
      }
      
      // 3. 清除缓存
      if (options.clearCache) {
        await this.clearCache(result);
      }
      
      // 4. 清除日志
      if (options.clearLogs) {
        await this.clearLogs(result);
      }
      
      this.logManager.info('游戏数据清除完成', {
        clearedItems: result.clearedItems,
        errors: result.errors
      });
      
    } catch (error) {
      result.success = false;
      result.errors.push('数据清除过程中发生错误');
      this.logManager.error('数据清除失败', { error });
    }
    
    return result;
  }
  
  private async clearProgress(result: ClearResult): Promise<void> {
    try {
      // 清除localStorage中的游戏数据
      const gameKeys = Object.keys(localStorage).filter(key => 
        key.startsWith('game_') || key.startsWith('progress_')
      );
      
      gameKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // 清除sessionStorage中的临时数据
      const sessionKeys = Object.keys(sessionStorage).filter(key =>
        key.startsWith('game_') || key.startsWith('temp_')
      );
      
      sessionKeys.forEach(key => {
        sessionStorage.removeItem(key);
      });
      
      // 清除IndexedDB中的数据
      await this.clearIndexedDB();
      
      result.clearedItems.push('游戏进度');
      this.logManager.info('游戏进度清除完成', { clearedKeys: gameKeys });
      
    } catch (error) {
      result.errors.push('清除游戏进度失败');
      this.logManager.error('清除游戏进度失败', { error });
    }
  }
  
  private async clearSettings(result: ClearResult): Promise<void> {
    try {
      // 清除设置相关的localStorage
      const settingKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('settings_') || key.startsWith('config_')
      );
      
      settingKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      result.clearedItems.push('游戏设置');
      this.logManager.info('游戏设置清除完成', { clearedKeys: settingKeys });
      
    } catch (error) {
      result.errors.push('清除游戏设置失败');
      this.logManager.error('清除游戏设置失败', { error });
    }
  }
  
  private async clearCache(result: ClearResult): Promise<void> {
    try {
      // 清除缓存数据
      const cacheKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('cache_') || key.includes('_cache')
      );
      
      cacheKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // 尝试清除浏览器缓存
      if ('caches' in window) {
        try {
          const cacheNames = await caches.keys();
          await Promise.all(cacheNames.map(name => caches.delete(name)));
          result.clearedItems.push('浏览器缓存');
        } catch (error) {
          this.logManager.warn('清除浏览器缓存失败', { error });
        }
      }
      
      result.clearedItems.push('缓存数据');
      this.logManager.info('缓存数据清除完成', { clearedKeys: cacheKeys });
      
    } catch (error) {
      result.errors.push('清除缓存数据失败');
      this.logManager.error('清除缓存数据失败', { error });
    }
  }
  
  private async clearLogs(result: ClearResult): Promise<void> {
    try {
      // 清除日志管理器的日志
      await this.logManager.clearLogs();
      
      // 清除其他可能的日志存储
      const logKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('log_') || key.includes('_log')
      );
      
      logKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      result.clearedItems.push('日志文件');
      this.logManager.info('日志文件清除完成', { clearedKeys: logKeys });
      
    } catch (error) {
      result.errors.push('清除日志文件失败');
      this.logManager.error('清除日志文件失败', { error });
    }
  }
  
  private async clearIndexedDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!window.indexedDB) {
        resolve();
        return;
      }
      
      const deleteRequests = [];
      
      // 获取所有数据库名称
      indexedDB.databases().then((databases) => {
        databases.forEach(db => {
          if (db.name) {
            const deleteRequest = indexedDB.deleteDatabase(db.name);
            deleteRequests.push(
              new Promise<void>((resolve, reject) => {
                deleteRequest.onsuccess = () => resolve();
                deleteRequest.onerror = () => reject(deleteRequest.error);
              })
            );
          }
        });
        
        Promise.all(deleteRequests).then(() => {
          this.logManager.info('IndexedDB清除完成');
          resolve();
        }).catch((error) => {
          this.logManager.warn('部分IndexedDB清除失败', { error });
          resolve(); // 继续执行，不阻塞整体流程
        });
      }).catch((error) => {
        this.logManager.warn('获取IndexedDB列表失败', { error });
        resolve();
      });
    });
  }
  
  /**
   * 获取数据大小信息
   */
  async getDataSizeInfo(): Promise<{
    totalSize: string;
    breakdown: Record<string, string>;
  }> {
    try {
      let totalSize = 0;
      const breakdown: Record<string, string> = {};
      
      // 计算localStorage大小
      let localStorageSize = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key) {
          const value = localStorage.getItem(key);
          if (value) {
            localStorageSize += key.length + value.length;
          }
        }
      }
      totalSize += localStorageSize;
      breakdown.localStorage = this.formatBytes(localStorageSize);
      
      // 计算sessionStorage大小
      let sessionStorageSize = 0;
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key) {
          const value = sessionStorage.getItem(key);
          if (value) {
            sessionStorageSize += key.length + value.length;
          }
        }
      }
      totalSize += sessionStorageSize;
      breakdown.sessionStorage = this.formatBytes(sessionStorageSize);
      
      // 估算IndexedDB大小（粗略估计）
      try {
        const databases = await indexedDB.databases();
        breakdown.indexedDB = `${databases.length} 个数据库`;
      } catch (error) {
        breakdown.indexedDB = '无法获取';
      }
      
      return {
        totalSize: this.formatBytes(totalSize),
        breakdown
      };
      
    } catch (error) {
      this.logManager.error('获取数据大小信息失败', { error });
      return {
        totalSize: '未知',
        breakdown: {}
      };
    }
  }
  
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
```

#### 性能测试工具
```typescript
// performanceTester.ts
export class PerformanceTester {
  private metrics: PerformanceMetrics[] = [];
  
  /**
   * 测试应用启动性能
   */
  async testStartupPerformance(): Promise<PerformanceMetrics> {
    const startTime = performance.now();
    const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
    
    // 模拟应用启动过程
    await this.simulateAppStartup();
    
    const endTime = performance.now();
    const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
    const startupTime = endTime - startTime;
    const memoryUsage = endMemory - startMemory;
    
    return {
      startupTime,
      memoryUsage,
      diskUsage: 0, // 需要额外计算
      bundleSize: 0, // 需要额外计算
      launchTime: startupTime
    };
  }
  
  /**
   * 测试内存使用
   */
  async testMemoryUsage(): Promise<number> {
    if (!(performance as any).memory) {
      console.warn('当前环境不支持内存监控');
      return 0;
    }
    
    return (performance as any).memory.usedJSHeapSize;
  }
  
  /**
   * 模拟应用启动
   */
  private async simulateAppStartup(): Promise<void> {
    // 模拟各种启动任务
    await this.delay(100); // 初始化
    await this.delay(50);  // 加载配置
    await this.delay(150); // 初始化组件
    await this.delay(100); // 渲染界面
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * 运行完整性能测试
   */
  async runFullPerformanceTest(): Promise<{
    startup: PerformanceMetrics;
    memory: number;
    recommendations: string[];
  }> {
    console.log('开始性能测试...');
    
    const startup = await this.testStartupPerformance();
    const memory = await this.testMemoryUsage();
    
    const recommendations = this.generateRecommendations(startup, memory);
    
    return {
      startup,
      memory,
      recommendations
    };
  }
  
  private generateRecommendations(
    startup: PerformanceMetrics,
    memory: number
  ): string[] {
    const recommendations: string[] = [];
    
    if (startup.startupTime > 3000) {
      recommendations.push('启动时间超过3秒，建议优化初始化流程');
    }
    
    if (memory > 500 * 1024 * 1024) { // 500MB
      recommendations.push('内存使用超过500MB，建议检查内存泄漏');
    }
    
    if (startup.memoryUsage > 100 * 1024 * 1024) { // 100MB
      recommendations.push('启动内存增加超过100MB，建议优化资源加载');
    }
    
    return recommendations;
  }
}
```

#### 兼容性测试工具
```typescript
// compatibilityTester.ts
export class CompatibilityTester {
  private results: CompatibilityResult[] = [];
  
  /**
   * 运行兼容性测试
   */
  async runCompatibilityTest(): Promise<CompatibilityResult[]> {
    this.results = [];
    
    // 测试各项功能
    await this.testBrowserFeatures();
    await this.testStorageFeatures();
    await this.testPerformanceFeatures();
    await this.testElectronFeatures();
    
    return this.results;
  }
  
  private async testBrowserFeatures(): Promise<void> {
    const features = [
      { name: 'localStorage', test: () => typeof Storage !== 'undefined' },
      { name: 'sessionStorage', test: () => typeof sessionStorage !== 'undefined' },
      { name: 'IndexedDB', test: () => typeof indexedDB !== 'undefined' },
      { name: 'BroadcastChannel', test: () => typeof BroadcastChannel !== 'undefined' },
      { name: 'CSS Grid', test: () => CSS.supports('display', 'grid') },
      { name: 'CSS Flexbox', test: () => CSS.supports('display', 'flex') },
      { name: 'ES6 Promises', test: () => typeof Promise !== 'undefined' },
      { name: 'ES6 Arrow Functions', test: () => {
        try {
          eval('(() => {})');
          return true;
        } catch {
          return false;
        }
      }}
    ];
    
    for (const feature of features) {
      const passed = feature.test();
      this.results.push({
        platform: 'Browser',
        version: feature.name,
        passed,
        issues: passed ? [] : [`不支持 ${feature.name}`],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testStorageFeatures(): Promise<void> {
    try {
      // 测试localStorage
      const testKey = 'compatibility_test';
      const testValue = 'test_value';
      localStorage.setItem(testKey, testValue);
      const retrieved = localStorage.getItem(testKey);
      localStorage.removeItem(testKey);
      
      this.results.push({
        platform: 'Storage',
        version: 'localStorage',
        passed: retrieved === testValue,
        issues: retrieved === testValue ? [] : ['localStorage读写失败'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
      
      // 测试存储配额
      const quotaResult = await this.testStorageQuota();
      this.results.push(quotaResult);
      
    } catch (error) {
      this.results.push({
        platform: 'Storage',
        version: 'Basic Storage',
        passed: false,
        issues: ['存储功能测试失败'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testStorageQuota(): Promise<CompatibilityResult> {
    try {
      if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        const usage = estimate.usage || 0;
        const quota = estimate.quota || 0;
        const usageRatio = usage / quota;
        
        return {
          platform: 'Storage',
          version: 'Storage API',
          passed: true,
          issues: usageRatio > 0.9 ? ['存储空间使用率超过90%'] : [],
          performance: {
            startupTime: 0,
            memoryUsage: usage,
            diskUsage: quota,
            bundleSize: 0,
            launchTime: 0
          }
        };
      }
      
      return {
        platform: 'Storage',
        version: 'Storage API',
        passed: false,
        issues: ['Storage API不支持'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      };
    } catch (error) {
      return {
        platform: 'Storage',
        version: 'Storage API',
        passed: false,
        issues: ['存储配额测试失败'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      };
    }
  }
  
  private async testPerformanceFeatures(): Promise<void> {
    try {
      // 测试性能API
      const hasPerformanceAPI = typeof performance !== 'undefined';
      const hasMemoryAPI = hasPerformanceAPI && 'memory' in performance;
      
      this.results.push({
        platform: 'Performance',
        version: 'Performance API',
        passed: hasPerformanceAPI,
        issues: hasPerformanceAPI ? [] : ['Performance API不支持'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
      
      if (hasMemoryAPI) {
        this.results.push({
          platform: 'Performance',
          version: 'Memory API',
          passed: true,
          issues: [],
          performance: {
            startupTime: 0,
            memoryUsage: (performance as any).memory?.usedJSHeapSize || 0,
            diskUsage: 0,
            bundleSize: 0,
            launchTime: 0
          }
        });
      }
      
    } catch (error) {
      this.results.push({
        platform: 'Performance',
        version: 'Performance Features',
        passed: false,
        issues: ['性能API测试失败'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testElectronFeatures(): Promise<void> {
    // 检测是否在Electron环境中
    const isElectron = this.isElectronEnvironment();
    
    this.results.push({
      platform: 'Electron',
      version: 'Environment',
      passed: isElectron,
      issues: isElectron ? [] : ['不在Electron环境中'],
      performance: {
        startupTime: 0,
        memoryUsage: 0,
        diskUsage: 0,
        bundleSize: 0,
        launchTime: 0
      }
    });
    
    if (isElectron) {
      // 测试Electron特定功能
      const electronFeatures = [
        { name: 'Node.js', test: () => typeof process !== 'undefined' },
        { name: 'File System', test: () => {
          try {
            // @ts-ignore
            return typeof require !== 'undefined' && require('fs');
          } catch {
            return false;
          }
        }},
        { name: 'IPC', test: () => {
          try {
            // @ts-ignore
            return typeof require !== 'undefined' && require('electron').ipcRenderer;
          } catch {
            return false;
          }
        }}
      ];
      
      for (const feature of electronFeatures) {
        const passed = feature.test();
        this.results.push({
          platform: 'Electron',
          version: feature.name,
          passed,
          issues: passed ? [] : [`不支持 ${feature.name}`],
          performance: {
            startupTime: 0,
            memoryUsage: 0,
            diskUsage: 0,
            bundleSize: 0,
            launchTime: 0
          }
        });
      }
    }
  }
  
  private isElectronEnvironment(): boolean {
    return typeof process !== 'undefined' && 
           process.versions != null && 
           process.versions.electron != null;
  }
  
  /**
   * 生成兼容性报告
   */
  generateReport(): {
    summary: {
      total: number;
      passed: number;
      failed: number;
      passRate: number;
    };
    criticalIssues: string[];
    recommendations: string[];
    details: CompatibilityResult[];
  } {
    const total = this.results.length;
    const passed = this.results.filter(r => r.passed).length;
    const failed = total - passed;
    const passRate = total > 0 ? (passed / total) * 100 : 0;
    
    const criticalIssues = this.results
      .filter(r => !r.passed)
      .flatMap(r => r.issues)
      .filter(issue => issue.includes('不支持'));
    
    const recommendations = this.generateRecommendations(criticalIssues);
    
    return {
      summary: {
        total,
        passed,
        failed,
        passRate
      },
      criticalIssues,
      recommendations,
      details: this.results
    };
  }
  
  private generateRecommendations(issues: string[]): string[] {
    const recommendations: string[] = [];
    
    if (issues.some(issue => issue.includes('localStorage'))) {
      recommendations.push('建议使用现代浏览器或启用本地存储功能');
    }
    
    if (issues.some(issue => issue.includes('IndexedDB'))) {
      recommendations.push('考虑使用localStorage作为数据存储备选方案');
    }
    
    if (issues.some(issue => issue.includes('BroadcastChannel'))) {
      recommendations.push('多标签页功能可能受限，建议使用localStorage备用方案');
    }
    
    if (issues.some(issue => issue.includes('CSS Grid'))) {
      recommendations.push('建议使用CSS Flexbox作为布局备选方案');
    }
    
    if (issues.some(issue => issue.includes('ES6'))) {
      recommendations.push('建议使用Babel转译以支持旧版浏览器');
    }
    
    return recommendations;
  }
}
```

#### 打包部署脚本
```typescript
// build.ts
import { build } from 'electron-builder';
import { electronConfig, builderConfig } from './config/electron.config';

/**
 * 构建Electron应用
 */
export async function buildElectronApp(): Promise<void> {
  try {
    console.log('🚀 开始构建Electron应用...');
    
    // 构建React应用
    console.log('📦 构建React应用...');
    await buildReactApp();
    
    // 构建Electron应用
    console.log('🔧 构建Electron应用...');
    await build({
      config: builderConfig,
      win: ['nsis'],
      x64: true,
      ia32: false,
      publish: 'never'
    });
    
    console.log('✅ Electron应用构建完成');
    
  } catch (error) {
    console.error('❌ 构建失败:', error);
    throw error;
  }
}

/**
 * 构建React应用
 */
async function buildReactApp(): Promise<void> {
  return new Promise((resolve, reject) => {
    const { exec } = require('child_process');
    
    exec('npm run build', (error: Error, stdout: string, stderr: string) => {
      if (error) {
        console.error('React构建失败:', stderr);
        reject(error);
      } else {
        console.log('React构建完成:', stdout);
        resolve();
      }
    });
  });
}

/**
 * 运行性能测试
 */
export async function runPerformanceTest(): Promise<void> {
  const { PerformanceTester } = await import('./utils/performanceTester');
  const tester = new PerformanceTester();
  
  console.log('🏃 运行性能测试...');
  const results = await tester.runFullPerformanceTest();
  
  console.log('📊 性能测试结果:');
  console.log('启动时间:', results.startup.startupTime, 'ms');
  console.log('内存使用:', results.memory, 'bytes');
  console.log('优化建议:', results.recommendations);
}

/**
 * 运行兼容性测试
 */
export async function runCompatibilityTest(): Promise<void> {
  const { CompatibilityTester } = await import('./utils/compatibilityTester');
  const tester = new CompatibilityTester();
  
  console.log('🔍 运行兼容性测试...');
  await tester.runCompatibilityTest();
  const report = tester.generateReport();
  
  console.log('📋 兼容性报告:');
  console.log(`总计: ${report.summary.total} 项`);
  console.log(`通过: ${report.summary.passed} 项`);
  console.log(`失败: ${report.summary.failed} 项`);
  console.log(`通过率: ${report.summary.passRate.toFixed(1)}%`);
  
  if (report.criticalIssues.length > 0) {
    console.log('⚠️ 关键问题:', report.criticalIssues);
  }
  
  if (report.recommendations.length > 0) {
    console.log('💡 建议:', report.recommendations);
  }
}

/**
 * 完整构建流程
 */
export async function fullBuildProcess(): Promise<void> {
  console.log('🎯 开始完整构建流程...');
  
  try {
    // 1. 运行兼容性测试
    await runCompatibilityTest();
    
    // 2. 运行性能测试
    await runPerformanceTest();
    
    // 3. 构建应用
    await buildElectronApp();
    
    console.log('🎉 构建流程完成');
    
  } catch (error) {
    console.error('构建流程失败:', error);
    throw error;
  }
}
```