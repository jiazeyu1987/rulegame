# Epic11-å­ä»»åŠ¡01: æ¸…é™¤è®°å¿†ç¡®è®¤ä¸æ‰“åŒ…éƒ¨ç½²

## å¼€å‘çŠ¶æ€
å­ä»»åŠ¡å¼€å‘å®Œæˆ

## å¼€å‘æ–¹æ¡ˆ

### 1. å¼€å‘ç›®æ ‡
å®ç°æ¸…é™¤è®°å¿†åŠŸèƒ½çš„äºŒæ¬¡ç¡®è®¤æœºåˆ¶ï¼Œå®Œæˆåº”ç”¨ç¨‹åºexeå°è£…æ‰“åŒ…ï¼Œè¿›è¡Œæ€§èƒ½ä¼˜åŒ–å’Œå…¼å®¹æ€§æµ‹è¯•ã€‚

### 2. è®¾è®¡æ–¹æ¡ˆ
- äºŒæ¬¡ç¡®è®¤å¼¹çª—ç»„ä»¶è®¾è®¡
- Electronæ‰“åŒ…é…ç½®å’Œä¼˜åŒ–
- æ€§èƒ½åŸºå‡†æµ‹è¯•å’Œä¼˜åŒ–
- Windowså…¼å®¹æ€§éªŒè¯æ–¹æ¡ˆ
- å¤šæ ‡ç­¾é¡µé™åˆ¶æœºåˆ¶
- æ•°æ®æ¸…é™¤å®Œæ•´æ€§éªŒè¯

### 3. å®ç°æ–¹å¼

#### æ ¸å¿ƒç±»å‹å®šä¹‰
```typescript
// æ¸…é™¤è®°å¿†ç¡®è®¤ç»„ä»¶å±æ€§
export interface ClearMemoryModalProps {
  isOpen: boolean;
  onConfirm: () => void;
  onCancel: () => void;
  riskLevel: 'low' | 'medium' | 'high';
  dataSize?: string;
  lastClearTime?: number;
}

// æ•°æ®æ¸…é™¤é€‰é¡¹
export interface ClearOptions {
  clearProgress: boolean;      // æ¸…é™¤æ¸¸æˆè¿›åº¦
  clearSettings: boolean;      // æ¸…é™¤è®¾ç½®
  clearCache: boolean;         // æ¸…é™¤ç¼“å­˜
  clearLogs: boolean;          // æ¸…é™¤æ—¥å¿—
  confirmText?: string;        // è‡ªå®šä¹‰ç¡®è®¤æ–‡æœ¬
}

// æ¸…é™¤ç»“æœ
export interface ClearResult {
  success: boolean;
  clearedItems: string[];
  errors: string[];
  timestamp: number;
}

// Electronåº”ç”¨é…ç½®
export interface ElectronConfig {
  appId: string;
  productName: string;
  version: string;
  description: string;
  author: string;
  directories: {
    output: string;
    buildResources: string;
  };
  files: string[];
  extraResources: string[];
  win: {
    target: string;
    icon: string;
    requestedExecutionLevel: string;
  };
  nsis: {
    oneClick: boolean;
    allowToChangeInstallationDirectory: boolean;
    createDesktopShortcut: boolean;
    createStartMenuShortcut: boolean;
  };
}

// æ€§èƒ½æŒ‡æ ‡
export interface PerformanceMetrics {
  startupTime: number;
  memoryUsage: number;
  diskUsage: number;
  bundleSize: number;
  launchTime: number;
}

// å…¼å®¹æ€§æµ‹è¯•ç»“æœ
export interface CompatibilityResult {
  platform: string;
  version: string;
  passed: boolean;
  issues: string[];
  performance: PerformanceMetrics;
}
```

#### æ¸…é™¤è®°å¿†ç¡®è®¤ç»„ä»¶å®ç°
```typescript
import React, { useState, useEffect } from 'react';
import './ClearMemoryModal.css';

const ClearMemoryModal: React.FC<ClearMemoryModalProps> = ({
  isOpen,
  onConfirm,
  onCancel,
  riskLevel,
  dataSize = 'æœªçŸ¥',
  lastClearTime
}) => {
  const [step, setStep] = useState(1);
  const [clearOptions, setClearOptions] = useState<ClearOptions>({
    clearProgress: true,
    clearSettings: false,
    clearCache: true,
    clearLogs: false
  });
  const [confirmText, setConfirmText] = useState('');
  const [requiredText, setRequiredText] = useState('');
  const [countdown, setCountdown] = useState(0);

  useEffect(() => {
    if (isOpen) {
      setStep(1);
      setCountdown(getCountdownTime());
      setRequiredText(getRequiredConfirmText());
      // å¯åŠ¨å€’è®¡æ—¶
      const timer = setInterval(() => {
        setCountdown(prev => {
          if (prev <= 1) {
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
      return () => clearInterval(timer);
    }
  }, [isOpen, riskLevel]);

  const getCountdownTime = (): number => {
    switch (riskLevel) {
      case 'high': return 10;
      case 'medium': return 5;
      case 'low': return 0;
      default: return 0;
    }
  };

  const getRequiredConfirmText = (): string => {
    switch (riskLevel) {
      case 'high': return 'æ°¸ä¹…åˆ é™¤';
      case 'medium': return 'ç¡®è®¤åˆ é™¤';
      case 'low': return 'åˆ é™¤';
      default: return 'åˆ é™¤';
    }
  };

  const getRiskLevelConfig = () => {
    switch (riskLevel) {
      case 'high':
        return {
          title: 'âš ï¸ é«˜é£é™©æ“ä½œ',
          description: 'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰æ¸¸æˆæ•°æ®ï¼ŒåŒ…æ‹¬è¿›åº¦ã€è®¾ç½®ã€ç¼“å­˜ç­‰ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚',
          confirmButtonText: 'æˆ‘ç†è§£é£é™©ï¼Œç¡®è®¤åˆ é™¤',
          confirmButtonClass: 'danger-high',
          icon: 'ğŸ”¥'
        };
      case 'medium':
        return {
          title: 'âš¡ ä¸­ç­‰é£é™©æ“ä½œ',
          description: 'æ­¤æ“ä½œå°†åˆ é™¤é€‰ä¸­çš„æ•°æ®é¡¹ç›®ã€‚éƒ¨åˆ†æ•°æ®å¯ä»¥æ¢å¤ã€‚',
          confirmButtonText: 'ç¡®è®¤åˆ é™¤é€‰ä¸­æ•°æ®',
          confirmButtonClass: 'danger-medium',
          icon: 'âš¡'
        };
      case 'low':
        return {
          title: 'ğŸ—‘ï¸ æ¸…ç†æ“ä½œ',
          description: 'æ­¤æ“ä½œå°†æ¸…ç†ä¸´æ—¶æ•°æ®å’Œç¼“å­˜ï¼Œä¸ä¼šå½±å“æ¸¸æˆè¿›åº¦ã€‚',
          confirmButtonText: 'æ¸…ç†æ•°æ®',
          confirmButtonClass: 'danger-low',
          icon: 'ğŸ—‘ï¸'
        };
      default:
        return {
          title: 'æ•°æ®æ¸…é™¤',
          description: 'æ¸…é™¤é€‰ä¸­çš„æ•°æ®é¡¹ç›®ã€‚',
          confirmButtonText: 'ç¡®è®¤æ¸…é™¤',
          confirmButtonClass: 'danger-low',
          icon: 'ğŸ—‘ï¸'
        };
    }
  };

  const handleOptionChange = (option: keyof ClearOptions) => {
    setClearOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleNextStep = () => {
    if (step === 1) {
      setStep(2);
    }
  };

  const handleConfirm = () => {
    if (confirmText !== requiredText) {
      alert(`è¯·è¾“å…¥"${requiredText}"ä»¥ç¡®è®¤æ“ä½œ`);
      return;
    }
    
    if (countdown > 0) {
      alert(`è¯·ç­‰å¾…${countdown}ç§’åå†ç¡®è®¤`);
      return;
    }
    
    onConfirm();
  };

  const formatLastClearTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleString('zh-CN');
  };

  const config = getRiskLevelConfig();

  if (!isOpen) return null;

  return (
    <div className="clear-memory-modal-overlay">
      <div className="clear-memory-modal">
        <div className="modal-header">
          <span className="risk-icon">{config.icon}</span>
          <h2>{config.title}</h2>
          <button className="close-button" onClick={onCancel}>Ã—</button>
        </div>

        <div className="modal-content">
          {step === 1 && (
            <div className="step-1">
              <div className="risk-description">
                <p>{config.description}</p>
                
                <div className="data-info">
                  <h4>å¾…æ¸…é™¤æ•°æ®ä¿¡æ¯ï¼š</h4>
                  <ul>
                    <li>ğŸ“Š æ•°æ®å¤§å°: {dataSize}</li>
                    {lastClearTime && (
                      <li>ğŸ• ä¸Šæ¬¡æ¸…é™¤: {formatLastClearTime(lastClearTime)}</li>
                    )}
                  </ul>
                </div>

                <div className="clear-options">
                  <h4>é€‰æ‹©è¦æ¸…é™¤çš„æ•°æ®ï¼š</h4>
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearProgress}
                      onChange={() => handleOptionChange('clearProgress')}
                      disabled={riskLevel === 'high'} // é«˜é£é™©æ—¶å¼ºåˆ¶æ¸…é™¤æ‰€æœ‰
                    />
                    <span className="option-label">
                      æ¸¸æˆè¿›åº¦ (âš ï¸ ä¸å¯æ¢å¤)
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearSettings}
                      onChange={() => handleOptionChange('clearSettings')}
                    />
                    <span className="option-label">
                      æ¸¸æˆè®¾ç½®
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearCache}
                      onChange={() => handleOptionChange('clearCache')}
                    />
                    <span className="option-label">
                      ç¼“å­˜æ•°æ®
                    </span>
                  </label>
                  
                  <label className="option-item">
                    <input
                      type="checkbox"
                      checked={clearOptions.clearLogs}
                      onChange={() => handleOptionChange('clearLogs')}
                    />
                    <span className="option-label">
                      æ—¥å¿—æ–‡ä»¶
                    </span>
                  </label>
                </div>

                {riskLevel === 'high' && (
                  <div className="warning-box">
                    <h4>âš ï¸ é‡è¦è­¦å‘Š</h4>
                    <ul>
                      <li>æ­¤æ“ä½œä¸å¯æ’¤é”€</li>
                      <li>æ‰€æœ‰æ¸¸æˆè¿›åº¦å°†æ°¸ä¹…ä¸¢å¤±</li>
                      <li>è¯·ç¡®ä¿å·²å¤‡ä»½é‡è¦æ•°æ®</li>
                      <li>å»ºè®®åœ¨æ¸…é™¤å‰å¯¼å‡ºæ¸¸æˆå­˜æ¡£</li>
                    </ul>
                  </div>
                )}
              </div>

              <div className="step-actions">
                <button className="cancel-button" onClick={onCancel}>
                  å–æ¶ˆ
                </button>
                <button 
                  className="next-button" 
                  onClick={handleNextStep}
                  disabled={!clearOptions.clearProgress && !clearOptions.clearSettings && 
                           !clearOptions.clearCache && !clearOptions.clearLogs}
                >
                  ä¸‹ä¸€æ­¥
                </button>
              </div>
            </div>
          )}

          {step === 2 && (
            <div className="step-2">
              <div className="final-confirmation">
                <h3>æœ€ç»ˆç¡®è®¤</h3>
                <p>è¯·è¾“å…¥ <strong>"{requiredText}"</strong> ä»¥ç¡®è®¤æ“ä½œï¼š</p>
                
                <input
                  type="text"
                  value={confirmText}
                  onChange={(e) => setConfirmText(e.target.value)}
                  placeholder={requiredText}
                  className="confirm-input"
                />

                {countdown > 0 && (
                  <div className="countdown-timer">
                    â±ï¸ è¯·ç­‰å¾… {countdown} ç§’
                  </div>
                )}

                <div className="selected-options">
                  <h4>ç¡®è®¤æ¸…é™¤ä»¥ä¸‹æ•°æ®ï¼š</h4>
                  <ul>
                    {clearOptions.clearProgress && <li>âœ“ æ¸¸æˆè¿›åº¦</li>}
                    {clearOptions.clearSettings && <li>âœ“ æ¸¸æˆè®¾ç½®</li>}
                    {clearOptions.clearCache && <li>âœ“ ç¼“å­˜æ•°æ®</li>}
                    {clearOptions.clearLogs && <li>âœ“ æ—¥å¿—æ–‡ä»¶</li>}
                  </ul>
                </div>
              </div>

              <div className="step-actions">
                <button className="back-button" onClick={() => setStep(1)}>
                  ä¸Šä¸€æ­¥
                </button>
                <button className="cancel-button" onClick={onCancel}>
                  å–æ¶ˆ
                </button>
                <button 
                  className={`confirm-button ${config.confirmButtonClass}`}
                  onClick={handleConfirm}
                  disabled={confirmText !== requiredText || countdown > 0}
                >
                  {countdown > 0 ? `ç­‰å¾…ä¸­... (${countdown}s)` : config.confirmButtonText}
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ClearMemoryModal;
```

#### CSSæ ·å¼å®ç°
```css
/* ClearMemoryModal.css */
.clear-memory-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.3s ease;
}

.clear-memory-modal {
  background: linear-gradient(135deg, #ffffff, #f8f9fa);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  animation: slideUp 0.3s ease;
}

.modal-header {
  padding: 24px;
  border-bottom: 1px solid #e9ecef;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.risk-icon {
  font-size: 2em;
  margin-right: 12px;
}

.modal-header h2 {
  margin: 0;
  flex: 1;
  font-size: 1.5em;
  font-weight: 600;
}

.close-button {
  background: none;
  border: none;
  font-size: 1.5em;
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.close-button:hover {
  background-color: #f0f0f0;
}

.modal-content {
  padding: 24px;
}

.risk-description {
  margin-bottom: 24px;
}

.risk-description p {
  font-size: 1.1em;
  line-height: 1.6;
  color: #495057;
}

.data-info {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 8px;
  margin: 16px 0;
}

.data-info h4 {
  margin: 0 0 8px 0;
  color: #343a40;
}

.data-info ul {
  margin: 0;
  padding-left: 20px;
}

.data-info li {
  margin: 4px 0;
  color: #6c757d;
}

.clear-options {
  margin: 20px 0;
}

.clear-options h4 {
  margin: 0 0 12px 0;
  color: #343a40;
}

.option-item {
  display: flex;
  align-items: center;
  margin: 12px 0;
  cursor: pointer;
  padding: 8px;
  border-radius: 6px;
  transition: background-color 0.2s;
}

.option-item:hover {
  background-color: #f8f9fa;
}

.option-item input[type="checkbox"] {
  margin-right: 12px;
  transform: scale(1.2);
}

.option-label {
  font-weight: 500;
  color: #495057;
}

.warning-box {
  background: linear-gradient(135deg, #fff3cd, #ffeaa7);
  border: 1px solid #ffeaa7;
  border-radius: 8px;
  padding: 16px;
  margin: 20px 0;
}

.warning-box h4 {
  margin: 0 0 8px 0;
  color: #856404;
}

.warning-box ul {
  margin: 0;
  padding-left: 20px;
}

.warning-box li {
  color: #856404;
  margin: 4px 0;
}

.step-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 20px;
  border-top: 1px solid #e9ecef;
}

.step-actions button {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 1em;
}

.cancel-button {
  background-color: #6c757d;
  color: white;
}

.cancel-button:hover {
  background-color: #5a6268;
}

.next-button, .confirm-button {
  background-color: #007bff;
  color: white;
}

.next-button:hover:not(:disabled), .confirm-button:hover:not(:disabled) {
  background-color: #0056b3;
}

.back-button {
  background-color: #6c757d;
  color: white;
}

.back-button:hover {
  background-color: #5a6268;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.danger-high {
  background: linear-gradient(135deg, #dc3545, #c82333);
}

.danger-high:hover:not(:disabled) {
  background: linear-gradient(135deg, #c82333, #a71d2a);
}

.danger-medium {
  background: linear-gradient(135deg, #fd7e14, #e55100);
}

.danger-medium:hover:not(:disabled) {
  background: linear-gradient(135deg, #e55100, #cc4400);
}

.danger-low {
  background: linear-gradient(135deg, #28a745, #218838);
}

.danger-low:hover:not(:disabled) {
  background: linear-gradient(135deg, #218838, #1e7e34);
}

.final-confirmation {
  text-align: center;
}

.final-confirmation h3 {
  margin: 0 0 16px 0;
  color: #343a40;
}

.final-confirmation p {
  margin: 0 0 20px 0;
  color: #6c757d;
}

.confirm-input {
  width: 100%;
  padding: 12px;
  border: 2px solid #dee2e6;
  border-radius: 8px;
  font-size: 1.1em;
  text-align: center;
  margin: 16px 0;
  transition: border-color 0.2s;
}

.confirm-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.countdown-timer {
  font-size: 1.2em;
  font-weight: 600;
  color: #dc3545;
  margin: 16px 0;
  animation: pulse 1s infinite;
}

.selected-options {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: left;
}

.selected-options h4 {
  margin: 0 0 12px 0;
  color: #343a40;
}

.selected-options ul {
  margin: 0;
  padding-left: 20px;
}

.selected-options li {
  color: #28a745;
  font-weight: 500;
  margin: 4px 0;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
  .clear-memory-modal {
    margin: 20px;
    width: calc(100% - 40px);
  }
  
  .modal-content {
    padding: 16px;
  }
  
  .step-actions {
    flex-direction: column;
  }
  
  .step-actions button {
    width: 100%;
  }
}

/* é«˜å¯¹æ¯”åº¦æ¨¡å¼æ”¯æŒ */
@media (prefers-contrast: high) {
  .clear-memory-modal {
    border: 2px solid #000;
  }
  
  .warning-box {
    border: 2px solid #856404;
  }
  
  .confirm-input {
    border-width: 3px;
  }
}

/* å‡å°‘åŠ¨ç”»æ¨¡å¼æ”¯æŒ */
@media (prefers-reduced-motion: reduce) {
  .clear-memory-modal-overlay,
  .clear-memory-modal {
    animation: none;
  }
  
  .countdown-timer {
    animation: none;
  }
}
```

#### Electronæ‰“åŒ…é…ç½®
```typescript
// electron.config.ts
import type { ElectronConfig } from '../types/deployment';

export const electronConfig: ElectronConfig = {
  appId: 'com.ruleskill.game',
  productName: 'è§„åˆ™æ€ªè°ˆæ¸¸æˆ',
  version: '1.0.0',
  description: 'åŸºäºReactçš„å¯å®¤è§„åˆ™æ€ªè°ˆæ–‡å­—å†’é™©æ¸¸æˆ',
  author: 'è§„åˆ™æ€ªè°ˆå·¥ä½œå®¤',
  directories: {
    output: 'dist-electron',
    buildResources: 'build-resources'
  },
  files: [
    'build/**/*',
    'node_modules/**/*',
    'package.json',
    '!**/*.map',
    '!**/test/**',
    '!**/*.test.*',
    '!**/__tests__/**'
  ],
  extraResources: [
    {
      from: 'assets',
      to: 'assets',
      filter: ['**/*']
    },
    {
      from: 'docs',
      to: 'docs',
      filter: ['*.md']
    }
  ],
  win: {
    target: 'nsis',
    icon: 'assets/icon.ico',
    requestedExecutionLevel: 'asInvoker'
  },
  nsis: {
    oneClick: false,
    allowToChangeInstallationDirectory: true,
    createDesktopShortcut: true,
    createStartMenuShortcut: true,
    shortcutName: 'è§„åˆ™æ€ªè°ˆæ¸¸æˆ'
  }
};

// electron-builderé…ç½®
export const builderConfig = {
  ...electronConfig,
  publish: {
    provider: 'github',
    owner: 'ruleskill',
    repo: 'rules-kill-game'
  },
  compression: 'maximum',
  removePackageScripts: true,
  buildDependenciesFromSource: false,
  nodeGypRebuild: false,
  npmRebuild: false
};
```

#### å¤šæ ‡ç­¾é¡µé™åˆ¶æœºåˆ¶
```typescript
// tabManager.ts
export class TabManager {
  private static instance: TabManager;
  private channel: BroadcastChannel | null = null;
  private isPrimary = false;
  private tabId: string;
  
  private constructor() {
    this.tabId = `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.initialize();
  }
  
  static getInstance(): TabManager {
    if (!TabManager.instance) {
      TabManager.instance = new TabManager();
    }
    return TabManager.instance;
  }
  
  private initialize(): void {
    try {
      // åˆ›å»ºå¹¿æ’­é¢‘é“ç”¨äºæ ‡ç­¾é¡µé€šä¿¡
      this.channel = new BroadcastChannel('rules-kill-game-tabs');
      
      // ç›‘å¬å…¶ä»–æ ‡ç­¾é¡µçš„æ¶ˆæ¯
      this.channel.onmessage = (event) => {
        this.handleMessage(event.data);
      };
      
      // å£°æ˜æ­¤æ ‡ç­¾é¡µçš„å­˜åœ¨
      this.declareTab();
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»æ ‡ç­¾é¡µ
      this.checkPrimaryStatus();
      
      // ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          this.checkPrimaryStatus();
        }
      });
      
      // ç›‘å¬é¡µé¢å¸è½½
      window.addEventListener('beforeunload', () => {
        this.removeTab();
      });
      
    } catch (error) {
      console.warn('BroadcastChannelä¸æ”¯æŒï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ');
      this.useFallbackMethod();
    }
  }
  
  private declareTab(): void {
    const message = {
      type: 'TAB_DECLARED',
      tabId: this.tabId,
      timestamp: Date.now()
    };
    
    this.channel?.postMessage(message);
    
    // å­˜å‚¨åˆ°localStorageä½œä¸ºå¤‡ç”¨
    this.updateTabList();
  }
  
  private handleMessage(data: any): void {
    switch (data.type) {
      case 'TAB_DECLARED':
        this.handleTabDeclared(data);
        break;
      case 'PRIMARY_CHECK':
        this.handlePrimaryCheck(data);
        break;
      case 'PRIMARY_ASSIGNED':
        this.handlePrimaryAssigned(data);
        break;
    }
  }
  
  private handleTabDeclared(data: any): void {
    if (data.tabId !== this.tabId) {
      // æœ‰å…¶ä»–æ ‡ç­¾é¡µå£°æ˜ï¼Œæ£€æŸ¥ä¸»æ ‡ç­¾é¡µçŠ¶æ€
      setTimeout(() => this.checkPrimaryStatus(), 100);
    }
  }
  
  private checkPrimaryStatus(): void {
    const tabList = this.getTabList();
    const sortedTabs = Object.entries(tabList).sort((a, b) => a[1] - b[1]);
    
    // æœ€æ—©åˆ›å»ºçš„æ ‡ç­¾é¡µæˆä¸ºä¸»æ ‡ç­¾é¡µ
    const primaryTab = sortedTabs[0];
    const wasPrimary = this.isPrimary;
    this.isPrimary = primaryTab && primaryTab[0] === this.tabId;
    
    if (this.isPrimary && !wasPrimary) {
      // æˆä¸ºæ–°çš„ä¸»æ ‡ç­¾é¡µ
      this.onBecamePrimary();
    } else if (!this.isPrimary && wasPrimary) {
      // å¤±å»ä¸»æ ‡ç­¾é¡µåœ°ä½
      this.onLostPrimary();
    }
  }
  
  private onBecamePrimary(): void {
    console.log('æ­¤æ ‡ç­¾é¡µæˆä¸ºä¸»æ ‡ç­¾é¡µ');
    
    // é€šçŸ¥å…¶ä»–æ ‡ç­¾é¡µ
    this.channel?.postMessage({
      type: 'PRIMARY_ASSIGNED',
      tabId: this.tabId,
      timestamp: Date.now()
    });
    
    // å¯ç”¨æ‰€æœ‰åŠŸèƒ½
    this.enableAllFeatures();
  }
  
  private onLostPrimary(): void {
    console.log('æ­¤æ ‡ç­¾é¡µå¤±å»ä¸»æ ‡ç­¾é¡µåœ°ä½');
    
    // ç¦ç”¨æŸäº›åŠŸèƒ½æˆ–æ˜¾ç¤ºæç¤º
    this.disableNonPrimaryFeatures();
  }
  
  private enableAllFeatures(): void {
    // å¯ç”¨æ¸¸æˆåŠŸèƒ½
    document.body.classList.remove('non-primary-tab');
    
    // å¯ä»¥ç»§ç»­æ¸¸æˆ
    window.dispatchEvent(new CustomEvent('becamePrimaryTab'));
  }
  
  private disableNonPrimaryFeatures(): void {
    // ç¦ç”¨æŸäº›åŠŸèƒ½
    document.body.classList.add('non-primary-tab');
    
    // æ˜¾ç¤ºæç¤ºä¿¡æ¯
    this.showNonPrimaryWarning();
    
    // æš‚åœæ¸¸æˆ
    window.dispatchEvent(new CustomEvent('lostPrimaryTab'));
  }
  
  private showNonPrimaryWarning(): void {
    // åˆ›å»ºè­¦å‘Šæç¤º
    const warning = document.createElement('div');
    warning.className = 'non-primary-warning';
    warning.innerHTML = `
      <div class="warning-content">
        <span>âš ï¸ æ¸¸æˆå·²åœ¨å…¶ä»–æ ‡ç­¾é¡µä¸­è¿è¡Œ</span>
        <button onclick="window.focusPrimaryTab()">åˆ‡æ¢åˆ°ä¸»æ ‡ç­¾é¡µ</button>
      </div>
    `;
    
    document.body.appendChild(warning);
    
    // æ·»åŠ æ ·å¼
    const style = document.createElement('style');
    style.textContent = `
      .non-primary-warning {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ff6b6b;
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        animation: slideInRight 0.3s ease;
      }
      
      .warning-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .warning-content button {
        background: white;
        color: #ff6b6b;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
      }
      
      .non-primary-tab {
        opacity: 0.7;
        pointer-events: none;
      }
      
      .non-primary-tab .game-container {
        filter: grayscale(0.5);
      }
      
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(style);
  }
  
  private updateTabList(): void {
    try {
      const tabList = this.getTabList();
      tabList[this.tabId] = Date.now();
      
      // æ¸…ç†è¿‡æœŸæ ‡ç­¾é¡µï¼ˆè¶…è¿‡30ç§’æœªæ›´æ–°ï¼‰
      const now = Date.now();
      Object.keys(tabList).forEach(tabId => {
        if (now - tabList[tabId] > 30000) {
          delete tabList[tabId];
        }
      });
      
      localStorage.setItem('game_tabs', JSON.stringify(tabList));
    } catch (error) {
      console.warn('æ›´æ–°æ ‡ç­¾é¡µåˆ—è¡¨å¤±è´¥:', error);
    }
  }
  
  private getTabList(): Record<string, number> {
    try {
      const stored = localStorage.getItem('game_tabs');
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      return {};
    }
  }
  
  private removeTab(): void {
    try {
      const tabList = this.getTabList();
      delete tabList[this.tabId];
      localStorage.setItem('game_tabs', JSON.stringify(tabList));
    } catch (error) {
      console.warn('ç§»é™¤æ ‡ç­¾é¡µå¤±è´¥:', error);
    }
  }
  
  private useFallbackMethod(): void {
    // ä½¿ç”¨localStorageä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
    setInterval(() => {
      this.updateTabList();
      this.checkPrimaryStatus();
    }, 1000);
  }
  
  public focusPrimaryTab(): void {
    // å°è¯•æˆä¸ºä¸»æ ‡ç­¾é¡µ
    this.checkPrimaryStatus();
    
    if (!this.isPrimary) {
      // ç§»é™¤å½“å‰æ ‡ç­¾é¡µå¹¶é‡æ–°åˆ›å»º
      this.removeTab();
      setTimeout(() => {
        this.declareTab();
        this.checkPrimaryStatus();
      }, 100);
    }
  }
  
  public isPrimaryTab(): boolean {
    return this.isPrimary;
  }
  
  public getTabId(): string {
    return this.tabId;
  }
}

// å…¨å±€å‡½æ•°ä¾›HTMLè°ƒç”¨
(window as any).focusPrimaryTab = () => {
  TabManager.getInstance().focusPrimaryTab();
};

// ä½¿ç”¨ç¤ºä¾‹
const tabManager = TabManager.getInstance();

// ç›‘å¬ä¸»æ ‡ç­¾é¡µå˜åŒ–
window.addEventListener('becamePrimaryTab', () => {
  console.log('æˆä¸ºä¸»æ ‡ç­¾é¡µï¼Œå¯ç”¨æ‰€æœ‰åŠŸèƒ½');
  // å¯ç”¨æ¸¸æˆåŠŸèƒ½
});

window.addEventListener('lostPrimaryTab', () => {
  console.log('å¤±å»ä¸»æ ‡ç­¾é¡µåœ°ä½ï¼Œç¦ç”¨åŠŸèƒ½');
  // ç¦ç”¨æ¸¸æˆåŠŸèƒ½
});
```

#### æ•°æ®æ¸…é™¤æœåŠ¡
```typescript
// dataClearService.ts
import { LogManager } from '../utils/logManager';
import type { ClearOptions, ClearResult } from '../types/deployment';

/**
 * æ•°æ®æ¸…é™¤æœåŠ¡
 */
export class DataClearService {
  private logManager: LogManager;
  
  constructor(logManager?: LogManager) {
    this.logManager = logManager || new LogManager();
  }
  
  /**
   * æ¸…é™¤æ¸¸æˆæ•°æ®
   */
  async clearGameData(options: ClearOptions): Promise<ClearResult> {
    const result: ClearResult = {
      success: true,
      clearedItems: [],
      errors: [],
      timestamp: Date.now()
    };
    
    try {
      this.logManager.info('å¼€å§‹æ¸…é™¤æ¸¸æˆæ•°æ®', options);
      
      // 1. æ¸…é™¤æ¸¸æˆè¿›åº¦
      if (options.clearProgress) {
        await this.clearProgress(result);
      }
      
      // 2. æ¸…é™¤è®¾ç½®
      if (options.clearSettings) {
        await this.clearSettings(result);
      }
      
      // 3. æ¸…é™¤ç¼“å­˜
      if (options.clearCache) {
        await this.clearCache(result);
      }
      
      // 4. æ¸…é™¤æ—¥å¿—
      if (options.clearLogs) {
        await this.clearLogs(result);
      }
      
      this.logManager.info('æ¸¸æˆæ•°æ®æ¸…é™¤å®Œæˆ', {
        clearedItems: result.clearedItems,
        errors: result.errors
      });
      
    } catch (error) {
      result.success = false;
      result.errors.push('æ•°æ®æ¸…é™¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯');
      this.logManager.error('æ•°æ®æ¸…é™¤å¤±è´¥', { error });
    }
    
    return result;
  }
  
  private async clearProgress(result: ClearResult): Promise<void> {
    try {
      // æ¸…é™¤localStorageä¸­çš„æ¸¸æˆæ•°æ®
      const gameKeys = Object.keys(localStorage).filter(key => 
        key.startsWith('game_') || key.startsWith('progress_')
      );
      
      gameKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // æ¸…é™¤sessionStorageä¸­çš„ä¸´æ—¶æ•°æ®
      const sessionKeys = Object.keys(sessionStorage).filter(key =>
        key.startsWith('game_') || key.startsWith('temp_')
      );
      
      sessionKeys.forEach(key => {
        sessionStorage.removeItem(key);
      });
      
      // æ¸…é™¤IndexedDBä¸­çš„æ•°æ®
      await this.clearIndexedDB();
      
      result.clearedItems.push('æ¸¸æˆè¿›åº¦');
      this.logManager.info('æ¸¸æˆè¿›åº¦æ¸…é™¤å®Œæˆ', { clearedKeys: gameKeys });
      
    } catch (error) {
      result.errors.push('æ¸…é™¤æ¸¸æˆè¿›åº¦å¤±è´¥');
      this.logManager.error('æ¸…é™¤æ¸¸æˆè¿›åº¦å¤±è´¥', { error });
    }
  }
  
  private async clearSettings(result: ClearResult): Promise<void> {
    try {
      // æ¸…é™¤è®¾ç½®ç›¸å…³çš„localStorage
      const settingKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('settings_') || key.startsWith('config_')
      );
      
      settingKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      result.clearedItems.push('æ¸¸æˆè®¾ç½®');
      this.logManager.info('æ¸¸æˆè®¾ç½®æ¸…é™¤å®Œæˆ', { clearedKeys: settingKeys });
      
    } catch (error) {
      result.errors.push('æ¸…é™¤æ¸¸æˆè®¾ç½®å¤±è´¥');
      this.logManager.error('æ¸…é™¤æ¸¸æˆè®¾ç½®å¤±è´¥', { error });
    }
  }
  
  private async clearCache(result: ClearResult): Promise<void> {
    try {
      // æ¸…é™¤ç¼“å­˜æ•°æ®
      const cacheKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('cache_') || key.includes('_cache')
      );
      
      cacheKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // å°è¯•æ¸…é™¤æµè§ˆå™¨ç¼“å­˜
      if ('caches' in window) {
        try {
          const cacheNames = await caches.keys();
          await Promise.all(cacheNames.map(name => caches.delete(name)));
          result.clearedItems.push('æµè§ˆå™¨ç¼“å­˜');
        } catch (error) {
          this.logManager.warn('æ¸…é™¤æµè§ˆå™¨ç¼“å­˜å¤±è´¥', { error });
        }
      }
      
      result.clearedItems.push('ç¼“å­˜æ•°æ®');
      this.logManager.info('ç¼“å­˜æ•°æ®æ¸…é™¤å®Œæˆ', { clearedKeys: cacheKeys });
      
    } catch (error) {
      result.errors.push('æ¸…é™¤ç¼“å­˜æ•°æ®å¤±è´¥');
      this.logManager.error('æ¸…é™¤ç¼“å­˜æ•°æ®å¤±è´¥', { error });
    }
  }
  
  private async clearLogs(result: ClearResult): Promise<void> {
    try {
      // æ¸…é™¤æ—¥å¿—ç®¡ç†å™¨çš„æ—¥å¿—
      await this.logManager.clearLogs();
      
      // æ¸…é™¤å…¶ä»–å¯èƒ½çš„æ—¥å¿—å­˜å‚¨
      const logKeys = Object.keys(localStorage).filter(key =>
        key.startsWith('log_') || key.includes('_log')
      );
      
      logKeys.forEach(key => {
        localStorage.removeItem(key);
      });
      
      result.clearedItems.push('æ—¥å¿—æ–‡ä»¶');
      this.logManager.info('æ—¥å¿—æ–‡ä»¶æ¸…é™¤å®Œæˆ', { clearedKeys: logKeys });
      
    } catch (error) {
      result.errors.push('æ¸…é™¤æ—¥å¿—æ–‡ä»¶å¤±è´¥');
      this.logManager.error('æ¸…é™¤æ—¥å¿—æ–‡ä»¶å¤±è´¥', { error });
    }
  }
  
  private async clearIndexedDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!window.indexedDB) {
        resolve();
        return;
      }
      
      const deleteRequests = [];
      
      // è·å–æ‰€æœ‰æ•°æ®åº“åç§°
      indexedDB.databases().then((databases) => {
        databases.forEach(db => {
          if (db.name) {
            const deleteRequest = indexedDB.deleteDatabase(db.name);
            deleteRequests.push(
              new Promise<void>((resolve, reject) => {
                deleteRequest.onsuccess = () => resolve();
                deleteRequest.onerror = () => reject(deleteRequest.error);
              })
            );
          }
        });
        
        Promise.all(deleteRequests).then(() => {
          this.logManager.info('IndexedDBæ¸…é™¤å®Œæˆ');
          resolve();
        }).catch((error) => {
          this.logManager.warn('éƒ¨åˆ†IndexedDBæ¸…é™¤å¤±è´¥', { error });
          resolve(); // ç»§ç»­æ‰§è¡Œï¼Œä¸é˜»å¡æ•´ä½“æµç¨‹
        });
      }).catch((error) => {
        this.logManager.warn('è·å–IndexedDBåˆ—è¡¨å¤±è´¥', { error });
        resolve();
      });
    });
  }
  
  /**
   * è·å–æ•°æ®å¤§å°ä¿¡æ¯
   */
  async getDataSizeInfo(): Promise<{
    totalSize: string;
    breakdown: Record<string, string>;
  }> {
    try {
      let totalSize = 0;
      const breakdown: Record<string, string> = {};
      
      // è®¡ç®—localStorageå¤§å°
      let localStorageSize = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key) {
          const value = localStorage.getItem(key);
          if (value) {
            localStorageSize += key.length + value.length;
          }
        }
      }
      totalSize += localStorageSize;
      breakdown.localStorage = this.formatBytes(localStorageSize);
      
      // è®¡ç®—sessionStorageå¤§å°
      let sessionStorageSize = 0;
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key) {
          const value = sessionStorage.getItem(key);
          if (value) {
            sessionStorageSize += key.length + value.length;
          }
        }
      }
      totalSize += sessionStorageSize;
      breakdown.sessionStorage = this.formatBytes(sessionStorageSize);
      
      // ä¼°ç®—IndexedDBå¤§å°ï¼ˆç²—ç•¥ä¼°è®¡ï¼‰
      try {
        const databases = await indexedDB.databases();
        breakdown.indexedDB = `${databases.length} ä¸ªæ•°æ®åº“`;
      } catch (error) {
        breakdown.indexedDB = 'æ— æ³•è·å–';
      }
      
      return {
        totalSize: this.formatBytes(totalSize),
        breakdown
      };
      
    } catch (error) {
      this.logManager.error('è·å–æ•°æ®å¤§å°ä¿¡æ¯å¤±è´¥', { error });
      return {
        totalSize: 'æœªçŸ¥',
        breakdown: {}
      };
    }
  }
  
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
```

#### æ€§èƒ½æµ‹è¯•å·¥å…·
```typescript
// performanceTester.ts
export class PerformanceTester {
  private metrics: PerformanceMetrics[] = [];
  
  /**
   * æµ‹è¯•åº”ç”¨å¯åŠ¨æ€§èƒ½
   */
  async testStartupPerformance(): Promise<PerformanceMetrics> {
    const startTime = performance.now();
    const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
    
    // æ¨¡æ‹Ÿåº”ç”¨å¯åŠ¨è¿‡ç¨‹
    await this.simulateAppStartup();
    
    const endTime = performance.now();
    const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
    const startupTime = endTime - startTime;
    const memoryUsage = endMemory - startMemory;
    
    return {
      startupTime,
      memoryUsage,
      diskUsage: 0, // éœ€è¦é¢å¤–è®¡ç®—
      bundleSize: 0, // éœ€è¦é¢å¤–è®¡ç®—
      launchTime: startupTime
    };
  }
  
  /**
   * æµ‹è¯•å†…å­˜ä½¿ç”¨
   */
  async testMemoryUsage(): Promise<number> {
    if (!(performance as any).memory) {
      console.warn('å½“å‰ç¯å¢ƒä¸æ”¯æŒå†…å­˜ç›‘æ§');
      return 0;
    }
    
    return (performance as any).memory.usedJSHeapSize;
  }
  
  /**
   * æ¨¡æ‹Ÿåº”ç”¨å¯åŠ¨
   */
  private async simulateAppStartup(): Promise<void> {
    // æ¨¡æ‹Ÿå„ç§å¯åŠ¨ä»»åŠ¡
    await this.delay(100); // åˆå§‹åŒ–
    await this.delay(50);  // åŠ è½½é…ç½®
    await this.delay(150); // åˆå§‹åŒ–ç»„ä»¶
    await this.delay(100); // æ¸²æŸ“ç•Œé¢
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * è¿è¡Œå®Œæ•´æ€§èƒ½æµ‹è¯•
   */
  async runFullPerformanceTest(): Promise<{
    startup: PerformanceMetrics;
    memory: number;
    recommendations: string[];
  }> {
    console.log('å¼€å§‹æ€§èƒ½æµ‹è¯•...');
    
    const startup = await this.testStartupPerformance();
    const memory = await this.testMemoryUsage();
    
    const recommendations = this.generateRecommendations(startup, memory);
    
    return {
      startup,
      memory,
      recommendations
    };
  }
  
  private generateRecommendations(
    startup: PerformanceMetrics,
    memory: number
  ): string[] {
    const recommendations: string[] = [];
    
    if (startup.startupTime > 3000) {
      recommendations.push('å¯åŠ¨æ—¶é—´è¶…è¿‡3ç§’ï¼Œå»ºè®®ä¼˜åŒ–åˆå§‹åŒ–æµç¨‹');
    }
    
    if (memory > 500 * 1024 * 1024) { // 500MB
      recommendations.push('å†…å­˜ä½¿ç”¨è¶…è¿‡500MBï¼Œå»ºè®®æ£€æŸ¥å†…å­˜æ³„æ¼');
    }
    
    if (startup.memoryUsage > 100 * 1024 * 1024) { // 100MB
      recommendations.push('å¯åŠ¨å†…å­˜å¢åŠ è¶…è¿‡100MBï¼Œå»ºè®®ä¼˜åŒ–èµ„æºåŠ è½½');
    }
    
    return recommendations;
  }
}
```

#### å…¼å®¹æ€§æµ‹è¯•å·¥å…·
```typescript
// compatibilityTester.ts
export class CompatibilityTester {
  private results: CompatibilityResult[] = [];
  
  /**
   * è¿è¡Œå…¼å®¹æ€§æµ‹è¯•
   */
  async runCompatibilityTest(): Promise<CompatibilityResult[]> {
    this.results = [];
    
    // æµ‹è¯•å„é¡¹åŠŸèƒ½
    await this.testBrowserFeatures();
    await this.testStorageFeatures();
    await this.testPerformanceFeatures();
    await this.testElectronFeatures();
    
    return this.results;
  }
  
  private async testBrowserFeatures(): Promise<void> {
    const features = [
      { name: 'localStorage', test: () => typeof Storage !== 'undefined' },
      { name: 'sessionStorage', test: () => typeof sessionStorage !== 'undefined' },
      { name: 'IndexedDB', test: () => typeof indexedDB !== 'undefined' },
      { name: 'BroadcastChannel', test: () => typeof BroadcastChannel !== 'undefined' },
      { name: 'CSS Grid', test: () => CSS.supports('display', 'grid') },
      { name: 'CSS Flexbox', test: () => CSS.supports('display', 'flex') },
      { name: 'ES6 Promises', test: () => typeof Promise !== 'undefined' },
      { name: 'ES6 Arrow Functions', test: () => {
        try {
          eval('(() => {})');
          return true;
        } catch {
          return false;
        }
      }}
    ];
    
    for (const feature of features) {
      const passed = feature.test();
      this.results.push({
        platform: 'Browser',
        version: feature.name,
        passed,
        issues: passed ? [] : [`ä¸æ”¯æŒ ${feature.name}`],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testStorageFeatures(): Promise<void> {
    try {
      // æµ‹è¯•localStorage
      const testKey = 'compatibility_test';
      const testValue = 'test_value';
      localStorage.setItem(testKey, testValue);
      const retrieved = localStorage.getItem(testKey);
      localStorage.removeItem(testKey);
      
      this.results.push({
        platform: 'Storage',
        version: 'localStorage',
        passed: retrieved === testValue,
        issues: retrieved === testValue ? [] : ['localStorageè¯»å†™å¤±è´¥'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
      
      // æµ‹è¯•å­˜å‚¨é…é¢
      const quotaResult = await this.testStorageQuota();
      this.results.push(quotaResult);
      
    } catch (error) {
      this.results.push({
        platform: 'Storage',
        version: 'Basic Storage',
        passed: false,
        issues: ['å­˜å‚¨åŠŸèƒ½æµ‹è¯•å¤±è´¥'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testStorageQuota(): Promise<CompatibilityResult> {
    try {
      if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        const usage = estimate.usage || 0;
        const quota = estimate.quota || 0;
        const usageRatio = usage / quota;
        
        return {
          platform: 'Storage',
          version: 'Storage API',
          passed: true,
          issues: usageRatio > 0.9 ? ['å­˜å‚¨ç©ºé—´ä½¿ç”¨ç‡è¶…è¿‡90%'] : [],
          performance: {
            startupTime: 0,
            memoryUsage: usage,
            diskUsage: quota,
            bundleSize: 0,
            launchTime: 0
          }
        };
      }
      
      return {
        platform: 'Storage',
        version: 'Storage API',
        passed: false,
        issues: ['Storage APIä¸æ”¯æŒ'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      };
    } catch (error) {
      return {
        platform: 'Storage',
        version: 'Storage API',
        passed: false,
        issues: ['å­˜å‚¨é…é¢æµ‹è¯•å¤±è´¥'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      };
    }
  }
  
  private async testPerformanceFeatures(): Promise<void> {
    try {
      // æµ‹è¯•æ€§èƒ½API
      const hasPerformanceAPI = typeof performance !== 'undefined';
      const hasMemoryAPI = hasPerformanceAPI && 'memory' in performance;
      
      this.results.push({
        platform: 'Performance',
        version: 'Performance API',
        passed: hasPerformanceAPI,
        issues: hasPerformanceAPI ? [] : ['Performance APIä¸æ”¯æŒ'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
      
      if (hasMemoryAPI) {
        this.results.push({
          platform: 'Performance',
          version: 'Memory API',
          passed: true,
          issues: [],
          performance: {
            startupTime: 0,
            memoryUsage: (performance as any).memory?.usedJSHeapSize || 0,
            diskUsage: 0,
            bundleSize: 0,
            launchTime: 0
          }
        });
      }
      
    } catch (error) {
      this.results.push({
        platform: 'Performance',
        version: 'Performance Features',
        passed: false,
        issues: ['æ€§èƒ½APIæµ‹è¯•å¤±è´¥'],
        performance: {
          startupTime: 0,
          memoryUsage: 0,
          diskUsage: 0,
          bundleSize: 0,
          launchTime: 0
        }
      });
    }
  }
  
  private async testElectronFeatures(): Promise<void> {
    // æ£€æµ‹æ˜¯å¦åœ¨Electronç¯å¢ƒä¸­
    const isElectron = this.isElectronEnvironment();
    
    this.results.push({
      platform: 'Electron',
      version: 'Environment',
      passed: isElectron,
      issues: isElectron ? [] : ['ä¸åœ¨Electronç¯å¢ƒä¸­'],
      performance: {
        startupTime: 0,
        memoryUsage: 0,
        diskUsage: 0,
        bundleSize: 0,
        launchTime: 0
      }
    });
    
    if (isElectron) {
      // æµ‹è¯•Electronç‰¹å®šåŠŸèƒ½
      const electronFeatures = [
        { name: 'Node.js', test: () => typeof process !== 'undefined' },
        { name: 'File System', test: () => {
          try {
            // @ts-ignore
            return typeof require !== 'undefined' && require('fs');
          } catch {
            return false;
          }
        }},
        { name: 'IPC', test: () => {
          try {
            // @ts-ignore
            return typeof require !== 'undefined' && require('electron').ipcRenderer;
          } catch {
            return false;
          }
        }}
      ];
      
      for (const feature of electronFeatures) {
        const passed = feature.test();
        this.results.push({
          platform: 'Electron',
          version: feature.name,
          passed,
          issues: passed ? [] : [`ä¸æ”¯æŒ ${feature.name}`],
          performance: {
            startupTime: 0,
            memoryUsage: 0,
            diskUsage: 0,
            bundleSize: 0,
            launchTime: 0
          }
        });
      }
    }
  }
  
  private isElectronEnvironment(): boolean {
    return typeof process !== 'undefined' && 
           process.versions != null && 
           process.versions.electron != null;
  }
  
  /**
   * ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š
   */
  generateReport(): {
    summary: {
      total: number;
      passed: number;
      failed: number;
      passRate: number;
    };
    criticalIssues: string[];
    recommendations: string[];
    details: CompatibilityResult[];
  } {
    const total = this.results.length;
    const passed = this.results.filter(r => r.passed).length;
    const failed = total - passed;
    const passRate = total > 0 ? (passed / total) * 100 : 0;
    
    const criticalIssues = this.results
      .filter(r => !r.passed)
      .flatMap(r => r.issues)
      .filter(issue => issue.includes('ä¸æ”¯æŒ'));
    
    const recommendations = this.generateRecommendations(criticalIssues);
    
    return {
      summary: {
        total,
        passed,
        failed,
        passRate
      },
      criticalIssues,
      recommendations,
      details: this.results
    };
  }
  
  private generateRecommendations(issues: string[]): string[] {
    const recommendations: string[] = [];
    
    if (issues.some(issue => issue.includes('localStorage'))) {
      recommendations.push('å»ºè®®ä½¿ç”¨ç°ä»£æµè§ˆå™¨æˆ–å¯ç”¨æœ¬åœ°å­˜å‚¨åŠŸèƒ½');
    }
    
    if (issues.some(issue => issue.includes('IndexedDB'))) {
      recommendations.push('è€ƒè™‘ä½¿ç”¨localStorageä½œä¸ºæ•°æ®å­˜å‚¨å¤‡é€‰æ–¹æ¡ˆ');
    }
    
    if (issues.some(issue => issue.includes('BroadcastChannel'))) {
      recommendations.push('å¤šæ ‡ç­¾é¡µåŠŸèƒ½å¯èƒ½å—é™ï¼Œå»ºè®®ä½¿ç”¨localStorageå¤‡ç”¨æ–¹æ¡ˆ');
    }
    
    if (issues.some(issue => issue.includes('CSS Grid'))) {
      recommendations.push('å»ºè®®ä½¿ç”¨CSS Flexboxä½œä¸ºå¸ƒå±€å¤‡é€‰æ–¹æ¡ˆ');
    }
    
    if (issues.some(issue => issue.includes('ES6'))) {
      recommendations.push('å»ºè®®ä½¿ç”¨Babelè½¬è¯‘ä»¥æ”¯æŒæ—§ç‰ˆæµè§ˆå™¨');
    }
    
    return recommendations;
  }
}
```

#### æ‰“åŒ…éƒ¨ç½²è„šæœ¬
```typescript
// build.ts
import { build } from 'electron-builder';
import { electronConfig, builderConfig } from './config/electron.config';

/**
 * æ„å»ºElectronåº”ç”¨
 */
export async function buildElectronApp(): Promise<void> {
  try {
    console.log('ğŸš€ å¼€å§‹æ„å»ºElectronåº”ç”¨...');
    
    // æ„å»ºReactåº”ç”¨
    console.log('ğŸ“¦ æ„å»ºReactåº”ç”¨...');
    await buildReactApp();
    
    // æ„å»ºElectronåº”ç”¨
    console.log('ğŸ”§ æ„å»ºElectronåº”ç”¨...');
    await build({
      config: builderConfig,
      win: ['nsis'],
      x64: true,
      ia32: false,
      publish: 'never'
    });
    
    console.log('âœ… Electronåº”ç”¨æ„å»ºå®Œæˆ');
    
  } catch (error) {
    console.error('âŒ æ„å»ºå¤±è´¥:', error);
    throw error;
  }
}

/**
 * æ„å»ºReactåº”ç”¨
 */
async function buildReactApp(): Promise<void> {
  return new Promise((resolve, reject) => {
    const { exec } = require('child_process');
    
    exec('npm run build', (error: Error, stdout: string, stderr: string) => {
      if (error) {
        console.error('Reactæ„å»ºå¤±è´¥:', stderr);
        reject(error);
      } else {
        console.log('Reactæ„å»ºå®Œæˆ:', stdout);
        resolve();
      }
    });
  });
}

/**
 * è¿è¡Œæ€§èƒ½æµ‹è¯•
 */
export async function runPerformanceTest(): Promise<void> {
  const { PerformanceTester } = await import('./utils/performanceTester');
  const tester = new PerformanceTester();
  
  console.log('ğŸƒ è¿è¡Œæ€§èƒ½æµ‹è¯•...');
  const results = await tester.runFullPerformanceTest();
  
  console.log('ğŸ“Š æ€§èƒ½æµ‹è¯•ç»“æœ:');
  console.log('å¯åŠ¨æ—¶é—´:', results.startup.startupTime, 'ms');
  console.log('å†…å­˜ä½¿ç”¨:', results.memory, 'bytes');
  console.log('ä¼˜åŒ–å»ºè®®:', results.recommendations);
}

/**
 * è¿è¡Œå…¼å®¹æ€§æµ‹è¯•
 */
export async function runCompatibilityTest(): Promise<void> {
  const { CompatibilityTester } = await import('./utils/compatibilityTester');
  const tester = new CompatibilityTester();
  
  console.log('ğŸ” è¿è¡Œå…¼å®¹æ€§æµ‹è¯•...');
  await tester.runCompatibilityTest();
  const report = tester.generateReport();
  
  console.log('ğŸ“‹ å…¼å®¹æ€§æŠ¥å‘Š:');
  console.log(`æ€»è®¡: ${report.summary.total} é¡¹`);
  console.log(`é€šè¿‡: ${report.summary.passed} é¡¹`);
  console.log(`å¤±è´¥: ${report.summary.failed} é¡¹`);
  console.log(`é€šè¿‡ç‡: ${report.summary.passRate.toFixed(1)}%`);
  
  if (report.criticalIssues.length > 0) {
    console.log('âš ï¸ å…³é”®é—®é¢˜:', report.criticalIssues);
  }
  
  if (report.recommendations.length > 0) {
    console.log('ğŸ’¡ å»ºè®®:', report.recommendations);
  }
}

/**
 * å®Œæ•´æ„å»ºæµç¨‹
 */
export async function fullBuildProcess(): Promise<void> {
  console.log('ğŸ¯ å¼€å§‹å®Œæ•´æ„å»ºæµç¨‹...');
  
  try {
    // 1. è¿è¡Œå…¼å®¹æ€§æµ‹è¯•
    await runCompatibilityTest();
    
    // 2. è¿è¡Œæ€§èƒ½æµ‹è¯•
    await runPerformanceTest();
    
    // 3. æ„å»ºåº”ç”¨
    await buildElectronApp();
    
    console.log('ğŸ‰ æ„å»ºæµç¨‹å®Œæˆ');
    
  } catch (error) {
    console.error('æ„å»ºæµç¨‹å¤±è´¥:', error);
    throw error;
  }
}
```