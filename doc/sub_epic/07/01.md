# Epic7-子任务01: 游戏核心流程集成

## 开发状态
已测试 → 子任务开发完成

## 开发方案

### 1. 开发目标
集成所有核心模块，实现完整的7天游戏流程，确保端到端功能正常运作。建立统一的游戏流程控制器，管理从游戏初始化到通关/死亡的完整生命周期。

### 2. 设计方案
采用分层架构设计：
- **流程控制层**：统一的游戏状态机和流程管理
- **模块集成层**：各Epic模块的接口适配和协调
- **错误处理层**：全局错误捕获和恢复机制
- **用户体验层**：流畅的界面过渡和反馈

### 3. 实现方式

#### 3.1 游戏流程控制器核心架构
```typescript
// src/types/gameFlow.ts
import { GameState, GameAction } from './gameState';
import { GameSaveData } from './storage';
import { StoryData, ParseError } from './parser';
import { ProvinceData } from './map';

export interface GameFlowController {
  // 游戏生命周期管理
  initializeGame(config: GameConfig): Promise<InitializationResult>;
  startNewGame(playerInfo: PlayerInfo): Promise<GameStartResult>;
  loadExistingGame(saveData: GameSaveData): Promise<GameLoadResult>;
  
  // 核心游戏流程
  processPlayerChoice(choiceId: string, context: ChoiceContext): Promise<ChoiceResult>;
  advanceToNextDay(day: number): Promise<DayAdvanceResult>;
  completeCurrentDay(completion: DayCompletion): Promise<DayCompletionResult>;
  
  // 状态检查和验证
  validateGameState(): ValidationResult;
  checkWinConditions(): WinConditionResult;
  checkDeathConditions(): DeathConditionResult;
  
  // 游戏结束处理
  handleGameEnd(reason: GameEndReason): Promise<GameEndResult>;
  generateGameSummary(): GameSummary;
  
  // 错误处理和恢复
  handleError(error: GameFlowError): ErrorHandlingResult;
  recoverFromError(state: RecoveryState): Promise<RecoveryResult>;
}

export interface GameConfig {
  // 基础配置
  debugMode: boolean;
  autoSaveInterval: number;
  maxSaveSlots: number;
  
  // 游戏参数
  startingAttributes: Partial<GameState>;
  professionModifiers: Record<string, AttributeModifiers>;
  
  // 性能设置
  enableAnimations: boolean;
  enableSound: boolean;
  qualityPreset: 'low' | 'medium' | 'high';
}

export interface PlayerInfo {
  name: string;
  profession: string;
  province: string;
  customAttributes?: Partial<GameState>;
}

export interface InitializationResult {
  success: boolean;
  gameId: string;
  initializedModules: string[];
  errors: FlowError[];
  warnings: FlowWarning[];
}

export interface ChoiceResult {
  success: boolean;
  newState: GameState;
  storyText?: string;
  availableChoices?: string[];
  effects: ChoiceEffect[];
  nextNode?: string;
  errors: FlowError[];
}

export interface DayAdvanceResult {
  success: boolean;
  newDay: number;
  newNode: string;
  storyData?: StoryData;
  unlockedContent: string[];
  errors: FlowError[];
}

export interface WinConditionResult {
  hasWon: boolean;
  winLevel?: 'S' | 'A' | 'B' | 'C';
  triggeredConditions: string[];
  score: number;
  message: string;
}

export interface DeathConditionResult {
  hasDied: boolean;
  deathReason?: string;
  triggeredConditions: string[];
  message: string;
  canContinue?: boolean;
}

export interface GameEndResult {
  success: boolean;
  endType: 'victory' | 'defeat' | 'abandon' | 'error';
  finalState: GameState;
  summary: GameSummary;
  achievements: string[];
  saveData?: GameSaveData;
}

export interface FlowError {
  type: 'initialization' | 'parsing' | 'state' | 'storage' | 'validation';
  code: string;
  message: string;
  severity: 'critical' | 'error' | 'warning' | 'info';
  context?: Record<string, any>;
  recoverable: boolean;
}

export interface GameFlowError extends Error {
  flowError: FlowError;
  originalError?: Error;
}
```

#### 3.2 核心流程控制器实现
```typescript
// src/utils/gameFlowController.ts
import { GameFlowController, GameConfig, PlayerInfo } from '../types/gameFlow';
import { GameState, GameAction } from '../types/gameState';
import { GameSaveData } from '../types/storage';
import { StoryData, ParseError } from '../types/parser';
import { StorageManager } from './storageManager';
import { PythonScriptParser } from './pythonScriptParser';
import { gameReducer, initialGameState } from './gameReducer';
import { CHINA_PROVINCES } from '../data/chinaProvinces';

export class GameFlowControllerImpl implements GameFlowController {
  private storage: StorageManager;
  private parser: PythonScriptParser;
  private currentState: GameState;
  private gameConfig: GameConfig;
  private storyCache: Map<number, StoryData>;
  private errorLog: FlowError[];
  private isInitialized: boolean;

  constructor(config: GameConfig) {
    this.storage = new StorageManager({
      storageKey: 'rulegame_save',
      maxSaveSlots: config.maxSaveSlots,
      autoSaveInterval: config.autoSaveInterval,
      compressionEnabled: true
    });
    
    this.parser = new PythonScriptParser();
    this.currentState = { ...initialGameState };
    this.gameConfig = config;
    this.storyCache = new Map();
    this.errorLog = [];
    this.isInitialized = false;
  }

  /**
   * 初始化游戏系统
   */
  async initializeGame(config: GameConfig): Promise<InitializationResult> {
    try {
      this.logInfo('Initializing game system...');
      
      // 1. 验证配置
      const validationResult = this.validateConfiguration(config);
      if (!validationResult.isValid) {
        throw this.createFlowError('initialization', 'INVALID_CONFIG', 
          'Configuration validation failed', validationResult.errors);
      }

      // 2. 初始化存储系统
      await this.initializeStorage();
      
      // 3. 预加载故事数据
      await this.preloadStoryData();
      
      // 4. 验证省份数据
      this.validateProvinceData();
      
      this.isInitialized = true;
      this.gameConfig = config;
      
      this.logInfo('Game system initialized successfully');
      
      return {
        success: true,
        gameId: this.generateGameId(),
        initializedModules: ['storage', 'parser', 'state', 'provinces'],
        errors: [],
        warnings: validationResult.warnings
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        gameId: '',
        initializedModules: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * 开始新游戏
   */
  async startNewGame(playerInfo: PlayerInfo): Promise<GameStartResult> {
    if (!this.isInitialized) {
      throw this.createFlowError('initialization', 'NOT_INITIALIZED', 
        'Game system not initialized');
    }

    try {
      this.logInfo(`Starting new game for player: ${playerInfo.name}`);
      
      // 1. 验证玩家信息
      const validationResult = this.validatePlayerInfo(playerInfo);
      if (!validationResult.isValid) {
        throw this.createFlowError('initialization', 'INVALID_PLAYER_INFO', 
          'Player info validation failed', validationResult.errors);
      }

      // 2. 创建新的游戏状态
      const newGameState = this.createNewGameState(playerInfo);
      
      // 3. 加载第一天故事数据
      const day1Story = await this.loadStoryData(1);
      
      // 4. 初始化游戏状态
      this.currentState = {
        ...newGameState,
        currentDay: 1,
        currentNode: 'start',
        gameStatus: 'playing',
        playerName: playerInfo.name,
        selectedProfession: playerInfo.profession,
        selectedProvince: playerInfo.province,
        profession: playerInfo.profession
      };

      // 5. 保存初始存档
      await this.saveGame();
      
      this.logInfo(`New game started successfully for ${playerInfo.name}`);
      
      return {
        success: true,
        initialState: this.currentState,
        storyData: day1Story,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        initialState: this.currentState,
        storyData: null,
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * 处理玩家选择
   */
  async processPlayerChoice(choiceId: string, context: ChoiceContext): Promise<ChoiceResult> {
    try {
      this.logInfo(`Processing choice: ${choiceId}`);
      
      // 1. 验证选择有效性
      const validation = this.validateChoice(choiceId, context);
      if (!validation.isValid) {
        throw this.createFlowError('validation', 'INVALID_CHOICE', 
          'Choice validation failed', validation.errors);
      }

      // 2. 获取当前故事数据
      const currentStory = await this.loadStoryData(this.currentState.currentDay);
      if (!currentStory) {
        throw this.createFlowError('parsing', 'STORY_NOT_FOUND', 
          `Story data not found for day ${this.currentState.currentDay}`);
      }

      // 3. 查找对应的选择
      const choice = currentStory.choices.find(c => c.id === choiceId);
      if (!choice) {
        throw this.createFlowError('validation', 'CHOICE_NOT_FOUND', 
          `Choice not found: ${choiceId}`);
      }

      // 4. 验证选择条件
      if (choice.conditions && choice.conditions.length > 0) {
        const conditionResult = this.evaluateChoiceConditions(choice.conditions);
        if (!conditionResult.passed) {
          return {
            success: false,
            newState: this.currentState,
            effects: [],
            errors: [{
              type: 'validation',
              code: 'CONDITION_NOT_MET',
              message: 'Choice conditions not met',
              severity: 'warning',
              recoverable: true
            }],
            warnings: []
          };
        }
      }

      // 5. 应用选择效果
      const effects = this.applyChoiceEffects(choice);
      
      // 6. 更新游戏状态
      const newState = this.updateStateFromChoice(choice, effects);
      this.currentState = newState;

      // 7. 记录选择历史
      this.recordChoice(choice, effects);

      // 8. 检查游戏结束条件
      const winResult = this.checkWinConditions();
      const deathResult = this.checkDeathConditions();

      let result: ChoiceResult = {
        success: true,
        newState: this.currentState,
        storyText: choice.text,
        effects,
        errors: [],
        warnings: []
      };

      // 9. 处理游戏结束
      if (winResult.hasWon) {
        await this.handleGameEnd({ type: 'victory', winResult });
      } else if (deathResult.hasDied) {
        await this.handleGameEnd({ type: 'defeat', deathResult });
      } else if (choice.nextSection) {
        result.nextNode = choice.nextSection;
        await this.advanceToNode(choice.nextSection);
      }

      // 10. 自动保存
      if (this.gameConfig.autoSaveInterval > 0) {
        await this.saveGame();
      }

      return result;
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        newState: this.currentState,
        effects: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * 推进到下一天
   */
  async advanceToNextDay(day: number): Promise<DayAdvanceResult> {
    try {
      this.logInfo(`Advancing to day ${day}`);
      
      // 1. 验证天数有效性
      if (day < 1 || day > 7) {
        throw this.createFlowError('validation', 'INVALID_DAY', 
          `Invalid day number: ${day}`);
      }

      // 2. 检查前置条件
      if (day > this.currentState.currentDay + 1) {
        throw this.createFlowError('validation', 'DAY_NOT_UNLOCKED', 
          `Day ${day} is not unlocked yet`);
      }

      // 3. 加载新的一天故事数据
      const storyData = await this.loadStoryData(day);
      if (!storyData) {
        throw this.createFlowError('parsing', 'STORY_NOT_FOUND', 
          `Story data not found for day ${day}`);
      }

      // 4. 更新游戏状态
      const newState = {
        ...this.currentState,
        currentDay: day,
        currentNode: 'start',
        availableDays: new Set([...this.currentState.availableDays, day])
      };

      this.currentState = newState;

      // 5. 解锁新内容
      const unlockedContent = this.unlockContentForDay(day);

      this.logInfo(`Advanced to day ${day} successfully`);

      return {
        success: true,
        newDay: day,
        newNode: 'start',
        storyData,
        unlockedContent,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        newDay: this.currentState.currentDay,
        newNode: this.currentState.currentNode,
        storyData: null,
        unlockedContent: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * 完成当前天数
   */
  async completeCurrentDay(completion: DayCompletion): Promise<DayCompletionResult> {
    try {
      this.logInfo(`Completing day ${completion.day}`);
      
      // 1. 验证完成信息
      if (completion.day !== this.currentState.currentDay) {
        throw this.createFlowError('validation', 'DAY_MISMATCH', 
          `Completion day ${completion.day} does not match current day ${this.currentState.currentDay}`);
      }

      // 2. 评估完成情况
      const evaluation = this.evaluateDayCompletion(completion);
      
      // 3. 更新游戏状态
      const newCompletedDays = new Set([...this.currentState.completedDays, completion.day]);
      const newAvailableDays = new Set([...this.currentState.availableDays]);
      
      if (completion.success && completion.day < 7) {
        newAvailableDays.add(completion.day + 1);
      }

      this.currentState = {
        ...this.currentState,
        completedDays: newCompletedDays,
        availableDays: newAvailableDays,
        gameStatus: completion.success ? 'playing' : 'failed'
      };

      // 4. 保存进度
      await this.saveGame();

      // 5. 检查游戏结束
      let gameEndResult: GameEndResult | null = null;
      if (completion.day === 7 && completion.success) {
        gameEndResult = await this.handleGameEnd({ 
          type: 'victory', 
          winResult: { level: completion.endingType || 'C' } 
        });
      } else if (!completion.success && completion.endingType === 'death') {
        gameEndResult = await this.handleGameEnd({ 
          type: 'defeat', 
          deathResult: { reason: completion.summary || 'Day completion failed' } 
        });
      }

      this.logInfo(`Day ${completion.day} completed with success: ${completion.success}`);

      return {
        success: true,
        completion,
        evaluation,
        gameEndResult,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        completion,
        evaluation: null,
        gameEndResult: null,
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * 检查胜利条件
   */
  checkWinConditions(): WinConditionResult {
    try {
      const state = this.currentState;
      const triggeredConditions: string[] = [];
      let score = 0;
      let winLevel: 'S' | 'A' | 'B' | 'C' | undefined;

      // S级通关条件：完美通关
      if (this.checkSLevelConditions(state)) {
        winLevel = 'S';
        score = 1000;
        triggeredConditions.push('perfect_completion', 'all_rules_correct', 'max_attributes');
      }
      // A级通关条件：优秀通关
      else if (this.checkALevelConditions(state)) {
        winLevel = 'A';
        score = 800;
        triggeredConditions.push('good_completion', 'most_rules_correct', 'high_attributes');
      }
      // B级通关条件：良好通关
      else if (this.checkBLevelConditions(state)) {
        winLevel = 'B';
        score = 600;
        triggeredConditions.push('decent_completion', 'some_rules_correct', 'medium_attributes');
      }
      // C级通关条件：基础通关
      else if (this.checkCLevelConditions(state)) {
        winLevel = 'C';
        score = 400;
        triggeredConditions.push('basic_completion', 'survived_all_days');
      }

      return {
        hasWon: winLevel !== undefined,
        winLevel,
        triggeredConditions,
        score,
        message: winLevel ? `恭喜获得${winLevel}级通关！` : '继续努力，争取通关！'
      };
      
    } catch (error) {
      this.logError('Error checking win conditions', error);
      return {
        hasWon: false,
        triggeredConditions: [],
        score: 0,
        message: '条件检查失败'
      };
    }
  }

  /**
   * 检查死亡条件
   */
  checkDeathConditions(): DeathConditionResult {
    try {
      const state = this.currentState;
      const triggeredConditions: string[] = [];
      let hasDied = false;
      let deathReason: string | undefined;

      // 检查属性死亡条件
      if (state.sanity <= 0) {
        hasDied = true;
        deathReason = '精神崩溃';
        triggeredConditions.push('sanity_zero');
      } else if (state.energy <= 0) {
        hasDied = true;
        deathReason = '体力耗尽';
        triggeredConditions.push('energy_zero');
      } else if (state.hunger <= 0) {
        hasDied = true;
        deathReason = '饥饿致死';
        triggeredConditions.push('hunger_zero');
      }

      // 检查时间死亡条件
      if (state.time >= 240) { // 4小时 = 240分钟
        hasDied = true;
        deathReason = '时间耗尽';
        triggeredConditions.push('time_exceeded');
      }

      // 检查特殊死亡条件
      if (this.checkSpecialDeathConditions(state)) {
        hasDied = true;
        deathReason = '触发特殊死亡条件';
        triggeredConditions.push('special_death');
      }

      return {
        hasDied,
        deathReason,
        triggeredConditions,
        message: hasDied ? `游戏结束：${deathReason}` : '生存状态良好',
        canContinue: !hasDied
      };
      
    } catch (error) {
      this.logError('Error checking death conditions', error);
      return {
        hasDied: false,
        triggeredConditions: [],
        message: '死亡条件检查失败',
        canContinue: true
      };
    }
  }

  /**
   * 处理游戏结束
   */
  async handleGameEnd(reason: GameEndReason): Promise<GameEndResult> {
    try {
      this.logInfo(`Game ending: ${reason.type}`);
      
      // 1. 生成游戏总结
      const summary = this.generateGameSummary();
      
      // 2. 计算成就
      const achievements = this.calculateAchievements(reason);
      
      // 3. 更新最终状态
      let finalStatus: GameState['gameStatus'];
      switch (reason.type) {
        case 'victory':
          finalStatus = 'completed';
          break;
        case 'defeat':
          finalStatus = 'failed';
          break;
        case 'abandon':
          finalStatus = 'abandoned';
          break;
        default:
          finalStatus = 'error';
      }

      this.currentState = {
        ...this.currentState,
        gameStatus: finalStatus
      };

      // 4. 创建最终存档
      const saveData = await this.createFinalSaveData();
      
      // 5. 清理资源
      await this.cleanup();

      this.logInfo(`Game ended with type: ${reason.type}`);

      return {
        success: true,
        endType: reason.type,
        finalState: this.currentState,
        summary,
        achievements,
        saveData
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        endType: 'error',
        finalState: this.currentState,
        summary: this.generateGameSummary(),
        achievements: [],
        saveData: undefined
      };
    }
  }

  /**
   * 错误处理
   */
  handleError(error: Error): ErrorHandlingResult {
    const flowError: FlowError = {
      type: 'validation',
      code: 'UNKNOWN_ERROR',
      message: error.message,
      severity: 'error',
      recoverable: true,
      context: { stack: error.stack }
    };

    this.errorLog.push(flowError);
    this.logError('Game flow error', error);

    return {
      success: false,
      flowError,
      originalError: error,
      canRecover: flowError.recoverable
    };
  }

  /**
   * 从错误中恢复
   */
  async recoverFromError(state: RecoveryState): Promise<RecoveryResult> {
    try {
      this.logInfo('Attempting error recovery...');
      
      // 1. 尝试从最后存档恢复
      if (state.lastSaveData) {
        const loadResult = await this.loadExistingGame(state.lastSaveData);
        if (loadResult.success) {
          return {
            success: true,
            recoveredState: this.currentState,
            recoveryMethod: 'from_save'
          };
        }
      }

      // 2. 尝试重置到安全状态
      if (state.safeState) {
        this.currentState = state.safeState;
        return {
          success: true,
          recoveredState: this.currentState,
          recoveryMethod: 'to_safe_state'
        };
      }

      // 3. 重置到初始状态
      this.currentState = { ...initialGameState };
      return {
        success: true,
        recoveredState: this.currentState,
        recoveryMethod: 'to_initial'
      };
      
    } catch (recoveryError) {
      this.logError('Error recovery failed', recoveryError);
      return {
        success: false,
        recoveredState: this.currentState,
        recoveryMethod: 'failed'
      };
    }
  }

  // 私有辅助方法
  private validateConfiguration(config: GameConfig): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (config.maxSaveSlots < 1 || config.maxSaveSlots > 10) {
      errors.push('maxSaveSlots must be between 1 and 10');
    }

    if (config.autoSaveInterval < 0) {
      errors.push('autoSaveInterval cannot be negative');
    }

    if (config.qualityPreset && !['low', 'medium', 'high'].includes(config.qualityPreset)) {
      warnings.push('Unknown quality preset, using medium');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  private async initializeStorage(): Promise<void> {
    try {
      // 验证存储系统可用性
      const testData = { test: true, timestamp: Date.now() };
      await this.storage.save({
        version: '1.0.0',
        playerName: '__test__',
        profession: '学生',
        gameState: initialGameState,
        rulePapers: [],
        clearRules: [],
        currentDay: 0,
        currentNode: 'test',
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: Date.now(),
        saveCount: 0
      });
      
      // 清理测试数据
      await this.storage.clear('__test__', 0);
      
      this.logInfo('Storage system initialized successfully');
    } catch (error) {
      throw this.createFlowError('storage', 'STORAGE_INIT_FAILED', 
        'Failed to initialize storage system', { originalError: error });
    }
  }

  private async preloadStoryData(): Promise<void> {
    try {
      // 预加载前几天的故事数据以提高性能
      const daysToPreload = [0, 1, 2];
      
      for (const day of daysToPreload) {
        try {
          const storyData = await this.loadStoryData(day);
          if (storyData) {
            this.storyCache.set(day, storyData);
            this.logInfo(`Preloaded story data for day ${day}`);
          }
        } catch (error) {
          this.logWarn(`Failed to preload story for day ${day}`, error);
        }
      }
    } catch (error) {
      this.logError('Error preloading story data', error);
    }
  }

  private validateProvinceData(): void {
    if (!CHINA_PROVINCES || CHINA_PROVINCES.length === 0) {
      throw this.createFlowError('initialization', 'PROVINCE_DATA_MISSING', 
        'Province data is missing or empty');
    }
    
    this.logInfo(`Validated ${CHINA_PROVINCES.length} provinces`);
  }

  private async loadStoryData(day: number): Promise<StoryData | null> {
    // 检查缓存
    if (this.storyCache.has(day)) {
      return this.storyCache.get(day)!;
    }

    try {
      // 这里应该加载实际的Python脚本文件
      // 为了演示，返回模拟数据
      const mockStoryData: StoryData = {
        day,
        title: `第${day}天`,
        sections: [
          {
            id: 'start',
            title: '开始',
            content: '新的一天开始了...',
            type: 'story',
            references: []
          }
        ],
        choices: [
          {
            id: 'choice_1',
            text: '继续游戏',
            nextSection: 'continue',
            weight: 1,
            priority: 1
          }
        ],
        winConditions: [],
        deathConditions: [],
        metadata: {
          author: '系统',
          version: '1.0.0',
          created: new Date().toISOString(),
          modified: new Date().toISOString(),
          description: `第${day}天的故事`,
          tags: []
        }
      };

      // 缓存结果
      this.storyCache.set(day, mockStoryData);
      return mockStoryData;
      
    } catch (error) {
      this.logError(`Failed to load story data for day ${day}`, error);
      return null;
    }
  }

  private createNewGameState(playerInfo: PlayerInfo): GameState {
    const baseAttributes = this.gameConfig.startingAttributes;
    const professionModifiers = this.gameConfig.professionModifiers[playerInfo.profession] || {};
    
    return {
      ...initialGameState,
      ...baseAttributes,
      playerName: playerInfo.name,
      selectedProfession: playerInfo.profession,
      selectedProvince: playerInfo.province,
      profession: playerInfo.profession,
      sessionStartTime: Date.now(),
      ...professionModifiers,
      ...playerInfo.customAttributes
    };
  }

  private async saveGame(): Promise<boolean> {
    try {
      const saveData: GameSaveData = {
        version: '1.0.0',
        playerName: this.currentState.playerName,
        profession: this.currentState.selectedProfession,
        gameState: this.currentState,
        rulePapers: this.currentState.rulePapers || [],
        clearRules: this.currentState.clearRules || [],
        currentDay: this.currentState.currentDay,
        currentNode: this.currentState.currentNode,
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: Date.now(),
        saveCount: 0
      };

      return await this.storage.save(saveData);
    } catch (error) {
      this.logError('Failed to save game', error);
      return false;
    }
  }

  private validateChoice(choiceId: string, context: ChoiceContext): ValidationResult {
    const errors: string[] = [];
    
    if (!choiceId || choiceId.trim() === '') {
      errors.push('Choice ID cannot be empty');
    }

    if (this.currentState.gameStatus !== 'playing') {
      errors.push('Game is not in playing state');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings: []
    };
  }

  private evaluateChoiceConditions(conditions: string[]): ConditionResult {
    // 简化实现，实际应该解析和执行条件表达式
    return {
      passed: true,
      evaluatedConditions: conditions.map(condition => ({
        condition,
        result: true,
        reason: 'Condition passed'
      }))
    };
  }

  private applyChoiceEffects(choice: any): ChoiceEffect[] {
    // 简化实现，实际应该根据选择应用具体效果
    return choice.effects || [];
  }

  private updateStateFromChoice(choice: any, effects: ChoiceEffect[]): GameState {
    // 简化实现，实际应该更新游戏状态
    return this.currentState;
  }

  private recordChoice(choice: any, effects: ChoiceEffect[]): void {
    const choiceRecord = {
      id: choice.id,
      day: this.currentState.currentDay,
      node: this.currentState.currentNode,
      choiceText: choice.text,
      timestamp: Date.now(),
      effects
    };

    this.currentState.choiceHistory.push(choiceRecord);
  }

  private checkSLevelConditions(state: GameState): boolean {
    // S级条件：所有属性>80，通关天数=7，规则正确率>90%
    return state.currentDay === 7 &&
           state.sanity > 80 && state.energy > 80 && state.hunger > 80 &&
           state.intelligence > 80 && state.strength > 80 && state.speed > 80 && state.luck > 80;
  }

  private checkALevelConditions(state: GameState): boolean {
    // A级条件：主要属性>60，通关天数=7
    return state.currentDay === 7 &&
           state.sanity > 60 && state.energy > 60 && state.hunger > 60;
  }

  private checkBLevelConditions(state: GameState): boolean {
    // B级条件：通关天数=7，基本属性正常
    return state.currentDay === 7 &&
           state.sanity > 30 && state.energy > 30 && state.hunger > 30;
  }

  private checkCLevelConditions(state: GameState): boolean {
    // C级条件：存活到第7天
    return state.currentDay === 7;
  }

  private checkSpecialDeathConditions(state: GameState): boolean {
    // 特殊死亡条件检查
    return false; // 简化实现
  }

  private unlockContentForDay(day: number): string[] {
    const unlocked: string[] = [];
    
    // 根据天数解锁相应内容
    if (day >= 2) unlocked.push('advanced_rules');
    if (day >= 4) unlocked.push('hidden_choices');
    if (day >= 6) unlocked.push('final_challenges');
    
    return unlocked;
  }

  private generateGameId(): string {
    return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateGameSummary(): GameSummary {
    return {
      playerName: this.currentState.playerName,
      profession: this.currentState.selectedProfession,
      totalDays: this.currentState.currentDay,
      completedDays: this.currentState.completedDays.size,
      finalScore: this.calculateFinalScore(),
      playTime: Date.now() - this.currentState.sessionStartTime,
      choicesMade: this.currentState.choiceHistory.length,
      achievements: []
    };
  }

  private calculateFinalScore(): number {
    const state = this.currentState;
    let score = 0;
    
    // 基础分数
    score += state.currentDay * 100;
    
    // 属性分数
    score += (state.sanity + state.energy + state.hunger) * 2;
    score += (state.intelligence + state.strength + state.speed + state.luck);
    
    // 完成天数奖励
    score += state.completedDays.size * 50;
    
    return Math.max(0, score);
  }

  private calculateAchievements(reason: GameEndReason): string[] {
    const achievements: string[] = [];
    
    if (reason.type === 'victory') {
      achievements.push('first_victory');
      if (reason.winResult?.level === 'S') {
        achievements.push('perfect_victory');
      }
    }
    
    return achievements;
  }

  private async createFinalSaveData(): Promise<GameSaveData | undefined> {
    try {
      return {
        version: '1.0.0',
        playerName: this.currentState.playerName,
        profession: this.currentState.selectedProfession,
        gameState: this.currentState,
        rulePapers: this.currentState.rulePapers || [],
        clearRules: this.currentState.clearRules || [],
        currentDay: this.currentState.currentDay,
        currentNode: this.currentState.currentNode,
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: this.currentState.sessionStartTime,
        saveCount: 0
      };
    } catch (error) {
      this.logError('Failed to create final save data', error);
      return undefined;
    }
  }

  private async cleanup(): Promise<void> {
    // 清理资源
    this.storyCache.clear();
    this.errorLog = [];
  }

  // 日志方法
  private logInfo(message: string, context?: any): void {
    console.log(`[GameFlow] ${message}`, context || '');
  }

  private logWarn(message: string, context?: any): void {
    console.warn(`[GameFlow] ${message}`, context || '');
  }

  private logError(message: string, error?: any): void {
    console.error(`[GameFlow] ${message}`, error || '');
  }

  private createFlowError(
    type: FlowError['type'],
    code: string,
    message: string,
    context?: any
  ): GameFlowError {
    const flowError: FlowError = {
      type,
      code,
      message,
      severity: type === 'initialization' ? 'critical' : 'error',
      recoverable: type !== 'initialization',
      context
    };

    const error = new GameFlowError(message);
    error.flowError = flowError;
    return error;
  }
}

// 导出工厂函数
export function createGameFlowController(config: GameConfig): GameFlowController {
  return new GameFlowControllerImpl(config);
}
```

#### 3.3 游戏流程Hook
```typescript
// src/hooks/useGameFlow.ts
import { useState, useCallback, useEffect } from 'react';
import { GameFlowController, GameConfig, PlayerInfo } from '../types/gameFlow';
import { GameState } from '../types/gameState';
import { createGameFlowController } from '../utils/gameFlowController';

export interface UseGameFlowReturn {
  // 控制器状态
  controller: GameFlowController | null;
  isInitialized: boolean;
  isLoading: boolean;
  error: string | null;
  
  // 游戏状态
  gameState: GameState;
  isGameActive: boolean;
  currentDay: number;
  
  // 主要操作
  initialize: (config: GameConfig) => Promise<boolean>;
  startNewGame: (playerInfo: PlayerInfo) => Promise<boolean>;
  makeChoice: (choiceId: string) => Promise<boolean>;
  advanceDay: (day: number) => Promise<boolean>;
  completeDay: (success: boolean) => Promise<boolean>;
  
  // 工具方法
  canAdvanceToDay: (day: number) => boolean;
  getAvailableChoices: () => string[];
  getCurrentStory: () => any;
}

export const useGameFlow = (initialConfig?: GameConfig): UseGameFlowReturn => {
  const [controller, setController] = useState<GameFlowController | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [gameState, setGameState] = useState<GameState>({
    time: 0,
    profession: '学生',
    hunger: 50,
    energy: 100,
    sanity: 100,
    intelligence: 50,
    strength: 50,
    speed: 50,
    luck: 50,
    playerName: '',
    selectedProvince: '',
    selectedProfession: '学生',
    currentDay: 0,
    currentNode: 'start',
    completedDays: new Set(),
    availableDays: new Set([0]),
    gameStatus: 'menu',
    choiceHistory: [],
    storyProgress: {
      visitedNodes: new Set(),
      completedNodes: new Set(),
      currentPath: [],
      branchFlags: new Map(),
      storyVariables: new Map()
    },
    isLoading: false,
    lastSaveTime: null,
    sessionStartTime: Date.now(),
    activeModals: new Set(),
    notifications: []
  });

  // 初始化控制器
  const initialize = useCallback(async (config: GameConfig): Promise<boolean> => {
    setIsLoading(true);
    setError(null);
    
    try {
      const newController = createGameFlowController(config);
      const result = await newController.initializeGame(config);
      
      if (result.success) {
        setController(newController);
        setIsInitialized(true);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Initialization failed');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  // 开始新游戏
  const startNewGame = useCallback(async (playerInfo: PlayerInfo): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.startNewGame(playerInfo);
      
      if (result.success) {
        setGameState(result.initialState);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to start new game');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // 做出选择
  const makeChoice = useCallback(async (choiceId: string): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.processPlayerChoice(choiceId, {});
      
      if (result.success) {
        setGameState(result.newState);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to process choice');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // 推进天数
  const advanceDay = useCallback(async (day: number): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.advanceToNextDay(day);
      
      if (result.success) {
        // 更新游戏状态（这里简化处理）
        setGameState(prev => ({
          ...prev,
          currentDay: result.newDay,
          currentNode: result.newNode
        }));
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to advance day');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // 完成天数
  const completeDay = useCallback(async (success: boolean): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.completeCurrentDay({
        day: gameState.currentDay,
        success,
        endingType: success ? 'C' : 'death',
        summary: success ? 'Day completed successfully' : 'Day failed'
      });
      
      if (result.success) {
        // 更新游戏状态
        if (result.gameEndResult) {
          setGameState(result.gameEndResult.finalState);
        }
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to complete day');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller, gameState.currentDay]);

  // 工具方法
  const canAdvanceToDay = useCallback((day: number): boolean => {
    return day >= 0 && day <= 7 && day <= gameState.currentDay + 1;
  }, [gameState.currentDay]);

  const getAvailableChoices = useCallback((): string[] => {
    // 这里应该根据当前故事数据返回可用选择
    return ['choice_1', 'choice_2', 'choice_3'];
  }, []);

  const getCurrentStory = useCallback(() => {
    // 这里应该返回当前故事数据
    return null;
  }, []);

  // 计算派生状态
  const isGameActive = gameState.gameStatus === 'playing' || gameState.gameStatus === 'paused';
  const currentDay = gameState.currentDay;

  // 初始化（如果提供了初始配置）
  useEffect(() => {
    if (initialConfig && !controller && !isInitialized) {
      initialize(initialConfig);
    }
  }, [initialConfig, controller, isInitialized, initialize]);

  return {
    controller,
    isInitialized,
    isLoading,
    error,
    gameState,
    isGameActive,
    currentDay,
    initialize,
    startNewGame,
    makeChoice,
    advanceDay,
    completeDay,
    canAdvanceToDay,
    getAvailableChoices,
    getCurrentStory
  };
};

// 默认配置
export const DEFAULT_GAME_CONFIG: GameConfig = {
  debugMode: false,
  autoSaveInterval: 300000, // 5分钟
  maxSaveSlots: 5,
  startingAttributes: {
    hunger: 50,
    energy: 100,
    sanity: 100,
    intelligence: 50,
    strength: 50,
    speed: 50,
    luck: 50
  },
  professionModifiers: {
    '学生': { intelligence: 10 },
    '医生': { sanity: 10 },
    '律师': { intelligence: 15 },
    '老人': { wisdom: 20 },
    '残疾人': { empathy: 15 }
  },
  enableAnimations: true,
  enableSound: true,
  qualityPreset: 'medium'
};
```

### 4. 关键技术点
- **异步流程控制**：完整的Promise链和错误处理
- **状态一致性**：游戏状态的原子性更新和验证
- **模块化集成**：各Epic模块的无缝对接
- **错误恢复**：多层次错误处理和恢复机制
- **性能优化**：缓存机制和懒加载策略
- **类型安全**：完整的TypeScript类型定义

### 5. 依赖项
- Epic2存储系统（数据持久化）
- Epic3脚本解析（故事内容加载）
- Epic4状态管理（游戏状态维护）
- Epic5UI组件（界面交互）
- Epic6地图组件（省份选择）

## Milestone

**第一阶段（当前进行）**：
- 🔄 流程控制器架构设计（45分钟）
- 🔄 核心流程实现（60分钟）
- 🔄 错误处理机制（30分钟）

**第二阶段（待完成）**：
- 📋 React Hook封装（30分钟）
- 📋 集成测试开发（45分钟）
- 📋 性能优化和验证（30分钟）

**第三阶段（待完成）**：
- 📋 单元测试执行（30分钟）
- 📋 文档完善和状态更新（15分钟）

## 测试方案

### 功能点测试
- 游戏初始化流程（配置验证→模块加载→状态准备）
- 新游戏开始流程（玩家信息→状态创建→故事加载）
- 选择处理流程（验证→效果应用→状态更新→条件检查）
- 天数推进流程（解锁→数据加载→状态更新）
- 游戏结束流程（胜利/失败→总结生成→存档创建）

### 异常测试
- 模块初始化失败处理
- 无效玩家信息处理
- 故事数据加载失败处理
- 选择验证失败处理
- 状态更新异常处理
- 存档操作失败处理

### 性能验证
- 完整流程执行时间<3秒（性能基准）
- 选择处理响应时间<200ms
- 状态更新延迟<50ms
- 错误恢复时间<500ms
- 内存使用稳定性（<100MB峰值）