# Epic7-å­ä»»åŠ¡01: æ¸¸æˆæ ¸å¿ƒæµç¨‹é›†æˆ

## å¼€å‘çŠ¶æ€
å·²æµ‹è¯• â†’ å­ä»»åŠ¡å¼€å‘å®Œæˆ

## å¼€å‘æ–¹æ¡ˆ

### 1. å¼€å‘ç›®æ ‡
é›†æˆæ‰€æœ‰æ ¸å¿ƒæ¨¡å—ï¼Œå®ç°å®Œæ•´çš„7å¤©æ¸¸æˆæµç¨‹ï¼Œç¡®ä¿ç«¯åˆ°ç«¯åŠŸèƒ½æ­£å¸¸è¿ä½œã€‚å»ºç«‹ç»Ÿä¸€çš„æ¸¸æˆæµç¨‹æ§åˆ¶å™¨ï¼Œç®¡ç†ä»æ¸¸æˆåˆå§‹åŒ–åˆ°é€šå…³/æ­»äº¡çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸã€‚

### 2. è®¾è®¡æ–¹æ¡ˆ
é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼š
- **æµç¨‹æ§åˆ¶å±‚**ï¼šç»Ÿä¸€çš„æ¸¸æˆçŠ¶æ€æœºå’Œæµç¨‹ç®¡ç†
- **æ¨¡å—é›†æˆå±‚**ï¼šå„Epicæ¨¡å—çš„æ¥å£é€‚é…å’Œåè°ƒ
- **é”™è¯¯å¤„ç†å±‚**ï¼šå…¨å±€é”™è¯¯æ•è·å’Œæ¢å¤æœºåˆ¶
- **ç”¨æˆ·ä½“éªŒå±‚**ï¼šæµç•…çš„ç•Œé¢è¿‡æ¸¡å’Œåé¦ˆ

### 3. å®ç°æ–¹å¼

#### 3.1 æ¸¸æˆæµç¨‹æ§åˆ¶å™¨æ ¸å¿ƒæ¶æ„
```typescript
// src/types/gameFlow.ts
import { GameState, GameAction } from './gameState';
import { GameSaveData } from './storage';
import { StoryData, ParseError } from './parser';
import { ProvinceData } from './map';

export interface GameFlowController {
  // æ¸¸æˆç”Ÿå‘½å‘¨æœŸç®¡ç†
  initializeGame(config: GameConfig): Promise<InitializationResult>;
  startNewGame(playerInfo: PlayerInfo): Promise<GameStartResult>;
  loadExistingGame(saveData: GameSaveData): Promise<GameLoadResult>;
  
  // æ ¸å¿ƒæ¸¸æˆæµç¨‹
  processPlayerChoice(choiceId: string, context: ChoiceContext): Promise<ChoiceResult>;
  advanceToNextDay(day: number): Promise<DayAdvanceResult>;
  completeCurrentDay(completion: DayCompletion): Promise<DayCompletionResult>;
  
  // çŠ¶æ€æ£€æŸ¥å’ŒéªŒè¯
  validateGameState(): ValidationResult;
  checkWinConditions(): WinConditionResult;
  checkDeathConditions(): DeathConditionResult;
  
  // æ¸¸æˆç»“æŸå¤„ç†
  handleGameEnd(reason: GameEndReason): Promise<GameEndResult>;
  generateGameSummary(): GameSummary;
  
  // é”™è¯¯å¤„ç†å’Œæ¢å¤
  handleError(error: GameFlowError): ErrorHandlingResult;
  recoverFromError(state: RecoveryState): Promise<RecoveryResult>;
}

export interface GameConfig {
  // åŸºç¡€é…ç½®
  debugMode: boolean;
  autoSaveInterval: number;
  maxSaveSlots: number;
  
  // æ¸¸æˆå‚æ•°
  startingAttributes: Partial<GameState>;
  professionModifiers: Record<string, AttributeModifiers>;
  
  // æ€§èƒ½è®¾ç½®
  enableAnimations: boolean;
  enableSound: boolean;
  qualityPreset: 'low' | 'medium' | 'high';
}

export interface PlayerInfo {
  name: string;
  profession: string;
  province: string;
  customAttributes?: Partial<GameState>;
}

export interface InitializationResult {
  success: boolean;
  gameId: string;
  initializedModules: string[];
  errors: FlowError[];
  warnings: FlowWarning[];
}

export interface ChoiceResult {
  success: boolean;
  newState: GameState;
  storyText?: string;
  availableChoices?: string[];
  effects: ChoiceEffect[];
  nextNode?: string;
  errors: FlowError[];
}

export interface DayAdvanceResult {
  success: boolean;
  newDay: number;
  newNode: string;
  storyData?: StoryData;
  unlockedContent: string[];
  errors: FlowError[];
}

export interface WinConditionResult {
  hasWon: boolean;
  winLevel?: 'S' | 'A' | 'B' | 'C';
  triggeredConditions: string[];
  score: number;
  message: string;
}

export interface DeathConditionResult {
  hasDied: boolean;
  deathReason?: string;
  triggeredConditions: string[];
  message: string;
  canContinue?: boolean;
}

export interface GameEndResult {
  success: boolean;
  endType: 'victory' | 'defeat' | 'abandon' | 'error';
  finalState: GameState;
  summary: GameSummary;
  achievements: string[];
  saveData?: GameSaveData;
}

export interface FlowError {
  type: 'initialization' | 'parsing' | 'state' | 'storage' | 'validation';
  code: string;
  message: string;
  severity: 'critical' | 'error' | 'warning' | 'info';
  context?: Record<string, any>;
  recoverable: boolean;
}

export interface GameFlowError extends Error {
  flowError: FlowError;
  originalError?: Error;
}
```

#### 3.2 æ ¸å¿ƒæµç¨‹æ§åˆ¶å™¨å®ç°
```typescript
// src/utils/gameFlowController.ts
import { GameFlowController, GameConfig, PlayerInfo } from '../types/gameFlow';
import { GameState, GameAction } from '../types/gameState';
import { GameSaveData } from '../types/storage';
import { StoryData, ParseError } from '../types/parser';
import { StorageManager } from './storageManager';
import { PythonScriptParser } from './pythonScriptParser';
import { gameReducer, initialGameState } from './gameReducer';
import { CHINA_PROVINCES } from '../data/chinaProvinces';

export class GameFlowControllerImpl implements GameFlowController {
  private storage: StorageManager;
  private parser: PythonScriptParser;
  private currentState: GameState;
  private gameConfig: GameConfig;
  private storyCache: Map<number, StoryData>;
  private errorLog: FlowError[];
  private isInitialized: boolean;

  constructor(config: GameConfig) {
    this.storage = new StorageManager({
      storageKey: 'rulegame_save',
      maxSaveSlots: config.maxSaveSlots,
      autoSaveInterval: config.autoSaveInterval,
      compressionEnabled: true
    });
    
    this.parser = new PythonScriptParser();
    this.currentState = { ...initialGameState };
    this.gameConfig = config;
    this.storyCache = new Map();
    this.errorLog = [];
    this.isInitialized = false;
  }

  /**
   * åˆå§‹åŒ–æ¸¸æˆç³»ç»Ÿ
   */
  async initializeGame(config: GameConfig): Promise<InitializationResult> {
    try {
      this.logInfo('Initializing game system...');
      
      // 1. éªŒè¯é…ç½®
      const validationResult = this.validateConfiguration(config);
      if (!validationResult.isValid) {
        throw this.createFlowError('initialization', 'INVALID_CONFIG', 
          'Configuration validation failed', validationResult.errors);
      }

      // 2. åˆå§‹åŒ–å­˜å‚¨ç³»ç»Ÿ
      await this.initializeStorage();
      
      // 3. é¢„åŠ è½½æ•…äº‹æ•°æ®
      await this.preloadStoryData();
      
      // 4. éªŒè¯çœä»½æ•°æ®
      this.validateProvinceData();
      
      this.isInitialized = true;
      this.gameConfig = config;
      
      this.logInfo('Game system initialized successfully');
      
      return {
        success: true,
        gameId: this.generateGameId(),
        initializedModules: ['storage', 'parser', 'state', 'provinces'],
        errors: [],
        warnings: validationResult.warnings
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        gameId: '',
        initializedModules: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * å¼€å§‹æ–°æ¸¸æˆ
   */
  async startNewGame(playerInfo: PlayerInfo): Promise<GameStartResult> {
    if (!this.isInitialized) {
      throw this.createFlowError('initialization', 'NOT_INITIALIZED', 
        'Game system not initialized');
    }

    try {
      this.logInfo(`Starting new game for player: ${playerInfo.name}`);
      
      // 1. éªŒè¯ç©å®¶ä¿¡æ¯
      const validationResult = this.validatePlayerInfo(playerInfo);
      if (!validationResult.isValid) {
        throw this.createFlowError('initialization', 'INVALID_PLAYER_INFO', 
          'Player info validation failed', validationResult.errors);
      }

      // 2. åˆ›å»ºæ–°çš„æ¸¸æˆçŠ¶æ€
      const newGameState = this.createNewGameState(playerInfo);
      
      // 3. åŠ è½½ç¬¬ä¸€å¤©æ•…äº‹æ•°æ®
      const day1Story = await this.loadStoryData(1);
      
      // 4. åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
      this.currentState = {
        ...newGameState,
        currentDay: 1,
        currentNode: 'start',
        gameStatus: 'playing',
        playerName: playerInfo.name,
        selectedProfession: playerInfo.profession,
        selectedProvince: playerInfo.province,
        profession: playerInfo.profession
      };

      // 5. ä¿å­˜åˆå§‹å­˜æ¡£
      await this.saveGame();
      
      this.logInfo(`New game started successfully for ${playerInfo.name}`);
      
      return {
        success: true,
        initialState: this.currentState,
        storyData: day1Story,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        initialState: this.currentState,
        storyData: null,
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * å¤„ç†ç©å®¶é€‰æ‹©
   */
  async processPlayerChoice(choiceId: string, context: ChoiceContext): Promise<ChoiceResult> {
    try {
      this.logInfo(`Processing choice: ${choiceId}`);
      
      // 1. éªŒè¯é€‰æ‹©æœ‰æ•ˆæ€§
      const validation = this.validateChoice(choiceId, context);
      if (!validation.isValid) {
        throw this.createFlowError('validation', 'INVALID_CHOICE', 
          'Choice validation failed', validation.errors);
      }

      // 2. è·å–å½“å‰æ•…äº‹æ•°æ®
      const currentStory = await this.loadStoryData(this.currentState.currentDay);
      if (!currentStory) {
        throw this.createFlowError('parsing', 'STORY_NOT_FOUND', 
          `Story data not found for day ${this.currentState.currentDay}`);
      }

      // 3. æŸ¥æ‰¾å¯¹åº”çš„é€‰æ‹©
      const choice = currentStory.choices.find(c => c.id === choiceId);
      if (!choice) {
        throw this.createFlowError('validation', 'CHOICE_NOT_FOUND', 
          `Choice not found: ${choiceId}`);
      }

      // 4. éªŒè¯é€‰æ‹©æ¡ä»¶
      if (choice.conditions && choice.conditions.length > 0) {
        const conditionResult = this.evaluateChoiceConditions(choice.conditions);
        if (!conditionResult.passed) {
          return {
            success: false,
            newState: this.currentState,
            effects: [],
            errors: [{
              type: 'validation',
              code: 'CONDITION_NOT_MET',
              message: 'Choice conditions not met',
              severity: 'warning',
              recoverable: true
            }],
            warnings: []
          };
        }
      }

      // 5. åº”ç”¨é€‰æ‹©æ•ˆæœ
      const effects = this.applyChoiceEffects(choice);
      
      // 6. æ›´æ–°æ¸¸æˆçŠ¶æ€
      const newState = this.updateStateFromChoice(choice, effects);
      this.currentState = newState;

      // 7. è®°å½•é€‰æ‹©å†å²
      this.recordChoice(choice, effects);

      // 8. æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
      const winResult = this.checkWinConditions();
      const deathResult = this.checkDeathConditions();

      let result: ChoiceResult = {
        success: true,
        newState: this.currentState,
        storyText: choice.text,
        effects,
        errors: [],
        warnings: []
      };

      // 9. å¤„ç†æ¸¸æˆç»“æŸ
      if (winResult.hasWon) {
        await this.handleGameEnd({ type: 'victory', winResult });
      } else if (deathResult.hasDied) {
        await this.handleGameEnd({ type: 'defeat', deathResult });
      } else if (choice.nextSection) {
        result.nextNode = choice.nextSection;
        await this.advanceToNode(choice.nextSection);
      }

      // 10. è‡ªåŠ¨ä¿å­˜
      if (this.gameConfig.autoSaveInterval > 0) {
        await this.saveGame();
      }

      return result;
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        newState: this.currentState,
        effects: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * æ¨è¿›åˆ°ä¸‹ä¸€å¤©
   */
  async advanceToNextDay(day: number): Promise<DayAdvanceResult> {
    try {
      this.logInfo(`Advancing to day ${day}`);
      
      // 1. éªŒè¯å¤©æ•°æœ‰æ•ˆæ€§
      if (day < 1 || day > 7) {
        throw this.createFlowError('validation', 'INVALID_DAY', 
          `Invalid day number: ${day}`);
      }

      // 2. æ£€æŸ¥å‰ç½®æ¡ä»¶
      if (day > this.currentState.currentDay + 1) {
        throw this.createFlowError('validation', 'DAY_NOT_UNLOCKED', 
          `Day ${day} is not unlocked yet`);
      }

      // 3. åŠ è½½æ–°çš„ä¸€å¤©æ•…äº‹æ•°æ®
      const storyData = await this.loadStoryData(day);
      if (!storyData) {
        throw this.createFlowError('parsing', 'STORY_NOT_FOUND', 
          `Story data not found for day ${day}`);
      }

      // 4. æ›´æ–°æ¸¸æˆçŠ¶æ€
      const newState = {
        ...this.currentState,
        currentDay: day,
        currentNode: 'start',
        availableDays: new Set([...this.currentState.availableDays, day])
      };

      this.currentState = newState;

      // 5. è§£é”æ–°å†…å®¹
      const unlockedContent = this.unlockContentForDay(day);

      this.logInfo(`Advanced to day ${day} successfully`);

      return {
        success: true,
        newDay: day,
        newNode: 'start',
        storyData,
        unlockedContent,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        newDay: this.currentState.currentDay,
        newNode: this.currentState.currentNode,
        storyData: null,
        unlockedContent: [],
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * å®Œæˆå½“å‰å¤©æ•°
   */
  async completeCurrentDay(completion: DayCompletion): Promise<DayCompletionResult> {
    try {
      this.logInfo(`Completing day ${completion.day}`);
      
      // 1. éªŒè¯å®Œæˆä¿¡æ¯
      if (completion.day !== this.currentState.currentDay) {
        throw this.createFlowError('validation', 'DAY_MISMATCH', 
          `Completion day ${completion.day} does not match current day ${this.currentState.currentDay}`);
      }

      // 2. è¯„ä¼°å®Œæˆæƒ…å†µ
      const evaluation = this.evaluateDayCompletion(completion);
      
      // 3. æ›´æ–°æ¸¸æˆçŠ¶æ€
      const newCompletedDays = new Set([...this.currentState.completedDays, completion.day]);
      const newAvailableDays = new Set([...this.currentState.availableDays]);
      
      if (completion.success && completion.day < 7) {
        newAvailableDays.add(completion.day + 1);
      }

      this.currentState = {
        ...this.currentState,
        completedDays: newCompletedDays,
        availableDays: newAvailableDays,
        gameStatus: completion.success ? 'playing' : 'failed'
      };

      // 4. ä¿å­˜è¿›åº¦
      await this.saveGame();

      // 5. æ£€æŸ¥æ¸¸æˆç»“æŸ
      let gameEndResult: GameEndResult | null = null;
      if (completion.day === 7 && completion.success) {
        gameEndResult = await this.handleGameEnd({ 
          type: 'victory', 
          winResult: { level: completion.endingType || 'C' } 
        });
      } else if (!completion.success && completion.endingType === 'death') {
        gameEndResult = await this.handleGameEnd({ 
          type: 'defeat', 
          deathResult: { reason: completion.summary || 'Day completion failed' } 
        });
      }

      this.logInfo(`Day ${completion.day} completed with success: ${completion.success}`);

      return {
        success: true,
        completion,
        evaluation,
        gameEndResult,
        errors: [],
        warnings: []
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        completion,
        evaluation: null,
        gameEndResult: null,
        errors: [flowError.flowError],
        warnings: []
      };
    }
  }

  /**
   * æ£€æŸ¥èƒœåˆ©æ¡ä»¶
   */
  checkWinConditions(): WinConditionResult {
    try {
      const state = this.currentState;
      const triggeredConditions: string[] = [];
      let score = 0;
      let winLevel: 'S' | 'A' | 'B' | 'C' | undefined;

      // Sçº§é€šå…³æ¡ä»¶ï¼šå®Œç¾é€šå…³
      if (this.checkSLevelConditions(state)) {
        winLevel = 'S';
        score = 1000;
        triggeredConditions.push('perfect_completion', 'all_rules_correct', 'max_attributes');
      }
      // Açº§é€šå…³æ¡ä»¶ï¼šä¼˜ç§€é€šå…³
      else if (this.checkALevelConditions(state)) {
        winLevel = 'A';
        score = 800;
        triggeredConditions.push('good_completion', 'most_rules_correct', 'high_attributes');
      }
      // Bçº§é€šå…³æ¡ä»¶ï¼šè‰¯å¥½é€šå…³
      else if (this.checkBLevelConditions(state)) {
        winLevel = 'B';
        score = 600;
        triggeredConditions.push('decent_completion', 'some_rules_correct', 'medium_attributes');
      }
      // Cçº§é€šå…³æ¡ä»¶ï¼šåŸºç¡€é€šå…³
      else if (this.checkCLevelConditions(state)) {
        winLevel = 'C';
        score = 400;
        triggeredConditions.push('basic_completion', 'survived_all_days');
      }

      return {
        hasWon: winLevel !== undefined,
        winLevel,
        triggeredConditions,
        score,
        message: winLevel ? `æ­å–œè·å¾—${winLevel}çº§é€šå…³ï¼` : 'ç»§ç»­åŠªåŠ›ï¼Œäº‰å–é€šå…³ï¼'
      };
      
    } catch (error) {
      this.logError('Error checking win conditions', error);
      return {
        hasWon: false,
        triggeredConditions: [],
        score: 0,
        message: 'æ¡ä»¶æ£€æŸ¥å¤±è´¥'
      };
    }
  }

  /**
   * æ£€æŸ¥æ­»äº¡æ¡ä»¶
   */
  checkDeathConditions(): DeathConditionResult {
    try {
      const state = this.currentState;
      const triggeredConditions: string[] = [];
      let hasDied = false;
      let deathReason: string | undefined;

      // æ£€æŸ¥å±æ€§æ­»äº¡æ¡ä»¶
      if (state.sanity <= 0) {
        hasDied = true;
        deathReason = 'ç²¾ç¥å´©æºƒ';
        triggeredConditions.push('sanity_zero');
      } else if (state.energy <= 0) {
        hasDied = true;
        deathReason = 'ä½“åŠ›è€—å°½';
        triggeredConditions.push('energy_zero');
      } else if (state.hunger <= 0) {
        hasDied = true;
        deathReason = 'é¥¥é¥¿è‡´æ­»';
        triggeredConditions.push('hunger_zero');
      }

      // æ£€æŸ¥æ—¶é—´æ­»äº¡æ¡ä»¶
      if (state.time >= 240) { // 4å°æ—¶ = 240åˆ†é’Ÿ
        hasDied = true;
        deathReason = 'æ—¶é—´è€—å°½';
        triggeredConditions.push('time_exceeded');
      }

      // æ£€æŸ¥ç‰¹æ®Šæ­»äº¡æ¡ä»¶
      if (this.checkSpecialDeathConditions(state)) {
        hasDied = true;
        deathReason = 'è§¦å‘ç‰¹æ®Šæ­»äº¡æ¡ä»¶';
        triggeredConditions.push('special_death');
      }

      return {
        hasDied,
        deathReason,
        triggeredConditions,
        message: hasDied ? `æ¸¸æˆç»“æŸï¼š${deathReason}` : 'ç”Ÿå­˜çŠ¶æ€è‰¯å¥½',
        canContinue: !hasDied
      };
      
    } catch (error) {
      this.logError('Error checking death conditions', error);
      return {
        hasDied: false,
        triggeredConditions: [],
        message: 'æ­»äº¡æ¡ä»¶æ£€æŸ¥å¤±è´¥',
        canContinue: true
      };
    }
  }

  /**
   * å¤„ç†æ¸¸æˆç»“æŸ
   */
  async handleGameEnd(reason: GameEndReason): Promise<GameEndResult> {
    try {
      this.logInfo(`Game ending: ${reason.type}`);
      
      // 1. ç”Ÿæˆæ¸¸æˆæ€»ç»“
      const summary = this.generateGameSummary();
      
      // 2. è®¡ç®—æˆå°±
      const achievements = this.calculateAchievements(reason);
      
      // 3. æ›´æ–°æœ€ç»ˆçŠ¶æ€
      let finalStatus: GameState['gameStatus'];
      switch (reason.type) {
        case 'victory':
          finalStatus = 'completed';
          break;
        case 'defeat':
          finalStatus = 'failed';
          break;
        case 'abandon':
          finalStatus = 'abandoned';
          break;
        default:
          finalStatus = 'error';
      }

      this.currentState = {
        ...this.currentState,
        gameStatus: finalStatus
      };

      // 4. åˆ›å»ºæœ€ç»ˆå­˜æ¡£
      const saveData = await this.createFinalSaveData();
      
      // 5. æ¸…ç†èµ„æº
      await this.cleanup();

      this.logInfo(`Game ended with type: ${reason.type}`);

      return {
        success: true,
        endType: reason.type,
        finalState: this.currentState,
        summary,
        achievements,
        saveData
      };
      
    } catch (error) {
      const flowError = this.handleError(error as Error);
      return {
        success: false,
        endType: 'error',
        finalState: this.currentState,
        summary: this.generateGameSummary(),
        achievements: [],
        saveData: undefined
      };
    }
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  handleError(error: Error): ErrorHandlingResult {
    const flowError: FlowError = {
      type: 'validation',
      code: 'UNKNOWN_ERROR',
      message: error.message,
      severity: 'error',
      recoverable: true,
      context: { stack: error.stack }
    };

    this.errorLog.push(flowError);
    this.logError('Game flow error', error);

    return {
      success: false,
      flowError,
      originalError: error,
      canRecover: flowError.recoverable
    };
  }

  /**
   * ä»é”™è¯¯ä¸­æ¢å¤
   */
  async recoverFromError(state: RecoveryState): Promise<RecoveryResult> {
    try {
      this.logInfo('Attempting error recovery...');
      
      // 1. å°è¯•ä»æœ€åå­˜æ¡£æ¢å¤
      if (state.lastSaveData) {
        const loadResult = await this.loadExistingGame(state.lastSaveData);
        if (loadResult.success) {
          return {
            success: true,
            recoveredState: this.currentState,
            recoveryMethod: 'from_save'
          };
        }
      }

      // 2. å°è¯•é‡ç½®åˆ°å®‰å…¨çŠ¶æ€
      if (state.safeState) {
        this.currentState = state.safeState;
        return {
          success: true,
          recoveredState: this.currentState,
          recoveryMethod: 'to_safe_state'
        };
      }

      // 3. é‡ç½®åˆ°åˆå§‹çŠ¶æ€
      this.currentState = { ...initialGameState };
      return {
        success: true,
        recoveredState: this.currentState,
        recoveryMethod: 'to_initial'
      };
      
    } catch (recoveryError) {
      this.logError('Error recovery failed', recoveryError);
      return {
        success: false,
        recoveredState: this.currentState,
        recoveryMethod: 'failed'
      };
    }
  }

  // ç§æœ‰è¾…åŠ©æ–¹æ³•
  private validateConfiguration(config: GameConfig): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (config.maxSaveSlots < 1 || config.maxSaveSlots > 10) {
      errors.push('maxSaveSlots must be between 1 and 10');
    }

    if (config.autoSaveInterval < 0) {
      errors.push('autoSaveInterval cannot be negative');
    }

    if (config.qualityPreset && !['low', 'medium', 'high'].includes(config.qualityPreset)) {
      warnings.push('Unknown quality preset, using medium');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  private async initializeStorage(): Promise<void> {
    try {
      // éªŒè¯å­˜å‚¨ç³»ç»Ÿå¯ç”¨æ€§
      const testData = { test: true, timestamp: Date.now() };
      await this.storage.save({
        version: '1.0.0',
        playerName: '__test__',
        profession: 'å­¦ç”Ÿ',
        gameState: initialGameState,
        rulePapers: [],
        clearRules: [],
        currentDay: 0,
        currentNode: 'test',
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: Date.now(),
        saveCount: 0
      });
      
      // æ¸…ç†æµ‹è¯•æ•°æ®
      await this.storage.clear('__test__', 0);
      
      this.logInfo('Storage system initialized successfully');
    } catch (error) {
      throw this.createFlowError('storage', 'STORAGE_INIT_FAILED', 
        'Failed to initialize storage system', { originalError: error });
    }
  }

  private async preloadStoryData(): Promise<void> {
    try {
      // é¢„åŠ è½½å‰å‡ å¤©çš„æ•…äº‹æ•°æ®ä»¥æé«˜æ€§èƒ½
      const daysToPreload = [0, 1, 2];
      
      for (const day of daysToPreload) {
        try {
          const storyData = await this.loadStoryData(day);
          if (storyData) {
            this.storyCache.set(day, storyData);
            this.logInfo(`Preloaded story data for day ${day}`);
          }
        } catch (error) {
          this.logWarn(`Failed to preload story for day ${day}`, error);
        }
      }
    } catch (error) {
      this.logError('Error preloading story data', error);
    }
  }

  private validateProvinceData(): void {
    if (!CHINA_PROVINCES || CHINA_PROVINCES.length === 0) {
      throw this.createFlowError('initialization', 'PROVINCE_DATA_MISSING', 
        'Province data is missing or empty');
    }
    
    this.logInfo(`Validated ${CHINA_PROVINCES.length} provinces`);
  }

  private async loadStoryData(day: number): Promise<StoryData | null> {
    // æ£€æŸ¥ç¼“å­˜
    if (this.storyCache.has(day)) {
      return this.storyCache.get(day)!;
    }

    try {
      // è¿™é‡Œåº”è¯¥åŠ è½½å®é™…çš„Pythonè„šæœ¬æ–‡ä»¶
      // ä¸ºäº†æ¼”ç¤ºï¼Œè¿”å›æ¨¡æ‹Ÿæ•°æ®
      const mockStoryData: StoryData = {
        day,
        title: `ç¬¬${day}å¤©`,
        sections: [
          {
            id: 'start',
            title: 'å¼€å§‹',
            content: 'æ–°çš„ä¸€å¤©å¼€å§‹äº†...',
            type: 'story',
            references: []
          }
        ],
        choices: [
          {
            id: 'choice_1',
            text: 'ç»§ç»­æ¸¸æˆ',
            nextSection: 'continue',
            weight: 1,
            priority: 1
          }
        ],
        winConditions: [],
        deathConditions: [],
        metadata: {
          author: 'ç³»ç»Ÿ',
          version: '1.0.0',
          created: new Date().toISOString(),
          modified: new Date().toISOString(),
          description: `ç¬¬${day}å¤©çš„æ•…äº‹`,
          tags: []
        }
      };

      // ç¼“å­˜ç»“æœ
      this.storyCache.set(day, mockStoryData);
      return mockStoryData;
      
    } catch (error) {
      this.logError(`Failed to load story data for day ${day}`, error);
      return null;
    }
  }

  private createNewGameState(playerInfo: PlayerInfo): GameState {
    const baseAttributes = this.gameConfig.startingAttributes;
    const professionModifiers = this.gameConfig.professionModifiers[playerInfo.profession] || {};
    
    return {
      ...initialGameState,
      ...baseAttributes,
      playerName: playerInfo.name,
      selectedProfession: playerInfo.profession,
      selectedProvince: playerInfo.province,
      profession: playerInfo.profession,
      sessionStartTime: Date.now(),
      ...professionModifiers,
      ...playerInfo.customAttributes
    };
  }

  private async saveGame(): Promise<boolean> {
    try {
      const saveData: GameSaveData = {
        version: '1.0.0',
        playerName: this.currentState.playerName,
        profession: this.currentState.selectedProfession,
        gameState: this.currentState,
        rulePapers: this.currentState.rulePapers || [],
        clearRules: this.currentState.clearRules || [],
        currentDay: this.currentState.currentDay,
        currentNode: this.currentState.currentNode,
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: Date.now(),
        saveCount: 0
      };

      return await this.storage.save(saveData);
    } catch (error) {
      this.logError('Failed to save game', error);
      return false;
    }
  }

  private validateChoice(choiceId: string, context: ChoiceContext): ValidationResult {
    const errors: string[] = [];
    
    if (!choiceId || choiceId.trim() === '') {
      errors.push('Choice ID cannot be empty');
    }

    if (this.currentState.gameStatus !== 'playing') {
      errors.push('Game is not in playing state');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings: []
    };
  }

  private evaluateChoiceConditions(conditions: string[]): ConditionResult {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è§£æå’Œæ‰§è¡Œæ¡ä»¶è¡¨è¾¾å¼
    return {
      passed: true,
      evaluatedConditions: conditions.map(condition => ({
        condition,
        result: true,
        reason: 'Condition passed'
      }))
    };
  }

  private applyChoiceEffects(choice: any): ChoiceEffect[] {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ ¹æ®é€‰æ‹©åº”ç”¨å…·ä½“æ•ˆæœ
    return choice.effects || [];
  }

  private updateStateFromChoice(choice: any, effects: ChoiceEffect[]): GameState {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ›´æ–°æ¸¸æˆçŠ¶æ€
    return this.currentState;
  }

  private recordChoice(choice: any, effects: ChoiceEffect[]): void {
    const choiceRecord = {
      id: choice.id,
      day: this.currentState.currentDay,
      node: this.currentState.currentNode,
      choiceText: choice.text,
      timestamp: Date.now(),
      effects
    };

    this.currentState.choiceHistory.push(choiceRecord);
  }

  private checkSLevelConditions(state: GameState): boolean {
    // Sçº§æ¡ä»¶ï¼šæ‰€æœ‰å±æ€§>80ï¼Œé€šå…³å¤©æ•°=7ï¼Œè§„åˆ™æ­£ç¡®ç‡>90%
    return state.currentDay === 7 &&
           state.sanity > 80 && state.energy > 80 && state.hunger > 80 &&
           state.intelligence > 80 && state.strength > 80 && state.speed > 80 && state.luck > 80;
  }

  private checkALevelConditions(state: GameState): boolean {
    // Açº§æ¡ä»¶ï¼šä¸»è¦å±æ€§>60ï¼Œé€šå…³å¤©æ•°=7
    return state.currentDay === 7 &&
           state.sanity > 60 && state.energy > 60 && state.hunger > 60;
  }

  private checkBLevelConditions(state: GameState): boolean {
    // Bçº§æ¡ä»¶ï¼šé€šå…³å¤©æ•°=7ï¼ŒåŸºæœ¬å±æ€§æ­£å¸¸
    return state.currentDay === 7 &&
           state.sanity > 30 && state.energy > 30 && state.hunger > 30;
  }

  private checkCLevelConditions(state: GameState): boolean {
    // Cçº§æ¡ä»¶ï¼šå­˜æ´»åˆ°ç¬¬7å¤©
    return state.currentDay === 7;
  }

  private checkSpecialDeathConditions(state: GameState): boolean {
    // ç‰¹æ®Šæ­»äº¡æ¡ä»¶æ£€æŸ¥
    return false; // ç®€åŒ–å®ç°
  }

  private unlockContentForDay(day: number): string[] {
    const unlocked: string[] = [];
    
    // æ ¹æ®å¤©æ•°è§£é”ç›¸åº”å†…å®¹
    if (day >= 2) unlocked.push('advanced_rules');
    if (day >= 4) unlocked.push('hidden_choices');
    if (day >= 6) unlocked.push('final_challenges');
    
    return unlocked;
  }

  private generateGameId(): string {
    return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateGameSummary(): GameSummary {
    return {
      playerName: this.currentState.playerName,
      profession: this.currentState.selectedProfession,
      totalDays: this.currentState.currentDay,
      completedDays: this.currentState.completedDays.size,
      finalScore: this.calculateFinalScore(),
      playTime: Date.now() - this.currentState.sessionStartTime,
      choicesMade: this.currentState.choiceHistory.length,
      achievements: []
    };
  }

  private calculateFinalScore(): number {
    const state = this.currentState;
    let score = 0;
    
    // åŸºç¡€åˆ†æ•°
    score += state.currentDay * 100;
    
    // å±æ€§åˆ†æ•°
    score += (state.sanity + state.energy + state.hunger) * 2;
    score += (state.intelligence + state.strength + state.speed + state.luck);
    
    // å®Œæˆå¤©æ•°å¥–åŠ±
    score += state.completedDays.size * 50;
    
    return Math.max(0, score);
  }

  private calculateAchievements(reason: GameEndReason): string[] {
    const achievements: string[] = [];
    
    if (reason.type === 'victory') {
      achievements.push('first_victory');
      if (reason.winResult?.level === 'S') {
        achievements.push('perfect_victory');
      }
    }
    
    return achievements;
  }

  private async createFinalSaveData(): Promise<GameSaveData | undefined> {
    try {
      return {
        version: '1.0.0',
        playerName: this.currentState.playerName,
        profession: this.currentState.selectedProfession,
        gameState: this.currentState,
        rulePapers: this.currentState.rulePapers || [],
        clearRules: this.currentState.clearRules || [],
        currentDay: this.currentState.currentDay,
        currentNode: this.currentState.currentNode,
        gameConfigPath: '',
        lastSaveTime: Date.now(),
        createdTime: this.currentState.sessionStartTime,
        saveCount: 0
      };
    } catch (error) {
      this.logError('Failed to create final save data', error);
      return undefined;
    }
  }

  private async cleanup(): Promise<void> {
    // æ¸…ç†èµ„æº
    this.storyCache.clear();
    this.errorLog = [];
  }

  // æ—¥å¿—æ–¹æ³•
  private logInfo(message: string, context?: any): void {
    console.log(`[GameFlow] ${message}`, context || '');
  }

  private logWarn(message: string, context?: any): void {
    console.warn(`[GameFlow] ${message}`, context || '');
  }

  private logError(message: string, error?: any): void {
    console.error(`[GameFlow] ${message}`, error || '');
  }

  private createFlowError(
    type: FlowError['type'],
    code: string,
    message: string,
    context?: any
  ): GameFlowError {
    const flowError: FlowError = {
      type,
      code,
      message,
      severity: type === 'initialization' ? 'critical' : 'error',
      recoverable: type !== 'initialization',
      context
    };

    const error = new GameFlowError(message);
    error.flowError = flowError;
    return error;
  }
}

// å¯¼å‡ºå·¥å‚å‡½æ•°
export function createGameFlowController(config: GameConfig): GameFlowController {
  return new GameFlowControllerImpl(config);
}
```

#### 3.3 æ¸¸æˆæµç¨‹Hook
```typescript
// src/hooks/useGameFlow.ts
import { useState, useCallback, useEffect } from 'react';
import { GameFlowController, GameConfig, PlayerInfo } from '../types/gameFlow';
import { GameState } from '../types/gameState';
import { createGameFlowController } from '../utils/gameFlowController';

export interface UseGameFlowReturn {
  // æ§åˆ¶å™¨çŠ¶æ€
  controller: GameFlowController | null;
  isInitialized: boolean;
  isLoading: boolean;
  error: string | null;
  
  // æ¸¸æˆçŠ¶æ€
  gameState: GameState;
  isGameActive: boolean;
  currentDay: number;
  
  // ä¸»è¦æ“ä½œ
  initialize: (config: GameConfig) => Promise<boolean>;
  startNewGame: (playerInfo: PlayerInfo) => Promise<boolean>;
  makeChoice: (choiceId: string) => Promise<boolean>;
  advanceDay: (day: number) => Promise<boolean>;
  completeDay: (success: boolean) => Promise<boolean>;
  
  // å·¥å…·æ–¹æ³•
  canAdvanceToDay: (day: number) => boolean;
  getAvailableChoices: () => string[];
  getCurrentStory: () => any;
}

export const useGameFlow = (initialConfig?: GameConfig): UseGameFlowReturn => {
  const [controller, setController] = useState<GameFlowController | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [gameState, setGameState] = useState<GameState>({
    time: 0,
    profession: 'å­¦ç”Ÿ',
    hunger: 50,
    energy: 100,
    sanity: 100,
    intelligence: 50,
    strength: 50,
    speed: 50,
    luck: 50,
    playerName: '',
    selectedProvince: '',
    selectedProfession: 'å­¦ç”Ÿ',
    currentDay: 0,
    currentNode: 'start',
    completedDays: new Set(),
    availableDays: new Set([0]),
    gameStatus: 'menu',
    choiceHistory: [],
    storyProgress: {
      visitedNodes: new Set(),
      completedNodes: new Set(),
      currentPath: [],
      branchFlags: new Map(),
      storyVariables: new Map()
    },
    isLoading: false,
    lastSaveTime: null,
    sessionStartTime: Date.now(),
    activeModals: new Set(),
    notifications: []
  });

  // åˆå§‹åŒ–æ§åˆ¶å™¨
  const initialize = useCallback(async (config: GameConfig): Promise<boolean> => {
    setIsLoading(true);
    setError(null);
    
    try {
      const newController = createGameFlowController(config);
      const result = await newController.initializeGame(config);
      
      if (result.success) {
        setController(newController);
        setIsInitialized(true);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Initialization failed');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  // å¼€å§‹æ–°æ¸¸æˆ
  const startNewGame = useCallback(async (playerInfo: PlayerInfo): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.startNewGame(playerInfo);
      
      if (result.success) {
        setGameState(result.initialState);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to start new game');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // åšå‡ºé€‰æ‹©
  const makeChoice = useCallback(async (choiceId: string): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.processPlayerChoice(choiceId, {});
      
      if (result.success) {
        setGameState(result.newState);
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to process choice');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // æ¨è¿›å¤©æ•°
  const advanceDay = useCallback(async (day: number): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.advanceToNextDay(day);
      
      if (result.success) {
        // æ›´æ–°æ¸¸æˆçŠ¶æ€ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
        setGameState(prev => ({
          ...prev,
          currentDay: result.newDay,
          currentNode: result.newNode
        }));
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to advance day');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller]);

  // å®Œæˆå¤©æ•°
  const completeDay = useCallback(async (success: boolean): Promise<boolean> => {
    if (!controller) {
      setError('Game controller not initialized');
      return false;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const result = await controller.completeCurrentDay({
        day: gameState.currentDay,
        success,
        endingType: success ? 'C' : 'death',
        summary: success ? 'Day completed successfully' : 'Day failed'
      });
      
      if (result.success) {
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        if (result.gameEndResult) {
          setGameState(result.gameEndResult.finalState);
        }
        return true;
      } else {
        setError(result.errors[0]?.message || 'Failed to complete day');
        return false;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [controller, gameState.currentDay]);

  // å·¥å…·æ–¹æ³•
  const canAdvanceToDay = useCallback((day: number): boolean => {
    return day >= 0 && day <= 7 && day <= gameState.currentDay + 1;
  }, [gameState.currentDay]);

  const getAvailableChoices = useCallback((): string[] => {
    // è¿™é‡Œåº”è¯¥æ ¹æ®å½“å‰æ•…äº‹æ•°æ®è¿”å›å¯ç”¨é€‰æ‹©
    return ['choice_1', 'choice_2', 'choice_3'];
  }, []);

  const getCurrentStory = useCallback(() => {
    // è¿™é‡Œåº”è¯¥è¿”å›å½“å‰æ•…äº‹æ•°æ®
    return null;
  }, []);

  // è®¡ç®—æ´¾ç”ŸçŠ¶æ€
  const isGameActive = gameState.gameStatus === 'playing' || gameState.gameStatus === 'paused';
  const currentDay = gameState.currentDay;

  // åˆå§‹åŒ–ï¼ˆå¦‚æœæä¾›äº†åˆå§‹é…ç½®ï¼‰
  useEffect(() => {
    if (initialConfig && !controller && !isInitialized) {
      initialize(initialConfig);
    }
  }, [initialConfig, controller, isInitialized, initialize]);

  return {
    controller,
    isInitialized,
    isLoading,
    error,
    gameState,
    isGameActive,
    currentDay,
    initialize,
    startNewGame,
    makeChoice,
    advanceDay,
    completeDay,
    canAdvanceToDay,
    getAvailableChoices,
    getCurrentStory
  };
};

// é»˜è®¤é…ç½®
export const DEFAULT_GAME_CONFIG: GameConfig = {
  debugMode: false,
  autoSaveInterval: 300000, // 5åˆ†é’Ÿ
  maxSaveSlots: 5,
  startingAttributes: {
    hunger: 50,
    energy: 100,
    sanity: 100,
    intelligence: 50,
    strength: 50,
    speed: 50,
    luck: 50
  },
  professionModifiers: {
    'å­¦ç”Ÿ': { intelligence: 10 },
    'åŒ»ç”Ÿ': { sanity: 10 },
    'å¾‹å¸ˆ': { intelligence: 15 },
    'è€äºº': { wisdom: 20 },
    'æ®‹ç–¾äºº': { empathy: 15 }
  },
  enableAnimations: true,
  enableSound: true,
  qualityPreset: 'medium'
};
```

### 4. å…³é”®æŠ€æœ¯ç‚¹
- **å¼‚æ­¥æµç¨‹æ§åˆ¶**ï¼šå®Œæ•´çš„Promiseé“¾å’Œé”™è¯¯å¤„ç†
- **çŠ¶æ€ä¸€è‡´æ€§**ï¼šæ¸¸æˆçŠ¶æ€çš„åŸå­æ€§æ›´æ–°å’ŒéªŒè¯
- **æ¨¡å—åŒ–é›†æˆ**ï¼šå„Epicæ¨¡å—çš„æ— ç¼å¯¹æ¥
- **é”™è¯¯æ¢å¤**ï¼šå¤šå±‚æ¬¡é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜æœºåˆ¶å’Œæ‡’åŠ è½½ç­–ç•¥
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰

### 5. ä¾èµ–é¡¹
- Epic2å­˜å‚¨ç³»ç»Ÿï¼ˆæ•°æ®æŒä¹…åŒ–ï¼‰
- Epic3è„šæœ¬è§£æï¼ˆæ•…äº‹å†…å®¹åŠ è½½ï¼‰
- Epic4çŠ¶æ€ç®¡ç†ï¼ˆæ¸¸æˆçŠ¶æ€ç»´æŠ¤ï¼‰
- Epic5UIç»„ä»¶ï¼ˆç•Œé¢äº¤äº’ï¼‰
- Epic6åœ°å›¾ç»„ä»¶ï¼ˆçœä»½é€‰æ‹©ï¼‰

## Milestone

**ç¬¬ä¸€é˜¶æ®µï¼ˆå½“å‰è¿›è¡Œï¼‰**ï¼š
- ğŸ”„ æµç¨‹æ§åˆ¶å™¨æ¶æ„è®¾è®¡ï¼ˆ45åˆ†é’Ÿï¼‰
- ğŸ”„ æ ¸å¿ƒæµç¨‹å®ç°ï¼ˆ60åˆ†é’Ÿï¼‰
- ğŸ”„ é”™è¯¯å¤„ç†æœºåˆ¶ï¼ˆ30åˆ†é’Ÿï¼‰

**ç¬¬äºŒé˜¶æ®µï¼ˆå¾…å®Œæˆï¼‰**ï¼š
- ğŸ“‹ React Hookå°è£…ï¼ˆ30åˆ†é’Ÿï¼‰
- ğŸ“‹ é›†æˆæµ‹è¯•å¼€å‘ï¼ˆ45åˆ†é’Ÿï¼‰
- ğŸ“‹ æ€§èƒ½ä¼˜åŒ–å’ŒéªŒè¯ï¼ˆ30åˆ†é’Ÿï¼‰

**ç¬¬ä¸‰é˜¶æ®µï¼ˆå¾…å®Œæˆï¼‰**ï¼š
- ğŸ“‹ å•å…ƒæµ‹è¯•æ‰§è¡Œï¼ˆ30åˆ†é’Ÿï¼‰
- ğŸ“‹ æ–‡æ¡£å®Œå–„å’ŒçŠ¶æ€æ›´æ–°ï¼ˆ15åˆ†é’Ÿï¼‰

## æµ‹è¯•æ–¹æ¡ˆ

### åŠŸèƒ½ç‚¹æµ‹è¯•
- æ¸¸æˆåˆå§‹åŒ–æµç¨‹ï¼ˆé…ç½®éªŒè¯â†’æ¨¡å—åŠ è½½â†’çŠ¶æ€å‡†å¤‡ï¼‰
- æ–°æ¸¸æˆå¼€å§‹æµç¨‹ï¼ˆç©å®¶ä¿¡æ¯â†’çŠ¶æ€åˆ›å»ºâ†’æ•…äº‹åŠ è½½ï¼‰
- é€‰æ‹©å¤„ç†æµç¨‹ï¼ˆéªŒè¯â†’æ•ˆæœåº”ç”¨â†’çŠ¶æ€æ›´æ–°â†’æ¡ä»¶æ£€æŸ¥ï¼‰
- å¤©æ•°æ¨è¿›æµç¨‹ï¼ˆè§£é”â†’æ•°æ®åŠ è½½â†’çŠ¶æ€æ›´æ–°ï¼‰
- æ¸¸æˆç»“æŸæµç¨‹ï¼ˆèƒœåˆ©/å¤±è´¥â†’æ€»ç»“ç”Ÿæˆâ†’å­˜æ¡£åˆ›å»ºï¼‰

### å¼‚å¸¸æµ‹è¯•
- æ¨¡å—åˆå§‹åŒ–å¤±è´¥å¤„ç†
- æ— æ•ˆç©å®¶ä¿¡æ¯å¤„ç†
- æ•…äº‹æ•°æ®åŠ è½½å¤±è´¥å¤„ç†
- é€‰æ‹©éªŒè¯å¤±è´¥å¤„ç†
- çŠ¶æ€æ›´æ–°å¼‚å¸¸å¤„ç†
- å­˜æ¡£æ“ä½œå¤±è´¥å¤„ç†

### æ€§èƒ½éªŒè¯
- å®Œæ•´æµç¨‹æ‰§è¡Œæ—¶é—´<3ç§’ï¼ˆæ€§èƒ½åŸºå‡†ï¼‰
- é€‰æ‹©å¤„ç†å“åº”æ—¶é—´<200ms
- çŠ¶æ€æ›´æ–°å»¶è¿Ÿ<50ms
- é”™è¯¯æ¢å¤æ—¶é—´<500ms
- å†…å­˜ä½¿ç”¨ç¨³å®šæ€§ï¼ˆ<100MBå³°å€¼ï¼‰