# Epic2-子任务01: 本地存储系统开发

## 开发状态
已测试 → 子任务开发完成

## 开发方案

### 1. 开发目标
实现完整的本地存储系统，支持游戏存档的保存、读取和清除功能，确保数据可靠性和操作性能。

### 2. 设计方案
- 使用浏览器localStorage作为主要存储方式
- 设计JSON格式的存档数据结构
- 实现存档验证和错误处理机制
- 提供React Hook接口供组件使用

### 3. 实现方式

#### 3.1 存储数据结构设计
```typescript
// src/types/storage.ts
import { GameState, Profession, RulePaper, ClearRule } from './game';

// 存档版本号，用于兼容性处理
export const SAVE_VERSION = '1.0.0';

// 完整的游戏存档数据结构
export interface GameSaveData {
  version: string;                    // 存档版本号
  playerName: string;                 // 玩家名称
  profession: Profession;             // 职业选择
  gameState: GameState;               // 游戏状态
  rulePapers: RulePaper[];            // 规则纸条状态
  clearRules: ClearRule[];            // 通关条件状态
  currentDay: number;                 // 当前天数
  currentNode: string;                // 当前故事节点
  gameConfigPath: string;             // 游戏配置文件路径
  lastSaveTime: number;               // 最后保存时间戳
  createdTime: number;                // 存档创建时间
  saveCount: number;                  // 保存次数
}

// 存储管理器配置
export interface StorageConfig {
  storageKey: string;                 // localStorage键名
  maxSaveSlots: number;               // 最大存档槽位数
  autoSaveInterval: number;           // 自动保存间隔（毫秒）
  compressionEnabled: boolean;        // 是否启用压缩
}
```

#### 3.2 核心存储管理器实现
```typescript
// src/utils/storageManager.ts
import { GameSaveData, StorageConfig } from '../types/storage';

export class StorageManager {
  private config: StorageConfig;
  private storage: Storage;

  constructor(config: StorageConfig = {
    storageKey: 'rulegame_save',
    maxSaveSlots: 5,
    autoSaveInterval: 300000, // 5分钟
    compressionEnabled: true
  }) {
    this.config = config;
    this.storage = window.localStorage;
  }

  /**
   * 保存游戏存档
   */
  async save(data: GameSaveData): Promise<boolean> {
    try {
      // 数据验证
      if (!this.validate(data)) {
        throw new Error('Invalid save data format');
      }

      // 获取现有存档
      const saves = await this.getAllSaves();
      
      // 检查存档槽位限制
      if (saves.length >= this.config.maxSaveSlots) {
        // 删除最旧的存档
        saves.sort((a, b) => a.lastSaveTime - b.lastSaveTime);
        saves.shift();
      }

      // 更新存档数据
      const saveData = {
        ...data,
        lastSaveTime: Date.now(),
        saveCount: (data.saveCount || 0) + 1
      };

      // 序列化数据
      const serializedData = JSON.stringify(saveData);
      
      // 存储数据
      const key = `${this.config.storageKey}_${data.playerName}_${data.currentDay}`;
      this.storage.setItem(key, serializedData);

      // 更新存档索引
      const saveIndex = saves.findIndex(save => 
        save.playerName === data.playerName && save.currentDay === data.currentDay
      );
      
      if (saveIndex >= 0) {
        saves[saveIndex] = saveData;
      } else {
        saves.push(saveData);
      }
      
      this.updateSaveIndex(saves);
      
      console.log(`Game saved successfully: ${key}`);
      return true;
    } catch (error) {
      console.error('Failed to save game:', error);
      return false;
    }
  }

  /**
   * 加载游戏存档
   */
  async load(playerName: string, day: number): Promise<GameSaveData | null> {
    try {
      const key = `${this.config.storageKey}_${playerName}_${day}`;
      const data = this.storage.getItem(key);
      
      if (!data) {
        return null;
      }

      const parsedData = JSON.parse(data) as GameSaveData;
      
      // 验证数据格式
      if (!this.validate(parsedData)) {
        console.warn('Invalid save data format, attempting recovery...');
        return this.attemptDataRecovery(parsedData);
      }

      console.log(`Game loaded successfully: ${key}`);
      return parsedData;
    } catch (error) {
      console.error('Failed to load game:', error);
      return null;
    }
  }

  /**
   * 获取所有存档
   */
  async getAllSaves(): Promise<GameSaveData[]> {
    try {
      const saves: GameSaveData[] = [];
      const keys = this.getSaveKeys();
      
      for (const key of keys) {
        const data = this.storage.getItem(key);
        if (data) {
          try {
            const parsedData = JSON.parse(data) as GameSaveData;
            if (this.validate(parsedData)) {
              saves.push(parsedData);
            }
          } catch (error) {
            console.warn(`Failed to parse save data for key: ${key}`, error);
          }
        }
      }
      
      return saves.sort((a, b) => b.lastSaveTime - a.lastSaveTime);
    } catch (error) {
      console.error('Failed to get all saves:', error);
      return [];
    }
  }

  /**
   * 清除指定存档
   */
  async clear(playerName: string, day: number): Promise<boolean> {
    try {
      const key = `${this.config.storageKey}_${playerName}_${day}`;
      this.storage.removeItem(key);
      
      // 更新存档索引
      const saves = await this.getAllSaves();
      const filteredSaves = saves.filter(save => 
        !(save.playerName === playerName && save.currentDay === day)
      );
      this.updateSaveIndex(filteredSaves);
      
      console.log(`Save cleared successfully: ${key}`);
      return true;
    } catch (error) {
      console.error('Failed to clear save:', error);
      return false;
    }
  }

  /**
   * 清除所有存档
   */
  async clearAll(): Promise<boolean> {
    try {
      const keys = this.getSaveKeys();
      keys.forEach(key => this.storage.removeItem(key));
      this.storage.removeItem(`${this.config.storageKey}_index`);
      
      console.log('All saves cleared successfully');
      return true;
    } catch (error) {
      console.error('Failed to clear all saves:', error);
      return false;
    }
  }

  /**
   * 数据验证
   */
  validate(data: any): boolean {
    if (!data || typeof data !== 'object') return false;
    
    const requiredFields = [
      'version', 'playerName', 'profession', 'gameState', 
      'currentDay', 'currentNode', 'lastSaveTime', 'createdTime'
    ];
    
    for (const field of requiredFields) {
      if (!(field in data)) return false;
    }
    
    // 验证版本兼容性
    if (data.version !== '1.0.0') {
      console.warn(`Save data version mismatch: expected 1.0.0, got ${data.version}`);
      return false;
    }
    
    // 验证游戏状态数据
    if (!this.validateGameState(data.gameState)) return false;
    
    return true;
  }

  /**
   * 验证游戏状态
   */
  private validateGameState(gameState: any): boolean {
    if (!gameState || typeof gameState !== 'object') return false;
    
    const requiredStats = [
      'time', 'profession', 'hunger', 'energy', 'sanity',
      'intelligence', 'strength', 'speed', 'luck'
    ];
    
    for (const stat of requiredStats) {
      if (!(stat in gameState) || typeof gameState[stat] !== 'number') {
        return false;
      }
    }
    
    // 验证数值范围
    if (gameState.hunger < 0 || gameState.hunger > 100) return false;
    if (gameState.energy < 0 || gameState.energy > 100) return false;
    if (gameState.sanity < 0 || gameState.sanity > 100) return false;
    
    return true;
  }

  /**
   * 数据恢复尝试
   */
  private attemptDataRecovery(data: any): GameSaveData | null {
    try {
      // 尝试恢复缺失的字段
      const recoveredData: GameSaveData = {
        version: data.version || '1.0.0',
        playerName: data.playerName || 'Unknown',
        profession: data.profession || '学生',
        gameState: data.gameState || this.getDefaultGameState(),
        rulePapers: data.rulePapers || [],
        clearRules: data.clearRules || [],
        currentDay: data.currentDay || 1,
        currentNode: data.currentNode || 'start',
        gameConfigPath: data.gameConfigPath || '',
        lastSaveTime: data.lastSaveTime || Date.now(),
        createdTime: data.createdTime || Date.now(),
        saveCount: data.saveCount || 0
      };
      
      return this.validate(recoveredData) ? recoveredData : null;
    } catch (error) {
      console.error('Data recovery failed:', error);
      return null;
    }
  }

  /**
   * 获取默认游戏状态
   */
  private getDefaultGameState() {
    return {
      time: 0,
      profession: '学生',
      hunger: 50,
      energy: 100,
      sanity: 100,
      intelligence: 50,
      strength: 50,
      speed: 50,
      luck: 50
    };
  }

  /**
   * 获取存档键名列表
   */
  private getSaveKeys(): string[] {
    const keys: string[] = [];
    for (let i = 0; i < this.storage.length; i++) {
      const key = this.storage.key(i);
      if (key && key.startsWith(`${this.config.storageKey}_`)) {
        keys.push(key);
      }
    }
    return keys;
  }

  /**
   * 更新存档索引
   */
  private updateSaveIndex(saves: GameSaveData[]): void {
    const indexData = saves.map(save => ({
      playerName: save.playerName,
      currentDay: save.currentDay,
      lastSaveTime: save.lastSaveTime,
      saveCount: save.saveCount
    }));
    
    this.storage.setItem(`${this.config.storageKey}_index`, JSON.stringify(indexData));
  }

  /**
   * 检查存储空间
   */
  getStorageUsage(): { used: number; remaining: number; total: number } {
    try {
      let used = 0;
      for (let i = 0; i < this.storage.length; i++) {
        const key = this.storage.key(i);
        if (key) {
          const value = this.storage.getItem(key);
          if (value) {
            used += key.length + value.length;
          }
        }
      }
      
      // localStorage通常限制为5MB
      const total = 5 * 1024 * 1024; // 5MB
      const remaining = Math.max(0, total - used);
      
      return { used, remaining, total };
    } catch (error) {
      console.error('Failed to check storage usage:', error);
      return { used: 0, remaining: 0, total: 0 };
    }
  }
}
```

#### 3.3 React Hook封装
```typescript
// src/hooks/useStorage.ts
import { useState, useEffect, useCallback } from 'react';
import { StorageManager } from '../utils/storageManager';
import { GameSaveData } from '../types/storage';

export interface UseStorageReturn {
  save: (data: GameSaveData) => Promise<boolean>;
  load: (playerName: string, day: number) => Promise<GameSaveData | null>;
  getAllSaves: () => Promise<GameSaveData[]>;
  clear: (playerName: string, day: number) => Promise<boolean>;
  clearAll: () => Promise<boolean>;
  isLoading: boolean;
  error: string | null;
  storageUsage: { used: number; remaining: number; total: number };
}

export const useStorage = (): UseStorageReturn => {
  const [storageManager] = useState(() => new StorageManager());
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [storageUsage, setStorageUsage] = useState({ used: 0, remaining: 0, total: 0 };

  // 更新存储使用情况
  const updateStorageUsage = useCallback(() => {
    const usage = storageManager.getStorageUsage();
    setStorageUsage(usage);
  }, [storageManager]);

  useEffect(() => {
    updateStorageUsage();
  }, [updateStorageUsage]);

  const save = useCallback(async (data: GameSaveData) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await storageManager.save(data);
      updateStorageUsage();
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [storageManager, updateStorageUsage]);

  const load = useCallback(async (playerName: string, day: number) => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await storageManager.load(playerName, day);
      return data;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [storageManager]);

  const getAllSaves = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const saves = await storageManager.getAllSaves();
      updateStorageUsage();
      return saves;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [storageManager, updateStorageUsage]);

  const clear = useCallback(async (playerName: string, day: number) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await storageManager.clear(playerName, day);
      updateStorageUsage();
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [storageManager, updateStorageUsage]);

  const clearAll = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await storageManager.clearAll();
      updateStorageUsage();
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [storageManager, updateStorageUsage]);

  return {
    save,
    load,
    getAllSaves,
    clear,
    clearAll,
    isLoading,
    error,
    storageUsage
  };
};
```

### 4. 关键技术点
- localStorage异步操作封装
- 数据完整性验证
- 存档版本兼容性处理
- 存储空间限制检测（5MB）

### 5. 依赖项
- Epic1完成的项目基础架构
- 浏览器localStorage API
- TypeScript类型系统
- JSON序列化/反序列化

## Milestone

- Day 1: 存储结构设计和技术方案确定
- Day 2: 核心存储功能开发和测试
- Day 3: React Hook封装和集成测试

## 测试方案

### 功能点测试
- 存档保存功能（数据完整性）
- 存档读取功能（数据恢复准确性）
- 存档清除功能（完全删除验证）
- 存档存在性检查

### 异常测试
- localStorage不可用降级处理
- 存储空间不足错误处理
- 数据损坏恢复机制
- 浏览器隐私模式处理

### 性能验证
- 存档保存响应时间<100ms
- 存档读取响应时间<50ms
- 大容量数据存储测试（边界值）